Disassembly Listing for SeniorDesign
Generated From:
C:/Users/cmh52/Desktop/SeniorDesign.X/dist/default/debug/SeniorDesign.X.debug.elf
Mar 15, 2019 3:57:21 PM

---  C:/Users/cmh52/Desktop/SeniorDesign.X/serial_uart.c  -----------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: serial_uart.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 0.01
12:             */
13:            
14:            #include "serial_uart.h"
15:            
16:            // ************************************************************
17:            //
18:            //  This function initializes the UART that is used to 
19:            //  communicate between the GNSS 5 Click module and the PIC.
20:            //  The UART bus is set up to
21:            //
22:            //      COMMENT NOT COMPLETE
23:            //
24:            // ************************************************************
25:            void UART_Initialize(void) {
26:                
27:                //Initialize UART for Asynchronous 8-bit receive and transmission
28:                BAUD1CON = 0x08;
02BB  3008     MOVLW 0x8
02BC  0022     MOVLB 0x2
02BD  009F     MOVWF BAUD1CON
29:                TX1STA = 0x24;
02BE  3024     MOVLW 0x24
02BF  009E     MOVWF TX1STA
30:                RC1STA = 0x90;
02C0  3090     MOVLW 0x90
02C1  009D     MOVWF RC1STA
31:                
32:                //Set Baud rate - 115.2k
33:                SP1BRGL = 0x44;//0x44;    
02C2  3044     MOVLW 0x44
02C3  009B     MOVWF SP1BRG
34:                SP1BRGH = 0x00;
02C4  019C     CLRF SP1BRGH
35:            
36:                //Clear Interrupt flags - CMH
37:                PIR3bits.RCIF = 0;
02C5  002E     MOVLB 0xE
02C6  128F     BCF PIR3, 0x5
38:            
39:            }
02C7  0008     RETURN
40:            
41:            // ************************************************************
42:            //
43:            //  This function reads in data through UART. It first checks
44:            //  to make sure all the various flag are set and looks for an
45:            //  over run error. It then receives the byte of data and clears
46:            //  the necessary flags. The received data is then returned from
47:            //  the function as an unsigned 8bit integer.
48:            //
49:            // ************************************************************
50:            uint8_t UART_Read(void) {
51:                
52:                //Variable for received byte - CMH
53:                uint8_t c;
54:            
55:                //Wait until the receive interrupt flag is set - CMH
56:                while(!(PIR3bits.RCIF));
57:                
58:                if(RC1STAbits.OERR) // check for over run error  - CMH
59:                {
60:                    RC1STAbits.CREN = 0;
61:                    RC1STAbits.CREN = 1; //Reset CREN - CMH
62:                }
63:                //Clear interrupt on change flag - CMH
64:                IOCCFbits.IOCCF0 = 0;
65:                
66:                //Read byte from RC1REG and clear receive interrupt
67:                // flag if receive interrupt flag is set - CMH
68:                if(PIR3bits.RCIF == 1)
69:                {
70:                   c = RC1REG;          //Save received byte in variable - CMH
71:                   PIR3bits.RCIF = 0;   //Clear receive interrupt flag - CMH
72:                }
73:                
74:                //Return received character - CMH
75:                return c;
76:                
77:            }
78:            
79:            // ************************************************************
80:            //
81:            //  This function acts as the write command to be used with
82:            //  printf. It takes in a unsigned 8bit integer as the value
83:            //  to be sent. It then waits until both the transmission 
84:            //  interrupt flag and TRMT are set. The byte is stored in
85:            //  the Transmission register to be sent.
86:            //
87:            // ************************************************************
88:            void putch(unsigned char byte)  
89:            {
90:                //Wait while TXIF and TRMT both are not set - CMH
91:                while(!(PIR3bits.TXIF) && !(TX1STAbits.TRMT)); 
92:                
93:                //Set TX1REG equal to byte - CMH
94:                TX1REG = byte;
95:            }
---  C:/Users/cmh52/Desktop/SeniorDesign.X/serial_spi.c  ------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: serial_spi.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 1.0
12:             */
13:            
14:            #include "serial_spi.h"
15:            
16:            // ************************************************************
17:            //
18:            //  This function initializes the SPI on SSP2 for use between
19:            //  the PIC and the ETH WIZ Click Module. It sets the PIC to
20:            //  be the master, to send a clock of 32 MHz, and to run in
21:            //  SPI Mode 0. It also clears the respective interrupt 
22:            //  flag.
23:            //
24:            // ************************************************************
25:            void SPI_ETHWIZ_Initialize(void) {
26:                
27:                SSP2STAT = 0b11000000;    //Sets sampling to middle of data output time and
0259  30C0     MOVLW 0xC0
025A  0023     MOVLB 0x3
025B  0099     MOVWF SSP2STAT
28:                                    //sets CLK Edge for transmit on transition from active
29:                                    //to idle state - CMH
30:                
31:                SSP2CON1 = 0x20;    //Enables SPI as Master, Sets CLK Idle to low, and
025C  3020     MOVLW 0x20
025D  009A     MOVWF SSP2CON1
32:                                    //CLK = Fosc/4 = 8MHz - CMH
33:                
34:                SSP2IF = 0;         //Clear interrupt flag - CMH
025E  002E     MOVLB 0xE
025F  110F     BCF PIR3, 0x2
35:              
36:            }
0260  0008     RETURN
37:            
38:            // ************************************************************
39:            //
40:            //  This function writes data to the ETH WIZ through the SPI bus
41:            //  on SSP2. It takes in an unsigned 8bit integer and immediately
42:            //  puts the value into the buffer to be sent. The program then
43:            //  waits for the interrupt flag to be set, signaling the 
44:            //  transmission is complete. The flag is then cleared. This
45:            //  function also doubles as a SPI Read function because the
46:            //  new value in the buffer that came from the ETH WIZ is returned
47:            //  from the function as an unsigned 8bit integer.
48:            //
49:            // ************************************************************
50:            uint8_t SPI_ETHWIZ_Write(uint8_t data) {
028D  00F0     MOVWF 0x770
51:                    
52:                SSP2BUF = data;             //Store value to be sent in buffer - CMH
028E  0870     MOVF 0x770, W
028F  0023     MOVLB 0x3
0290  0096     MOVWF SSP2BUF
53:                while(!SSP2IF) continue;    /*Wait for Interrupt Flag to signal 
0291  002E     MOVLB 0xE
0292  1D0F     BTFSS PIR3, 0x2
0293  2A91     GOTO 0x291
54:                                              transmission complete - CMH*/
55:                SSP2IF = 0;                 //Clear interrupt flag - CMH
0294  110F     BCF PIR3, 0x2
56:                return(SSP2BUF);            //Return received value - CMH
0295  0023     MOVLB 0x3
0296  0816     MOVF SSP2BUF, W
0297  0008     RETURN
57:                
58:            }
59:            
60:            // ************************************************************
61:            //
62:            //  This function initializes the SPI bus on SSP1 to work with
63:            //  the FLIR Lepton thermal camera. It sets the PIC to be the 
64:            //  master, to send a clock of 8 MHz, and to run in SPI mode 3.
65:            //  The respective interrupt flag is also cleared.
66:            //
67:            // ************************************************************
68:            void SPI_FLIR_Initialize(void) {
69:                SSP1STAT = 0b10000000;  //Sets sampling to end of data output time and
0261  3080     MOVLW 0x80
0262  0023     MOVLB 0x3
0263  008F     MOVWF SSP1STAT
70:                                        //sets CLK Edge for transmit on transition from idle
71:                                        //to active state - CMH
72:                
73:                SSP1CON1 = 0b00110000;  //Enables SPI as Master, Sets CLK Idle to high, and
0264  3030     MOVLW 0x30
0265  0090     MOVWF SSP1CON1
74:                                        //CLK = Fosc/(4*(SSP1ADD+1)) - CMH
75:                //SSP1ADD = 0x01;       //CLK = 4 MHz
76:                //SSP1IE = 1;
77:                SSP1IF = 0;             //Clear interrupt flag - CMH
0266  002E     MOVLB 0xE
0267  100F     BCF PIR3, 0x0
78:              
79:            }
0268  0008     RETURN
80:            
81:            // ************************************************************
82:            //
83:            //  This function initializes the SPI bus on SSP1 to work with
84:            //  the Arducam visual camera. It sets the PIC to be the 
85:            //  master, to send a clock of 8 MHz, and to run in SPI mode 0.
86:            //  The respective interrupt flag is also cleared.
87:            //
88:            // ************************************************************
89:            void SPI_Arducam_Initialize(void) {
90:                
91:                SSP1STAT = 0b11000000;    //Sets sampling to end of data output time and
0251  30C0     MOVLW 0xC0
0252  0023     MOVLB 0x3
0253  008F     MOVWF SSP1STAT
92:                                    //sets CLK Edge for transmit on transition from active
93:                                    //to idle state - CMH
94:                
95:                SSP1CON1 = 0b00100000;    //Enables SPI as Master, Sets CLK Idle to low, and
0254  3020     MOVLW 0x20
0255  0090     MOVWF SSP1CON1
96:                                    //CLK = Fosc/4 = 8MHz - CMHH
97:                        
98:                SSP1IF = 0;         //Clear interrupt flag - CMH
0256  002E     MOVLB 0xE
0257  100F     BCF PIR3, 0x0
99:              
100:           }
0258  0008     RETURN
101:           
102:           // ************************************************************
103:           //
104:           //  This function is the SPI write function for the SPI bus on
105:           //  SSP1. It takes in an unsigned 8bit integer and immediately
106:           //  puts the value into the buffer to be sent. The program then
107:           //  waits for the interrupt flag to be set, signaling the 
108:           //  transmission is complete. The flag is then cleared. This
109:           //  function also doubles as a SPI Read function because the
110:           //  new value in the buffer that came from the slave is returned
111:           //  from the function as an unsigned 8bit integer.
112:           //
113:           // ************************************************************
114:           uint8_t SPI_Write(uint8_t data) {
115:               
116:               SSP1BUF = data;             //Store value to be sent in buffer - CMH
117:               while(!SSP1IF) continue;    /*Wait for Interrupt Flag to signal 
118:                                             transmission complete - CMH*/
119:               SSP1IF = 0;                 //Clear the interrupt flag - CMH
120:               return(SSP1BUF);            //Return received value - CMH
121:               
122:           }
123:           
124:           
---  C:/Users/cmh52/Desktop/SeniorDesign.X/serial_i2c.c  ------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: serial_i2c.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 1.00
12:             */
13:            
14:            #include "serial_i2c.h"
15:            
16:            
17:            // ************************************************************
18:            //
19:            //  This function initializes the I2C bus on the PIC. I2C 
20:            //  will be used only in the first portion of the program
21:            //  to set the required settings on both the FLIR Lepton
22:            //  thermal camera and the Arducam 2MP visual camera.
23:            //
24:            // ************************************************************
25:            void i2c_initialize(void) {
26:                
27:                SSP2CON1 = 0x28;        //ON with Master Mode - CMH
0271  3028     MOVLW 0x28
0272  0023     MOVLB 0x3
0273  009A     MOVWF SSP2CON1
28:                SSP2CON2 = 0x00;        //Clear Flags - CMH
0274  019B     CLRF SSP2CON2
29:                SSP2ADD = 0x4F;         //100 kHz with 4MHz clock - CMH
0275  304F     MOVLW 0x4F
0276  0097     MOVWF SSP2ADD
30:                SSP2STATbits.CKE = 0;   //Use I2C signal levels - CMH
0277  1319     BCF SSP2STAT, 0x6
31:                SSP2STATbits.SMP = 1;   //Standard Speed Mode - CMH
0278  1799     BSF SSP2STAT, 0x7
32:            }
0279  0008     RETURN
33:            
34:            // ************************************************************
35:            //
36:            //  This function is responsible for waiting for the I2C data
37:            //  line to idle. It is used in many of the I2C functions 
38:            //  written below.
39:            //
40:            // ************************************************************
41:            void i2c_waitForIdle()
42:            {
43:                //Waits for the I2C data line to idle - CMH
44:                while((SSP2CON2 & 0x1F)| SSP2STATbits.R_nW){};
0298  0023     MOVLB 0x3
0299  0C19     RRF SSP2STAT, W
029A  0C89     RRF 0x189, F
029B  3901     ANDLW 0x1
029C  00F0     MOVWF 0x1F0
029D  081B     MOVF SSP2CON2, W
029E  391F     ANDLW 0x1F
029F  0470     IORWF 0x1F0, W
02A0  1903     BTFSC 0x183, 0x2
02A1  0008     RETURN
02A2  2A98     GOTO 0x298
45:            }
46:            
47:            // ************************************************************
48:            //
49:            //  This function starts the I2C communication. It waits for
50:            //  an idle data line and then sends the start condition.
51:            //
52:            // ************************************************************
53:            void i2c_start()
54:            {
55:                //Wait for Idle - CMH
56:                i2c_waitForIdle();
0241  3182     MOVLP 0x2
0242  2298     CALL 0x298
57:                
58:                //Send Start Condition - CMH
59:                SSP2CON2bits.SEN = 1;
0243  0023     MOVLB 0x3
0244  141B     BSF SSP2CON2, 0x0
60:            }
0245  0008     RETURN
61:            
62:            // ************************************************************
63:            //
64:            //  This function sends a repeat start signal for the I2C bus.
65:            //  It functions as a simultaneous stop then start signal. It
66:            //  waits for I2C to idle then send the repeat start condition.
67:            //
68:            // ************************************************************
69:            void i2c_repStart()
70:            {
71:                //Wait for Idle - CMH
72:                i2c_waitForIdle();
73:                
74:                //Send Restart Condition - CMH
75:                SSP2CON2bits.RSEN = 1;
76:            }
77:            
78:            // ************************************************************
79:            //
80:            //  This function stops transmission on the I2C bus. It waits
81:            //  for idle then sends the stop condition.
82:            //
83:            // ************************************************************
84:            void i2c_stop()
85:            {
86:                //Wait for Idle - CMH
87:                i2c_waitForIdle();
0246  3182     MOVLP 0x2
0247  2298     CALL 0x298
88:                
89:                //Send Stop condition - CMH
90:                SSP2CON2bits.PEN = 1;
0248  0023     MOVLB 0x3
0249  151B     BSF SSP2CON2, 0x2
91:            }
024A  0008     RETURN
92:            
93:            // ************************************************************
94:            //
95:            //  This function reads in data being sent from a slave over
96:            //  the I2C data line. Takes in an unsigned 8bit integer variable 
97:            //  that that should be either a 0 when it is the last byte
98:            //  to be received or a 1 when there are still more bytes to
99:            //  be received. The received data is returned from the function
100:           //  as an unsigned 8bit integer.
101:           //
102:           // ************************************************************
103:           uint8_t i2c_read( uint8_t ack )
104:           {
105:               
106:               uint8_t readData;           //Variable for received data - CMH
107:               
108:               i2c_waitForIdle();          //Wait for Idle - CMH
109:               
110:               SSP2CON2bits.RCEN = 1;      //Enables data reception for a byte - CMH
111:               
112:               i2c_waitForIdle();          //Wait for Idle - CMH
113:               
114:               readData = SSP1BUF;         //Read in the data from the buffer - CMH
115:               
116:               i2c_waitForIdle();          //Wait for Idle - CMH
117:               
118:               //If the not last byte of data, then... else... - CMH
119:               if (ack){
120:                   SSP2CON2bits.ACKDT = 0; //Acknowledge low for more data - CMH
121:               }
122:               else{
123:                   SSP2CON2bits.ACKDT = 1; //Acknowledge high after final byte - CMH
124:               }
125:               
126:               SSP2CON2bits.ACKEN = 1;     //Send Acknowledge sequence - CMH
127:               
128:               return(readData);           //Return the received data - CMH
129:               
130:           }
131:           
132:           
133:           // ************************************************************
134:           //
135:           //  This function writes data to a slave device through the I2C
136:           //  data line. It takes in an unsigned 8bit integer value, waits
137:           //  for idle, then writes the value to the buffer. The function
138:           //  returns the current state of the acknowledge bit.
139:           //
140:           // ************************************************************
141:           uint8_t i2c_write( uint8_t i2cWriteData )
0269  00F1     MOVWF 0x1F1
142:           {
143:               //Wait for Idle - CMH
144:               i2c_waitForIdle();
026A  3182     MOVLP 0x2
026B  2298     CALL 0x298
145:               
146:               //Write to Buffer to start transmission - CMH
147:               SSP2BUF = i2cWriteData;
026C  0871     MOVF 0x1F1, W
026D  0023     MOVLB 0x3
026E  0096     MOVWF SSP2BUF
148:               
149:               //Returns 1 if transmission is acknowledged - CMH
150:               return(!SSP2CON2bits.ACKSTAT);
026F  081B     MOVF SSP2CON2, W
0270  0008     RETURN
151:               
152:           }
---  C:/Users/cmh52/Desktop/SeniorDesign.X/main.c  ------------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: main.c
8:              * 
9:              * Date Created: 1/14/19
10:             * 
11:             * Revision Date: 3/7/19
12:             * 
13:             * Revision: 0.45
14:             */
15:            
16:            #include "config.h"
17:            #include "serial_uart.h"
18:            #include "serial_i2c.h"
19:            #include "serial_spi.h"
20:            #include "lepton.h"
21:            #include "arducam.h"
22:            #include "eth_wiz.h"
23:            #include "gnss5.h"
24:            
25:            
26:            //Mission Stage Check variable. Will increment through different 
27:            //stages when signal received from ground station - CMH
28:            uint8_t mission_stage_check = 1; //CHANGE TO 0 for final program - CMH
29:            
30:            //Thermal Image Variables - CMH
31:            uint8_t packet_length = 164;    //Length of single VoSPI packet from FLIR - CMH
32:            uint8_t image_packet[164];      //Array for storage of VoSPI packet - CMH
33:            uint8_t num_of_packets = 60;    //Number of packets when telemetry disabled - CMH
34:            uint8_t packet_index = 60;      //Current index of received packets - CMH
35:            uint8_t discard = 0;            //Discard packet flag - CMH
36:            uint8_t num_discard = 0;
37:            
38:            //GPS location variables. Need to turn location variables into strings - CMH
39:            uint16_t GPS_location = 0;          //location of hotspots. To be an array - CMH
40:            uint16_t GPS_location_current = 0;  //Current location of drone - CMH
41:            uint16_t GPS_array_length = 0;      //Length of hotspot location array - CMH
42:            
43:            
44:            //Function Declarations - CMH
45:            void lepton_capture_packet(void);
46:            void lepton_send_packet(void);
47:            extern void delay(void);
48:            
49:            
50:            // ************************************************************
51:            //
52:            //  This function acts as the main function of the program.
53:            //  The consists of three main stages. The first stage is for
54:            //  initializing everything like the serial buses, the cameras,
55:            //  etc. The second stage is for thermal image collection from
56:            //  from the FLIR Lepton and GPS locations from the GNSS 5.
57:            //  The third and final stage is for getting hotspot locations
58:            //  from the ground station, comparing the current GPS location
59:            //  to the list of hotspot locations, and taking a visual image 
60:            //  with the Arducam if at one of the hotspot locations.
61:            //
62:            // ************************************************************
63:            int main(int argc, char** argv) 
64:            {  
65:                //Setup the oscillator - CMH
66:                OSCILLATOR_Initialize();
0444  3182     MOVLP 0x2
0445  224B     CALL 0x24B
0446  3184     MOVLP 0x4
67:                
68:                //Run the first port pin initialization - CMH
69:                PORT_PIN_Initialize1();
0447  3183     MOVLP 0x3
0448  235C     CALL 0x35C
0449  3184     MOVLP 0x4
70:                
71:                //Initialize the I2C for camera setup - CMH
72:                i2c_initialize();
044A  3182     MOVLP 0x2
044B  2271     CALL 0x271
044C  3184     MOVLP 0x4
73:                
74:                //Initialize the Flir Lepton through the I2C - CMH
75:                lepton_initialize();
044D  3182     MOVLP 0x2
044E  22C8     CALL 0x2C8
044F  3184     MOVLP 0x4
76:                
77:                //Initialize the Arducam through the I2C - CMH
78:                arducam_initialize();
0450  3182     MOVLP 0x2
0451  223E     CALL 0x23E
0452  3184     MOVLP 0x4
79:                
80:                //Run the second Port Pin Initialization - CMH
81:                PORT_PIN_Initialize2();
0453  3182     MOVLP 0x2
0454  22E2     CALL 0x2E2
0455  3184     MOVLP 0x4
82:                
83:                //Initialize the UART for use with the GNSS 5 - CMH
84:                UART_Initialize();
0456  3182     MOVLP 0x2
0457  22BB     CALL 0x2BB
0458  3184     MOVLP 0x4
85:                
86:                //Initialize SPI for use with the ETH WIZ Click - CMH
87:                SPI_ETHWIZ_Initialize();
0459  3182     MOVLP 0x2
045A  2259     CALL 0x259
045B  3184     MOVLP 0x4
88:                
89:                //Initialize SPI for use with the FLIR Lepton - CMH
90:                SPI_FLIR_Initialize();
045C  3182     MOVLP 0x2
045D  2261     CALL 0x261
045E  3184     MOVLP 0x4
91:               
92:                //Pull RST pins high to de-assert - CMH
93:                PORTDbits.RD2 = 1; //ETH WIZ
045F  0020     MOVLB 0x0
0460  150F     BSF PORTD, 0x2
94:                PORTDbits.RD0 = 1; //GNSS 5    
0461  140F     BSF PORTD, 0x0
95:                
96:                //De-assert all Slave Select(SS) for SPI - CMH
97:                PORTCbits.RC0 = 1;  //FLIR
0462  140E     BSF PORTC, 0x0
98:                PORTDbits.RD1 = 1;  //ARDUCAM
0463  148F     BSF PORTD, 0x1
99:                PORTDbits.RD3 = 1;  //ETH WIZ
0464  158F     BSF PORTD, 0x3
100:               
101:               //Toggle SS for Flir to reset - CMH
102:               __delay_ms(1000);
0465  3029     MOVLW 0x29
0466  00FC     MOVWF 0x7C
0467  3096     MOVLW 0x96
0468  00FB     MOVWF 0x7B
0469  307F     MOVLW 0x7F
046A  0B89     DECFSZ WREG, F
046B  2C6A     GOTO 0x46A
046C  0BFB     DECFSZ 0x7B, F
046D  2C6A     GOTO 0x46A
046E  0BFC     DECFSZ 0x7C, F
046F  2C6A     GOTO 0x46A
0470  0000     NOP
103:               PORTCbits.RC0 = 0;
0471  0020     MOVLB 0x0
0472  100E     BCF PORTC, 0x0
104:               PORTCbits.RC0 = 1;
0473  140E     BSF PORTC, 0x0
105:               __delay_ms(500);
0474  3015     MOVLW 0x15
0475  00FC     MOVWF 0x7C
0476  304B     MOVLW 0x4B
0477  00FB     MOVWF 0x7B
0478  30BE     MOVLW 0xBE
0479  0B89     DECFSZ WREG, F
047A  2C79     GOTO 0x479
047B  0BFB     DECFSZ 0x7B, F
047C  2C79     GOTO 0x479
047D  0BFC     DECFSZ 0x7C, F
047E  2C79     GOTO 0x479
047F  3200     BRA 0x480
106:               
107:               //Initialize the settings on the ETH WIZ - CMH
108:               eth_wiz_configure();
0480  3185     MOVLP 0x5
0481  25B8     CALL 0x5B8
0482  3184     MOVLP 0x4
109:               
110:               //Create the socket for the ETH WIZ - CMH
111:               eth_wiz_createSocket();
0483  3184     MOVLP 0x4
0484  24EE     CALL 0x4EE
0485  3184     MOVLP 0x4
112:               
113:               //Wait until the start signal is given - CMH
114:               while(mission_stage_check == 0) {
0486  0020     MOVLB 0x0
0487  083C     MOVF mission_stage_check, W
0488  1903     BTFSC STATUS, 0x2
0489  2C86     GOTO 0x486
115:                   //This will contain code that is constantly polling the
116:                   //ETH WIZ to see if the start signal has been received. - CMH
117:               }
118:               
119:               
120:               uint8_t first_send = 0;
048A  01C4     CLRF first_send
121:               uint8_t IR_check = 0x00;
048B  01C3     CLRF IR_check
122:               //While still the thermal image stage - CMH
123:               while (mission_stage_check == 1)
048C  033C     DECF mission_stage_check, W
048D  1D03     BTFSS STATUS, 0x2
048E  2CD2     GOTO 0x4D2
124:               {
125:                   packet_index = -1;
048F  30FF     MOVLW 0xFF
0490  00FB     MOVWF 0x7B
0491  087B     MOVF 0x7B, W
0492  00B9     MOVWF packet_index
126:                   do{
127:                       //Capture a packet from the FLIR - CMH
128:                       lepton_capture_packet();
0493  3183     MOVLP 0x3
0494  23ED     CALL 0x3ED
0495  3184     MOVLP 0x4
129:                       
130:                       //if not the first time through
131:                       if(first_send == 1){
0496  0020     MOVLB 0x0
0497  0344     DECF first_send, W
0498  1D03     BTFSS STATUS, 0x2
0499  2CC7     GOTO 0x4C7
132:                           while(PORTBbits.RB0 == 1) continue;
049A  180D     BTFSC PORTB, 0x0
049B  2C9A     GOTO 0x49A
133:                           
134:                           //Wait for SEND_OK (complete) from previous send - CMH
135:                           do{
136:                               PORTDbits.RD3 = 0;
049C  118F     BCF PORTD, 0x3
137:                               SPI_ETHWIZ_Write(0x00);
049D  3000     MOVLW 0x0
049E  3182     MOVLP 0x2
049F  228D     CALL 0x28D
04A0  3184     MOVLP 0x4
138:                               SPI_ETHWIZ_Write(0x02); //Address = 0x0002
04A1  3002     MOVLW 0x2
04A2  3182     MOVLP 0x2
04A3  228D     CALL 0x28D
04A4  3184     MOVLP 0x4
139:                               SPI_ETHWIZ_Write(0b00001000); // S0_reg_read
04A5  3008     MOVLW 0x8
04A6  3182     MOVLP 0x2
04A7  228D     CALL 0x28D
04A8  3184     MOVLP 0x4
140:                               IR_check = SPI_ETHWIZ_Write(0x00);
04A9  3000     MOVLW 0x0
04AA  3182     MOVLP 0x2
04AB  228D     CALL 0x28D
04AC  3184     MOVLP 0x4
04AD  00FB     MOVWF 0x7B
04AE  087B     MOVF 0x7B, W
04AF  0020     MOVLB 0x0
04B0  00C3     MOVWF IR_check
141:                               PORTDbits.RD3 = 1;
04B1  158F     BSF PORTD, 0x3
142:                               
143:                           }while((IR_check & 0x10) != 0x10);
04B2  1E43     BTFSS IR_check, 0x4
04B3  2C9C     GOTO 0x49C
144:                           
145:                           //Set to 1 to clear flag - CMH
146:                           PORTDbits.RD3 = 0;
04B4  118F     BCF PORTD, 0x3
147:                           SPI_ETHWIZ_Write(0x00);
04B5  3000     MOVLW 0x0
04B6  3182     MOVLP 0x2
04B7  228D     CALL 0x28D
04B8  3184     MOVLP 0x4
148:                           SPI_ETHWIZ_Write(0x02); //Address = 0x0002
04B9  3002     MOVLW 0x2
04BA  3182     MOVLP 0x2
04BB  228D     CALL 0x28D
04BC  3184     MOVLP 0x4
149:                           SPI_ETHWIZ_Write(0b00001100); // S0_reg_write
04BD  300C     MOVLW 0xC
04BE  3182     MOVLP 0x2
04BF  228D     CALL 0x28D
04C0  3184     MOVLP 0x4
150:                           SPI_ETHWIZ_Write(0x10);
04C1  3010     MOVLW 0x10
04C2  3182     MOVLP 0x2
04C3  228D     CALL 0x28D
04C4  3184     MOVLP 0x4
151:                           PORTDbits.RD3 = 1;
04C5  0020     MOVLB 0x0
04C6  158F     BSF PORTD, 0x3
152:                           
153:                           first_send = 1;
154:                       }
155:                       else { //if first time through
156:                           first_send = 1;
04C7  01C4     CLRF first_send
04C8  0AC4     INCF first_send, F
157:                       }
158:                       
159:                       //Send the packet from FLIR - CMH
160:                       lepton_send_packet();
04C9  3183     MOVLP 0x3
04CA  2301     CALL 0x301
04CB  3184     MOVLP 0x4
161:                       
162:                   }while(packet_index < 59);
04CC  303B     MOVLW 0x3B
04CD  0020     MOVLB 0x0
04CE  0239     SUBWF packet_index, W
04CF  1803     BTFSC STATUS, 0x0
04D0  2C8C     GOTO 0x48C
04D1  2C93     GOTO 0x493
163:                   
164:                   //Acquire current GPS location - CMH
165:                   //gnss5_acquire();
166:                   
167:                   //Send GPS location over ETH WIZ - CMH
168:                   //ADD CODE HERE
169:                   
170:                   //Look to see if the Visual mission start signal was received - CMH
171:                   //ADD CODE HERE
172:                   
173:               }
174:               
175:               //Set up SPI bus to work with the Arducam - CMH
176:               SPI_Arducam_Initialize();
04D2  3182     MOVLP 0x2
04D3  2251     CALL 0x251
04D4  3184     MOVLP 0x4
177:               
178:               
179:               //Runs the visual image collection stage - CMH
180:               while (mission_stage_check == 2){
04D5  3002     MOVLW 0x2
04D6  0020     MOVLB 0x0
04D7  063C     XORWF mission_stage_check, W
04D8  1D03     BTFSS STATUS, 0x2
04D9  2CED     GOTO 0x4ED
181:                   
182:                   //Get the current GPS location - CMH
183:                   gnss5_acquire();
04DA  3182     MOVLP 0x2
04DB  223F     CALL 0x23F
04DC  3184     MOVLP 0x4
184:                   
185:                   //Check to see if any of the hotspot locations match the current - CMH
186:                   for(int i = 0; i == GPS_array_length; i++){
04DD  0020     MOVLB 0x0
04DE  01C1     CLRF i
04DF  01C2     CLRF 0x42
187:                       //will need to add some tolerances
188:                       if (GPS_location_current == GPS_location){
189:                           
190:                           //Take visual image with Arducam and send over ETH WIZ - CMH
191:                           //ADD CODE HERE
192:                           
193:                       }
194:                   }
04E0  0821     MOVF 0x21, W
04E1  0642     XORWF 0x42, W
04E2  1D03     BTFSS STATUS, 0x2
04E3  2CE6     GOTO 0x4E6
04E4  0820     MOVF GPS_array_length, W
04E5  0641     XORWF i, W
04E6  1D03     BTFSS STATUS, 0x2
04E7  2CD5     GOTO 0x4D5
04E8  3001     MOVLW 0x1
04E9  07C1     ADDWF i, F
04EA  3000     MOVLW 0x0
04EB  3DC2     ADDWFC 0x42, F
04EC  2CE0     GOTO 0x4E0
195:                   
196:               }
197:               
198:               //Infinite loop to end the program - CMH
199:               while(1) continue;
04ED  2CED     GOTO 0x4ED
200:           }
201:           
202:           
203:           // ************************************************************
204:           //
205:           //  This function sends a packet of thermal data through
206:           //  the ETH WIZ using the SPI Write function for the ETH WIZ.
207:           //
208:           // ************************************************************
209:           void lepton_send_packet(void){
210:               uint8_t junk = 0;
0301  01F9     CLRF junk
211:               uint8_t i = 0;
0302  01FA     CLRF i
212:               
213:               //start transmission
214:               eth_wiz_transmit_start();
0303  3183     MOVLP 0x3
0304  232C     CALL 0x32C
0305  3183     MOVLP 0x3
215:               
216:               //These four lines below are the write/read sequence for the SPI on
217:               //the ETH WIZ. It had to be done with these all in a row because the
218:               //XC8 compiler for the PIC does not generate optimized code so
219:               //the program wouldn't run fast enough to get the full image until
220:               //I wrote in this way - CMH
221:               
222:               
223:               while(i < 164){
0306  30A4     MOVLW 0xA4
0307  027A     SUBWF i, W
0308  1803     BTFSC STATUS, 0x0
0309  2B29     GOTO 0x329
0328  2B06     GOTO 0x306
224:                   SSP2BUF = image_packet[i];             
030A  087A     MOVF i, W
030B  3E4C     ADDLW 0x4C
030C  0086     MOVWF FSR1
030D  0187     CLRF FSR1H
030E  3023     MOVLW 0x23
030F  3D87     ADDWFC FSR1H, F
0310  0801     MOVF INDF1, W
0311  0023     MOVLB 0x3
0312  0096     MOVWF SSP2BUF
225:                   delay();
0313  3182     MOVLP 0x2
0314  227A     CALL 0x27A
0315  3183     MOVLP 0x3
226:                   image_packet[i] = 0;
0316  087A     MOVF 0x1FA, W
0317  3E4C     ADDLW 0x4C
0318  0086     MOVWF 0x186
0319  0187     CLRF 0x187
031A  3023     MOVLW 0x23
031B  3D87     ADDWFC 0x187, F
031C  0181     CLRF 0x181
227:                   SSP2IF = 0;
031D  002E     MOVLB 0xE
031E  110F     BCF PIR3, 0x2
228:                   junk = SSP2BUF;
031F  0023     MOVLB 0x3
0320  0816     MOVF SSP2BUF, W
0321  00F8     MOVWF 0x1F8
0322  0878     MOVF 0x1F8, W
0323  00F9     MOVWF 0x1F9
229:                   i++;
0324  3001     MOVLW 0x1
0325  00F8     MOVWF 0x1F8
0326  0878     MOVF 0x1F8, W
0327  07FA     ADDWF 0x1FA, F
230:               }
231:               
232:               eth_wiz_transmit_end();
0329  3183     MOVLP 0x3
032A  23A1     CALL 0x3A1
233:           }
032B  0008     RETURN
234:           
235:           
236:           
237:           // ************************************************************
238:           //
239:           //  This function captures a packet of thermal image data
240:           //  from the Flir Lepton over the SPI bus. The FLIR does not
241:           //  use traditional SPI and instead uses a proprietary SPI
242:           //  based protocol called VoSPI (Video over SPI). It doesn't
243:           //  send one byte at a time and instead sends over a whole 
244:           //  packet of data (164 bytes) continuously. This function
245:           //  is set up to handle that constant stream of data.
246:           //
247:           // ************************************************************
248:           void lepton_capture_packet(void){
249:               //Initially set the discard flag to 0 - CMH
250:               discard = 0;
03ED  0020     MOVLB 0x0
03EE  01B2     CLRF discard
251:               
252:               int i = 0;
03EF  01F2     CLRF connected
03F0  01F3     CLRF 0x73
253:               
254:               //Assert the Slave Select (CS) pin for the FLIR - CMH
255:               PORTCbits.RC0 = 0;
03F1  100E     BCF PORTC, 0x0
256:               
257:               //These four lines below are the write/read sequencence for the VoSPI on
258:               //the FLIR. It had to be done with these all in a row because the
259:               //XC8 compiler for the PIC does not generate optimized code so
260:               //the program wouldn't run fast enough to get the full image until
261:               //I wrote in this way - CMH
262:               while(i < 164){
03F2  0873     MOVF 0x73, W
03F3  3A80     XORLW 0x80
03F4  00F0     MOVWF __pcstackCOMMON
03F5  3080     MOVLW 0x80
03F6  0270     SUBWF __pcstackCOMMON, W
03F7  1D03     BTFSS STATUS, 0x2
03F8  2BFB     GOTO 0x3FB
03F9  30A4     MOVLW 0xA4
03FA  0272     SUBWF connected, W
03FB  1803     BTFSC STATUS, 0x0
03FC  2C10     GOTO 0x410
040F  2BF2     GOTO 0x3F2
263:                   SSP1BUF = 0x00;             
03FD  0023     MOVLB 0x3
03FE  018C     CLRF SSP1BUF
264:                   delay();
03FF  3182     MOVLP 0x2
0400  227A     CALL 0x27A
0401  3183     MOVLP 0x3
265:                   SSP1IF = 0;                 
0402  002E     MOVLB 0xE
0403  100F     BCF PIR3, 0x0
266:                   image_packet[0] = SSP1BUF;
0404  304C     MOVLW 0x4C
0405  0086     MOVWF 0x706
0406  3023     MOVLW 0x23
0407  0087     MOVWF 0x707
0408  0023     MOVLB 0x3
0409  080C     MOVF SSP1BUF, W
040A  3FC0     MOVWI 0[FSR1]
267:                   i++;
040B  3001     MOVLW 0x1
040C  07F2     ADDWF 0x1F2, F
040D  3000     MOVLW 0x0
040E  3DF3     ADDWFC 0x1F3, F
268:               }
269:               
270:               //De-assert the CS pin so next byte is not received until
271:               //pin is asserted again - CMH
272:               PORTCbits.RC0 = 1;
0410  0020     MOVLB 0x0
0411  140E     BSF PORTC, 0x0
273:               
274:               //If the first byte of data says the entire packet is a discard packet - CMH
275:               if((image_packet[0]&0x0F) == 0x0F){
0412  304C     MOVLW 0x4C
0413  0086     MOVWF FSR1
0414  3023     MOVLW 0x23
0415  0087     MOVWF FSR1H
0416  300F     MOVLW 0xF
0417  0501     ANDWF INDF1, W
0418  00F0     MOVWF __pcstackCOMMON
0419  300F     MOVLW 0xF
041A  0670     XORWF __pcstackCOMMON, W
041B  1D03     BTFSS STATUS, 0x2
041C  2C28     GOTO 0x428
276:                   discard = 1;        //Set the discard flag - CMH
041D  01B2     CLRF discard
041E  0AB2     INCF discard, F
277:                   num_discard++;      //Increment the number of discard packets - CMH
041F  3001     MOVLW 0x1
0420  00F0     MOVWF __pcstackCOMMON
0421  0870     MOVF __pcstackCOMMON, W
0422  07B1     ADDWF num_discard, F
278:                   packet_index = -1;  //set packet index to -1 so next real packet can
0423  30FF     MOVLW 0xFF
0424  00F0     MOVWF __pcstackCOMMON
0425  0870     MOVF __pcstackCOMMON, W
0426  00B9     MOVWF packet_index
279:                                       //have the index of 0 when incremented below - CMH
280:               }
0427  2C31     GOTO 0x431
281:               //If it is not a discard packet - CMH
282:               else{
283:                   num_discard = 0;        //Reset the number of discarded packets - CMH
0428  01B1     CLRF num_discard
284:                   packet_index++;         //increment to the current index - CMH
0429  3001     MOVLW 0x1
042A  00F0     MOVWF __pcstackCOMMON
042B  0870     MOVF __pcstackCOMMON, W
042C  07B9     ADDWF packet_index, F
285:                   if( packet_index > 59){ //If the index is incremented past the
042D  303C     MOVLW 0x3C
042E  0239     SUBWF packet_index, W
042F  1803     BTFSC STATUS, 0x0
286:                       packet_index = 0;   //final index, set back to 0 - CMH
0430  01B9     CLRF packet_index
287:                   }
288:               }
289:               
290:               //If there has been more than 150 discarded packets in a row,
291:               //wait for two seconds so the FLIR VoSPI can reset itself.
292:               //Also reset the number of discarded packets to 0 - CMH
293:               if(num_discard > 150){
0431  3097     MOVLW 0x97
0432  0231     SUBWF num_discard, W
0433  1C03     BTFSS STATUS, 0x0
0434  0008     RETURN
294:                   __delay_ms(2000);
0435  3052     MOVLW 0x52
0436  00F1     MOVWF i2cWriteData
0437  302B     MOVLW 0x2B
0438  00F0     MOVWF __pcstackCOMMON
0439  3000     MOVLW 0x0
043A  0B89     DECFSZ WREG, F
043B  2C3A     GOTO 0x43A
043C  0BF0     DECFSZ __pcstackCOMMON, F
043D  2C3A     GOTO 0x43A
043E  0BF1     DECFSZ i2cWriteData, F
043F  2C3A     GOTO 0x43A
0440  3200     BRA 0x441
295:                   num_discard = 0;
0441  0020     MOVLB 0x0
0442  01B1     CLRF num_discard
0443  0008     RETURN
296:               }
297:               
298:           }
299:           
300:           
301:           
302:           
---  C:/Users/cmh52/Desktop/SeniorDesign.X/lepton.c  ----------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: lepton.c
8:              * 
9:              * Date Created: 1/14/19
10:             * 
11:             * Revision Date: 2/11/19
12:             * 
13:             * Revision: 1.00
14:             */
15:            
16:            #include "lepton.h"
17:            #include "serial_i2c.h"
18:            
19:            
20:            // ************************************************************
21:            //
22:            //  This function initializes the necessary settings within
23:            //  the FLIR Lepton Thermal Camera through the I2C bus. Due
24:            //  to many of the settings needed being default within the
25:            //  Lepton like Telemetry disabled, Radiometry disabled, and 
26:            //  it being unnecessary to run Far Field Correction (FFC),
27:            //  the only AGC feature needs to be enabled on the Lepton.
28:            //
29:            // ************************************************************
30:            void lepton_initialize(){
31:                
32:                //Enable the AGC - CMH
33:                i2c_start();
02C8  3182     MOVLP 0x2
02C9  2241     CALL 0x241
02CA  3182     MOVLP 0x2
34:                i2c_write(0x2A);    //Device Address - CMH
02CB  302A     MOVLW 0x2A
02CC  3182     MOVLP 0x2
02CD  2269     CALL 0x269
02CE  3182     MOVLP 0x2
35:                i2c_write(0x01);    //AGC Address - CMH
02CF  3001     MOVLW 0x1
02D0  3182     MOVLP 0x2
02D1  2269     CALL 0x269
02D2  3182     MOVLP 0x2
36:                i2c_write(0x05);    //Write Command - CMH
02D3  3005     MOVLW 0x5
02D4  3182     MOVLP 0x2
02D5  2269     CALL 0x269
02D6  3182     MOVLP 0x2
37:                i2c_write(0x00);    //Enable AGC with 8-bit compression (1) - CMH
02D7  3000     MOVLW 0x0
02D8  3182     MOVLP 0x2
02D9  2269     CALL 0x269
02DA  3182     MOVLP 0x2
38:                i2c_write(0x01);    //Enable AGC with 8-bit compression (2) - CMH
02DB  3001     MOVLW 0x1
02DC  3182     MOVLP 0x2
02DD  2269     CALL 0x269
02DE  3182     MOVLP 0x2
39:                i2c_stop();
02DF  3182     MOVLP 0x2
02E0  2246     CALL 0x246
40:                
41:                //Telemetry is default disabled - CMH
42:                
43:                //Radiometry is default diabled - CMH
44:                
45:                //FFC does not need to run - CMH
46:            }
02E1  0008     RETURN
---  C:/Users/cmh52/Desktop/SeniorDesign.X/gnss5.c  -----------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: gnss5.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 0.01
12:             */
13:            
14:            #include "gnss5.h"
15:            
16:            // ************************************************************
17:            //
18:            //  This function acquires the current coordinates from the 
19:            //  GNSS 5 Click module.
20:            //
21:            // ************************************************************
22:            void gnss5_acquire(void){
23:                
24:            }
023F  0008     RETURN
---  C:/Users/cmh52/Desktop/SeniorDesign.X/eth_wiz.c  ---------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: eth_wiz.c
8:              * 
9:              * Date Created: 1/14/19
10:             * 
11:             * Revision Date: 3/5/19
12:             * 
13:             * Revision: 0.04
14:             */
15:            
16:            #include <xc.h>
17:            #include <stdio.h>
18:            #include <stdlib.h>
19:            #include <stdint.h>
20:            #include <stdbool.h>
21:            #include "config.h"
22:            #include "eth_wiz.h"
23:            #include "serial_spi.h"
24:            
25:            //Control Phase value for block and R/W selection in ETH WIZ - CMH
26:            uint8_t common_reg_write = 0b00000100;
27:            uint8_t common_reg_read  = 0b00000000;
28:            uint8_t s0_reg_write     = 0b00001100;
29:            uint8_t s0_reg_read      = 0b00001000;
30:            uint8_t s0_tx_buf_write  = 0b00010100;
31:            uint8_t s0_tx_buf_read   = 0b00010000;
32:            uint8_t s0_rx_buf_write  = 0b00011100;
33:            uint8_t s0_rx_buf_read    = 0b00011000;
34:            
35:            //Variables for pointer registers of TX and RX - CMH
36:            uint8_t s0_tx_pointer_high = 0x00;
37:            uint8_t s0_tx_pointer_low = 0x00;
38:            uint8_t s0_rx_readpointer_high = 0x00;
39:            uint8_t s0_rx_readpointer_low = 0x00;
40:            uint8_t s0_rx_writepointer_high = 0x00;
41:            uint8_t s0_rx_writepointer_low = 0x00;
42:            uint8_t s0_rx_datalength_high = 0x00;
43:            uint8_t s0_rx_datalength_low = 0x00;
44:            uint8_t s0_SR_check = 0x00;
45:            uint8_t s0_IR_check = 0x00;
46:            
47:            
48:            // ************************************************************
49:            //
50:            //  This function configures the proper settings on the W5500
51:            //  (the chipset on the ETH WIZ Click). See comments below to 
52:            //  see the exact settings for each register. Overall setup is
53:            //  for TCP through Socket 0.
54:            //
55:            // ************************************************************
56:            void eth_wiz_configure(void){
57:                
58:                /*
59:                 * Start of the Common Registers set up
60:                 */
61:                
62:                //Mode Register - Wake on LAN disabled, Pinf Block Mode enabled,
63:                //PPPoE mode disabled, and Force ARP disabled - CMH
64:                PORTDbits.RD3 = 0;
05B8  0020     MOVLB 0x0
05B9  118F     BCF PORTD, 0x3
65:                SPI_ETHWIZ_Write(0x00);
05BA  3000     MOVLW 0x0
05BB  3182     MOVLP 0x2
05BC  228D     CALL 0x28D
05BD  3185     MOVLP 0x5
66:                SPI_ETHWIZ_Write(0x00); //Address = 0x0000
05BE  3000     MOVLW 0x0
05BF  3182     MOVLP 0x2
05C0  228D     CALL 0x28D
05C1  3185     MOVLP 0x5
67:                SPI_ETHWIZ_Write(common_reg_write);
05C2  0020     MOVLB 0x0
05C3  0838     MOVF common_reg_write, W
05C4  3182     MOVLP 0x2
05C5  228D     CALL 0x28D
05C6  3185     MOVLP 0x5
68:                SPI_ETHWIZ_Write(0b00010000);
05C7  3010     MOVLW 0x10
05C8  3182     MOVLP 0x2
05C9  228D     CALL 0x28D
05CA  3185     MOVLP 0x5
69:                PORTDbits.RD3 = 1;
05CB  0020     MOVLB 0x0
05CC  158F     BSF PORTD, 0x3
70:                __delay_ms(1);
05CD  300B     MOVLW 0xB
05CE  00F1     MOVWF i2cWriteData
05CF  3062     MOVLW 0x62
05D0  0B89     DECFSZ WREG, F
05D1  2DD0     GOTO 0x5D0
05D2  0BF1     DECFSZ i2cWriteData, F
05D3  2DD0     GOTO 0x5D0
05D4  3200     BRA 0x5D5
71:                
72:                //Set the Gateway IP Address to 10.0.0.254 - CMH
73:                PORTDbits.RD3 = 0;
05D5  0020     MOVLB 0x0
05D6  118F     BCF PORTD, 0x3
74:                SPI_ETHWIZ_Write(0x00);
05D7  3000     MOVLW 0x0
05D8  3182     MOVLP 0x2
05D9  228D     CALL 0x28D
05DA  3185     MOVLP 0x5
75:                SPI_ETHWIZ_Write(0x01); //Start Address = 0x0001
05DB  3001     MOVLW 0x1
05DC  3182     MOVLP 0x2
05DD  228D     CALL 0x28D
05DE  3185     MOVLP 0x5
76:                SPI_ETHWIZ_Write(common_reg_write);
05DF  0020     MOVLB 0x0
05E0  0838     MOVF common_reg_write, W
05E1  3182     MOVLP 0x2
05E2  228D     CALL 0x28D
05E3  3185     MOVLP 0x5
77:                SPI_ETHWIZ_Write(0x0A); //10
05E4  300A     MOVLW 0xA
05E5  3182     MOVLP 0x2
05E6  228D     CALL 0x28D
05E7  3185     MOVLP 0x5
78:                SPI_ETHWIZ_Write(0x00); //0
05E8  3000     MOVLW 0x0
05E9  3182     MOVLP 0x2
05EA  228D     CALL 0x28D
05EB  3185     MOVLP 0x5
79:                SPI_ETHWIZ_Write(0x00); //0
05EC  3000     MOVLW 0x0
05ED  3182     MOVLP 0x2
05EE  228D     CALL 0x28D
05EF  3185     MOVLP 0x5
80:                SPI_ETHWIZ_Write(0xFE); //254
05F0  30FE     MOVLW 0xFE
05F1  3182     MOVLP 0x2
05F2  228D     CALL 0x28D
05F3  3185     MOVLP 0x5
81:                PORTDbits.RD3 = 1;
05F4  0020     MOVLB 0x0
05F5  158F     BSF PORTD, 0x3
82:                __delay_ms(1);
05F6  300B     MOVLW 0xB
05F7  00F1     MOVWF i2cWriteData
05F8  3062     MOVLW 0x62
05F9  0B89     DECFSZ WREG, F
05FA  2DF9     GOTO 0x5F9
05FB  0BF1     DECFSZ i2cWriteData, F
05FC  2DF9     GOTO 0x5F9
05FD  3200     BRA 0x5FE
83:            
84:                //Set the Subnet Mask address to 255.255.0.0 - CMH
85:                PORTDbits.RD3 = 0;
05FE  0020     MOVLB 0x0
05FF  118F     BCF PORTD, 0x3
86:                SPI_ETHWIZ_Write(0x00);
0600  3000     MOVLW 0x0
0601  3182     MOVLP 0x2
0602  228D     CALL 0x28D
0603  3185     MOVLP 0x5
87:                SPI_ETHWIZ_Write(0x05); //Start Address = 0x0005
0604  3005     MOVLW 0x5
0605  3182     MOVLP 0x2
0606  228D     CALL 0x28D
0607  3185     MOVLP 0x5
88:                SPI_ETHWIZ_Write(common_reg_write);
0608  0020     MOVLB 0x0
0609  0838     MOVF common_reg_write, W
060A  3182     MOVLP 0x2
060B  228D     CALL 0x28D
060C  3185     MOVLP 0x5
89:                SPI_ETHWIZ_Write(0xFF); //255
060D  30FF     MOVLW 0xFF
060E  3182     MOVLP 0x2
060F  228D     CALL 0x28D
0610  3185     MOVLP 0x5
90:                SPI_ETHWIZ_Write(0xFF); //255
0611  30FF     MOVLW 0xFF
0612  3182     MOVLP 0x2
0613  228D     CALL 0x28D
0614  3185     MOVLP 0x5
91:                SPI_ETHWIZ_Write(0x00); //0
0615  3000     MOVLW 0x0
0616  3182     MOVLP 0x2
0617  228D     CALL 0x28D
0618  3185     MOVLP 0x5
92:                SPI_ETHWIZ_Write(0x00); //0
0619  3000     MOVLW 0x0
061A  3182     MOVLP 0x2
061B  228D     CALL 0x28D
061C  3185     MOVLP 0x5
93:                PORTDbits.RD3 = 1;
061D  0020     MOVLB 0x0
061E  158F     BSF PORTD, 0x3
94:                __delay_ms(1);
061F  300B     MOVLW 0xB
0620  00F1     MOVWF i2cWriteData
0621  3062     MOVLW 0x62
0622  0B89     DECFSZ WREG, F
0623  2E22     GOTO 0x622
0624  0BF1     DECFSZ i2cWriteData, F
0625  2E22     GOTO 0x622
0626  3200     BRA 0x627
95:                
96:                //Set the Source Hardware Address address to 00.21.74.08.36.85 - CMH
97:                PORTDbits.RD3 = 0;
0627  0020     MOVLB 0x0
0628  118F     BCF PORTD, 0x3
98:                SPI_ETHWIZ_Write(0x00);
0629  3000     MOVLW 0x0
062A  3182     MOVLP 0x2
062B  228D     CALL 0x28D
062C  3185     MOVLP 0x5
99:                SPI_ETHWIZ_Write(0x09); //Start Address = 0x0009
062D  3009     MOVLW 0x9
062E  3182     MOVLP 0x2
062F  228D     CALL 0x28D
0630  3185     MOVLP 0x5
100:               SPI_ETHWIZ_Write(common_reg_write);
0631  0020     MOVLB 0x0
0632  0838     MOVF common_reg_write, W
0633  3182     MOVLP 0x2
0634  228D     CALL 0x28D
0635  3185     MOVLP 0x5
101:               SPI_ETHWIZ_Write(0x00); //00
0636  3000     MOVLW 0x0
0637  3182     MOVLP 0x2
0638  228D     CALL 0x28D
0639  3185     MOVLP 0x5
102:               SPI_ETHWIZ_Write(0x21); //21
063A  3021     MOVLW 0x21
063B  3182     MOVLP 0x2
063C  228D     CALL 0x28D
063D  3185     MOVLP 0x5
103:               SPI_ETHWIZ_Write(0x74); //74
063E  3074     MOVLW 0x74
063F  3182     MOVLP 0x2
0640  228D     CALL 0x28D
0641  3185     MOVLP 0x5
104:               SPI_ETHWIZ_Write(0x08); //08
0642  3008     MOVLW 0x8
0643  3182     MOVLP 0x2
0644  228D     CALL 0x28D
0645  3185     MOVLP 0x5
105:               SPI_ETHWIZ_Write(0x36); //36
0646  3036     MOVLW 0x36
0647  3182     MOVLP 0x2
0648  228D     CALL 0x28D
0649  3185     MOVLP 0x5
106:               SPI_ETHWIZ_Write(0x85); //85
064A  3085     MOVLW 0x85
064B  3182     MOVLP 0x2
064C  228D     CALL 0x28D
064D  3185     MOVLP 0x5
107:               PORTDbits.RD3 = 1;
064E  0020     MOVLB 0x0
064F  158F     BSF PORTD, 0x3
108:               __delay_ms(1);
0650  300B     MOVLW 0xB
0651  00F1     MOVWF i2cWriteData
0652  3062     MOVLW 0x62
0653  0B89     DECFSZ WREG, F
0654  2E53     GOTO 0x653
0655  0BF1     DECFSZ i2cWriteData, F
0656  2E53     GOTO 0x653
0657  3200     BRA 0x658
109:               
110:               //Set the Source IP address to 10.0.0.2 - CMH
111:               PORTDbits.RD3 = 0;
0658  0020     MOVLB 0x0
0659  118F     BCF PORTD, 0x3
112:               SPI_ETHWIZ_Write(0x00);
065A  3000     MOVLW 0x0
065B  3182     MOVLP 0x2
065C  228D     CALL 0x28D
065D  3185     MOVLP 0x5
113:               SPI_ETHWIZ_Write(0x0F); //Start Address = 0x000F
065E  300F     MOVLW 0xF
065F  3182     MOVLP 0x2
0660  228D     CALL 0x28D
0661  3185     MOVLP 0x5
114:               SPI_ETHWIZ_Write(common_reg_write);
0662  0020     MOVLB 0x0
0663  0838     MOVF common_reg_write, W
0664  3182     MOVLP 0x2
0665  228D     CALL 0x28D
0666  3185     MOVLP 0x5
115:               SPI_ETHWIZ_Write(0x0A); //10
0667  300A     MOVLW 0xA
0668  3182     MOVLP 0x2
0669  228D     CALL 0x28D
066A  3185     MOVLP 0x5
116:               SPI_ETHWIZ_Write(0x00); //0
066B  3000     MOVLW 0x0
066C  3182     MOVLP 0x2
066D  228D     CALL 0x28D
066E  3185     MOVLP 0x5
117:               SPI_ETHWIZ_Write(0x00); //0
066F  3000     MOVLW 0x0
0670  3182     MOVLP 0x2
0671  228D     CALL 0x28D
0672  3185     MOVLP 0x5
118:               SPI_ETHWIZ_Write(0x02); //2
0673  3002     MOVLW 0x2
0674  3182     MOVLP 0x2
0675  228D     CALL 0x28D
0676  3185     MOVLP 0x5
119:               PORTDbits.RD3 = 1;
0677  0020     MOVLB 0x0
0678  158F     BSF PORTD, 0x3
120:               __delay_ms(1);
0679  300B     MOVLW 0xB
067A  00F1     MOVWF i2cWriteData
067B  3062     MOVLW 0x62
067C  0B89     DECFSZ WREG, F
067D  2E7C     GOTO 0x67C
067E  0BF1     DECFSZ i2cWriteData, F
067F  2E7C     GOTO 0x67C
0680  3200     BRA 0x681
121:               
122:               //Set the Destination unreachable interrupt mask to enabled - CMH
123:               PORTDbits.RD3 = 0;
0681  0020     MOVLB 0x0
0682  118F     BCF PORTD, 0x3
124:               SPI_ETHWIZ_Write(0x00);
0683  3000     MOVLW 0x0
0684  3182     MOVLP 0x2
0685  228D     CALL 0x28D
0686  3185     MOVLP 0x5
125:               SPI_ETHWIZ_Write(0x15); //Address = 0x0015
0687  3015     MOVLW 0x15
0688  3182     MOVLP 0x2
0689  228D     CALL 0x28D
068A  3185     MOVLP 0x5
126:               SPI_ETHWIZ_Write(common_reg_write);
068B  0020     MOVLB 0x0
068C  0838     MOVF common_reg_write, W
068D  3182     MOVLP 0x2
068E  228D     CALL 0x28D
068F  3185     MOVLP 0x5
127:               SPI_ETHWIZ_Write(0b01000000);
0690  3040     MOVLW 0x40
0691  3182     MOVLP 0x2
0692  228D     CALL 0x28D
0693  3185     MOVLP 0x5
128:               PORTDbits.RD3 = 1;
0694  0020     MOVLB 0x0
0695  158F     BSF PORTD, 0x3
129:               __delay_ms(1);
0696  300B     MOVLW 0xB
0697  00F1     MOVWF i2cWriteData
0698  3062     MOVLW 0x62
0699  0B89     DECFSZ WREG, F
069A  2E99     GOTO 0x699
069B  0BF1     DECFSZ i2cWriteData, F
069C  2E99     GOTO 0x699
069D  3200     BRA 0x69E
130:               
131:               //Enable the Socket 0 and disable all other sockets - CMH
132:               PORTDbits.RD3 = 0;
069E  0020     MOVLB 0x0
069F  118F     BCF PORTD, 0x3
133:               SPI_ETHWIZ_Write(0x00);
06A0  3000     MOVLW 0x0
06A1  3182     MOVLP 0x2
06A2  228D     CALL 0x28D
06A3  3185     MOVLP 0x5
134:               SPI_ETHWIZ_Write(0x18); //Address = 0x0018
06A4  3018     MOVLW 0x18
06A5  3182     MOVLP 0x2
06A6  228D     CALL 0x28D
06A7  3185     MOVLP 0x5
135:               SPI_ETHWIZ_Write(common_reg_write);
06A8  0020     MOVLB 0x0
06A9  0838     MOVF common_reg_write, W
06AA  3182     MOVLP 0x2
06AB  228D     CALL 0x28D
06AC  3185     MOVLP 0x5
136:               SPI_ETHWIZ_Write(0b00000001);
06AD  3001     MOVLW 0x1
06AE  3182     MOVLP 0x2
06AF  228D     CALL 0x28D
06B0  3185     MOVLP 0x5
137:               PORTDbits.RD3 = 1;
06B1  0020     MOVLB 0x0
06B2  158F     BSF PORTD, 0x3
138:               __delay_ms(1);
06B3  300B     MOVLW 0xB
06B4  00F1     MOVWF i2cWriteData
06B5  3062     MOVLW 0x62
06B6  0B89     DECFSZ WREG, F
06B7  2EB6     GOTO 0x6B6
06B8  0BF1     DECFSZ i2cWriteData, F
06B9  2EB6     GOTO 0x6B6
06BA  3200     BRA 0x6BB
139:               
140:               //Set Retry Count Register to 0 (=RCR+1) - CMH
141:               PORTDbits.RD3 = 0;
06BB  0020     MOVLB 0x0
06BC  118F     BCF PORTD, 0x3
142:               SPI_ETHWIZ_Write(0x00);
06BD  3000     MOVLW 0x0
06BE  3182     MOVLP 0x2
06BF  228D     CALL 0x28D
06C0  3185     MOVLP 0x5
143:               SPI_ETHWIZ_Write(0x1B); //Address = 0x001B
06C1  301B     MOVLW 0x1B
06C2  3182     MOVLP 0x2
06C3  228D     CALL 0x28D
06C4  3185     MOVLP 0x5
144:               SPI_ETHWIZ_Write(common_reg_write);
06C5  0020     MOVLB 0x0
06C6  0838     MOVF common_reg_write, W
06C7  3182     MOVLP 0x2
06C8  228D     CALL 0x28D
06C9  3185     MOVLP 0x5
145:               SPI_ETHWIZ_Write(0b00000000);
06CA  3000     MOVLW 0x0
06CB  3182     MOVLP 0x2
06CC  228D     CALL 0x28D
06CD  3185     MOVLP 0x5
146:               PORTDbits.RD3 = 1;
06CE  0020     MOVLB 0x0
06CF  158F     BSF PORTD, 0x3
147:               __delay_ms(1);
06D0  300B     MOVLW 0xB
06D1  00F1     MOVWF i2cWriteData
06D2  3062     MOVLW 0x62
06D3  0B89     DECFSZ WREG, F
06D4  2ED3     GOTO 0x6D3
06D5  0BF1     DECFSZ i2cWriteData, F
06D6  2ED3     GOTO 0x6D3
06D7  3200     BRA 0x6D8
148:               
149:               //Set the Physical Operation Mode to all capable - CMH
150:               PORTDbits.RD3 = 0;
06D8  0020     MOVLB 0x0
06D9  118F     BCF PORTD, 0x3
151:               SPI_ETHWIZ_Write(0x00);
06DA  3000     MOVLW 0x0
06DB  3182     MOVLP 0x2
06DC  228D     CALL 0x28D
06DD  3185     MOVLP 0x5
152:               SPI_ETHWIZ_Write(0x2E); //Address = 0x002E
06DE  302E     MOVLW 0x2E
06DF  3182     MOVLP 0x2
06E0  228D     CALL 0x28D
06E1  3185     MOVLP 0x5
153:               SPI_ETHWIZ_Write(common_reg_write);
06E2  0020     MOVLB 0x0
06E3  0838     MOVF common_reg_write, W
06E4  3182     MOVLP 0x2
06E5  228D     CALL 0x28D
06E6  3185     MOVLP 0x5
154:               SPI_ETHWIZ_Write(0b10111000);
06E7  30B8     MOVLW 0xB8
06E8  3182     MOVLP 0x2
06E9  228D     CALL 0x28D
06EA  3185     MOVLP 0x5
155:               PORTDbits.RD3 = 1;
06EB  0020     MOVLB 0x0
06EC  158F     BSF PORTD, 0x3
156:               __delay_ms(1);
06ED  300B     MOVLW 0xB
06EE  00F1     MOVWF i2cWriteData
06EF  3062     MOVLW 0x62
06F0  0B89     DECFSZ WREG, F
06F1  2EF0     GOTO 0x6F0
06F2  0BF1     DECFSZ i2cWriteData, F
06F3  2EF0     GOTO 0x6F0
06F4  3200     BRA 0x6F5
157:               
158:               
159:               /*
160:                * Start of the Socket 0 (S0) Registers set up
161:                */
162:               
163:               //Set S0 Mode Register to enable Multicasting and sets 
164:               //the protocol mode to TCP - CMH
165:               PORTDbits.RD3 = 0;
06F5  0020     MOVLB 0x0
06F6  118F     BCF PORTD, 0x3
166:               SPI_ETHWIZ_Write(0x00);
06F7  3000     MOVLW 0x0
06F8  3182     MOVLP 0x2
06F9  228D     CALL 0x28D
06FA  3185     MOVLP 0x5
167:               SPI_ETHWIZ_Write(0x00); //Address = 0x0000
06FB  3000     MOVLW 0x0
06FC  3182     MOVLP 0x2
06FD  228D     CALL 0x28D
06FE  3185     MOVLP 0x5
168:               SPI_ETHWIZ_Write(s0_reg_write);
06FF  087D     MOVF s0_reg_write, W
0700  3182     MOVLP 0x2
0701  228D     CALL 0x28D
0702  3185     MOVLP 0x5
169:               SPI_ETHWIZ_Write(0b10000001);
0703  3081     MOVLW 0x81
0704  3182     MOVLP 0x2
0705  228D     CALL 0x28D
0706  3185     MOVLP 0x5
170:               PORTDbits.RD3 = 1;
0707  0020     MOVLB 0x0
0708  158F     BSF PORTD, 0x3
171:               __delay_ms(1);
0709  300B     MOVLW 0xB
070A  00F1     MOVWF i2cWriteData
070B  3062     MOVLW 0x62
070C  0B89     DECFSZ WREG, F
070D  2F0C     GOTO 0x70C
070E  0BF1     DECFSZ i2cWriteData, F
070F  2F0C     GOTO 0x70C
0710  3200     BRA 0x711
172:                   
173:               //Set the S0 Source Port Register to d'10,000' - CMH
174:               PORTDbits.RD3 = 0;
0711  0020     MOVLB 0x0
0712  118F     BCF PORTD, 0x3
175:               SPI_ETHWIZ_Write(0x00);
0713  3000     MOVLW 0x0
0714  3182     MOVLP 0x2
0715  228D     CALL 0x28D
0716  3185     MOVLP 0x5
176:               SPI_ETHWIZ_Write(0x04); //Address = 0x0004
0717  3004     MOVLW 0x4
0718  3182     MOVLP 0x2
0719  228D     CALL 0x28D
071A  3185     MOVLP 0x5
177:               SPI_ETHWIZ_Write(s0_reg_write);
071B  087D     MOVF s0_reg_write, W
071C  3182     MOVLP 0x2
071D  228D     CALL 0x28D
071E  3185     MOVLP 0x5
178:               SPI_ETHWIZ_Write(0x27);
071F  3027     MOVLW 0x27
0720  3182     MOVLP 0x2
0721  228D     CALL 0x28D
0722  3185     MOVLP 0x5
179:               SPI_ETHWIZ_Write(0x10); //10,000 = 0x2710
0723  3010     MOVLW 0x10
0724  3182     MOVLP 0x2
0725  228D     CALL 0x28D
0726  3185     MOVLP 0x5
180:               PORTDbits.RD3 = 1;
0727  0020     MOVLB 0x0
0728  158F     BSF PORTD, 0x3
181:               __delay_ms(1);
0729  300B     MOVLW 0xB
072A  00F1     MOVWF i2cWriteData
072B  3062     MOVLW 0x62
072C  0B89     DECFSZ WREG, F
072D  2F2C     GOTO 0x72C
072E  0BF1     DECFSZ i2cWriteData, F
072F  2F2C     GOTO 0x72C
0730  3200     BRA 0x731
182:           
183:               //Set the S0 Destination IP Address Register to 10.0.0.1 - CMH
184:               PORTDbits.RD3 = 0;
0731  0020     MOVLB 0x0
0732  118F     BCF PORTD, 0x3
185:               SPI_ETHWIZ_Write(0x00);
0733  3000     MOVLW 0x0
0734  3182     MOVLP 0x2
0735  228D     CALL 0x28D
0736  3185     MOVLP 0x5
186:               SPI_ETHWIZ_Write(0x0C); //Address = 0x000C
0737  300C     MOVLW 0xC
0738  3182     MOVLP 0x2
0739  228D     CALL 0x28D
073A  3185     MOVLP 0x5
187:               SPI_ETHWIZ_Write(s0_reg_write);
073B  087D     MOVF s0_reg_write, W
073C  3182     MOVLP 0x2
073D  228D     CALL 0x28D
073E  3185     MOVLP 0x5
188:               SPI_ETHWIZ_Write(0x0A); //10
073F  300A     MOVLW 0xA
0740  3182     MOVLP 0x2
0741  228D     CALL 0x28D
0742  3185     MOVLP 0x5
189:               SPI_ETHWIZ_Write(0x00); //0
0743  3000     MOVLW 0x0
0744  3182     MOVLP 0x2
0745  228D     CALL 0x28D
0746  3185     MOVLP 0x5
190:               SPI_ETHWIZ_Write(0x00); //0
0747  3000     MOVLW 0x0
0748  3182     MOVLP 0x2
0749  228D     CALL 0x28D
074A  3185     MOVLP 0x5
191:               SPI_ETHWIZ_Write(0x01); //1
074B  3001     MOVLW 0x1
074C  3182     MOVLP 0x2
074D  228D     CALL 0x28D
074E  3185     MOVLP 0x5
192:               PORTDbits.RD3 = 1;
074F  0020     MOVLB 0x0
0750  158F     BSF PORTD, 0x3
193:               __delay_ms(1);
0751  300B     MOVLW 0xB
0752  00F1     MOVWF i2cWriteData
0753  3062     MOVLW 0x62
0754  0B89     DECFSZ WREG, F
0755  2F54     GOTO 0x754
0756  0BF1     DECFSZ i2cWriteData, F
0757  2F54     GOTO 0x754
0758  3200     BRA 0x759
194:               
195:               //Set the S0 Destination Port Register to d'10,000' - CMH
196:               PORTDbits.RD3 = 0;
0759  0020     MOVLB 0x0
075A  118F     BCF PORTD, 0x3
197:               SPI_ETHWIZ_Write(0x00);
075B  3000     MOVLW 0x0
075C  3182     MOVLP 0x2
075D  228D     CALL 0x28D
075E  3185     MOVLP 0x5
198:               SPI_ETHWIZ_Write(0x10); //Address = 0x0010
075F  3010     MOVLW 0x10
0760  3182     MOVLP 0x2
0761  228D     CALL 0x28D
0762  3185     MOVLP 0x5
199:               SPI_ETHWIZ_Write(s0_reg_write);
0763  087D     MOVF s0_reg_write, W
0764  3182     MOVLP 0x2
0765  228D     CALL 0x28D
0766  3185     MOVLP 0x5
200:               SPI_ETHWIZ_Write(0x27);
0767  3027     MOVLW 0x27
0768  3182     MOVLP 0x2
0769  228D     CALL 0x28D
076A  3185     MOVLP 0x5
201:               SPI_ETHWIZ_Write(0x10); //10,000 = 0x2710
076B  3010     MOVLW 0x10
076C  3182     MOVLP 0x2
076D  228D     CALL 0x28D
076E  3185     MOVLP 0x5
202:               PORTDbits.RD3 = 1;
076F  0020     MOVLB 0x0
0770  158F     BSF PORTD, 0x3
203:               __delay_ms(1);
0771  300B     MOVLW 0xB
0772  00F1     MOVWF i2cWriteData
0773  3062     MOVLW 0x62
0774  0B89     DECFSZ WREG, F
0775  2F74     GOTO 0x774
0776  0BF1     DECFSZ i2cWriteData, F
0777  2F74     GOTO 0x774
0778  3200     BRA 0x779
204:                  
205:               //Set the S0 Max Segment Size Register to d'1460' - CMH
206:               PORTDbits.RD3 = 0;
0779  0020     MOVLB 0x0
077A  118F     BCF PORTD, 0x3
207:               SPI_ETHWIZ_Write(0x00);
077B  3000     MOVLW 0x0
077C  3182     MOVLP 0x2
077D  228D     CALL 0x28D
077E  3185     MOVLP 0x5
208:               SPI_ETHWIZ_Write(0x12); //Address = 0x0012
077F  3012     MOVLW 0x12
0780  3182     MOVLP 0x2
0781  228D     CALL 0x28D
0782  3185     MOVLP 0x5
209:               SPI_ETHWIZ_Write(s0_reg_write);
0783  087D     MOVF s0_reg_write, W
0784  3182     MOVLP 0x2
0785  228D     CALL 0x28D
0786  3185     MOVLP 0x5
210:               SPI_ETHWIZ_Write(0x05);
0787  3005     MOVLW 0x5
0788  3182     MOVLP 0x2
0789  228D     CALL 0x28D
078A  3185     MOVLP 0x5
211:               SPI_ETHWIZ_Write(0xB4); //1,460 = 0x05B4
078B  30B4     MOVLW 0xB4
078C  3182     MOVLP 0x2
078D  228D     CALL 0x28D
078E  3185     MOVLP 0x5
212:               PORTDbits.RD3 = 1;
078F  0020     MOVLB 0x0
0790  158F     BSF PORTD, 0x3
213:               __delay_ms(1);
0791  300B     MOVLW 0xB
0792  00F1     MOVWF i2cWriteData
0793  3062     MOVLW 0x62
0794  0B89     DECFSZ WREG, F
0795  2F94     GOTO 0x794
0796  0BF1     DECFSZ i2cWriteData, F
0797  2F94     GOTO 0x794
0798  3200     BRA 0x799
214:               
215:               //Set the S0 Fragment Register to d'0' to not allow for IP Fragments - CMH
216:               PORTDbits.RD3 = 0;
0799  0020     MOVLB 0x0
079A  118F     BCF PORTD, 0x3
217:               SPI_ETHWIZ_Write(0x00);
079B  3000     MOVLW 0x0
079C  3182     MOVLP 0x2
079D  228D     CALL 0x28D
079E  3185     MOVLP 0x5
218:               SPI_ETHWIZ_Write(0x2D); //Address = 0x002D
079F  302D     MOVLW 0x2D
07A0  3182     MOVLP 0x2
07A1  228D     CALL 0x28D
07A2  3185     MOVLP 0x5
219:               SPI_ETHWIZ_Write(s0_reg_write);
07A3  087D     MOVF s0_reg_write, W
07A4  3182     MOVLP 0x2
07A5  228D     CALL 0x28D
07A6  3185     MOVLP 0x5
220:               SPI_ETHWIZ_Write(0x00);
07A7  3000     MOVLW 0x0
07A8  3182     MOVLP 0x2
07A9  228D     CALL 0x28D
07AA  3185     MOVLP 0x5
221:               SPI_ETHWIZ_Write(0x00); //0 = 0x0000
07AB  3000     MOVLW 0x0
07AC  3182     MOVLP 0x2
07AD  228D     CALL 0x28D
07AE  3185     MOVLP 0x5
222:               PORTDbits.RD3 = 1;
07AF  0020     MOVLB 0x0
07B0  158F     BSF PORTD, 0x3
223:               __delay_ms(1);
07B1  300B     MOVLW 0xB
07B2  00F1     MOVWF i2cWriteData
07B3  3062     MOVLW 0x62
07B4  0B89     DECFSZ WREG, F
07B5  2FB4     GOTO 0x7B4
07B6  0BF1     DECFSZ i2cWriteData, F
07B7  2FB4     GOTO 0x7B4
07B8  3200     BRA 0x7B9
224:               
225:               //Set the S0 Keep Alive Time Register to d'10' - CMH
226:               PORTDbits.RD3 = 0;
07B9  0020     MOVLB 0x0
07BA  118F     BCF PORTD, 0x3
227:               SPI_ETHWIZ_Write(0x00);
07BB  3000     MOVLW 0x0
07BC  3182     MOVLP 0x2
07BD  228D     CALL 0x28D
07BE  3185     MOVLP 0x5
228:               SPI_ETHWIZ_Write(0x2F); //Address = 0x002F
07BF  302F     MOVLW 0x2F
07C0  3182     MOVLP 0x2
07C1  228D     CALL 0x28D
07C2  3185     MOVLP 0x5
229:               SPI_ETHWIZ_Write(s0_reg_write);
07C3  087D     MOVF s0_reg_write, W
07C4  3182     MOVLP 0x2
07C5  228D     CALL 0x28D
07C6  3185     MOVLP 0x5
230:               SPI_ETHWIZ_Write(0x0A); //10 = 0x0A
07C7  300A     MOVLW 0xA
07C8  3182     MOVLP 0x2
07C9  228D     CALL 0x28D
07CA  3185     MOVLP 0x5
231:               PORTDbits.RD3 = 1;
07CB  0020     MOVLB 0x0
07CC  158F     BSF PORTD, 0x3
232:               __delay_ms(1);
07CD  300B     MOVLW 0xB
07CE  00F1     MOVWF i2cWriteData
07CF  3062     MOVLW 0x62
07D0  0B89     DECFSZ WREG, F
07D1  2FD0     GOTO 0x7D0
07D2  0BF1     DECFSZ i2cWriteData, F
07D3  2FD0     GOTO 0x7D0
07D4  3200     BRA 0x7D5
233:           }
07D5  0008     RETURN
234:           
235:           
236:           // ************************************************************
237:           //
238:           //  This function goes through the sequence to create the 
239:           //  Socket 0. Will open and then listen.
240:           //
241:           // ************************************************************
242:           void eth_wiz_createSocket(void){
243:               uint8_t connected = 0;
04EE  01F2     CLRF connected
244:               do{
245:                   //Open the Socket 0 - CMH
246:                   PORTDbits.RD3 = 0;
04EF  0020     MOVLB 0x0
04F0  118F     BCF PORTD, 0x3
247:                   SPI_ETHWIZ_Write(0x00);
04F1  3000     MOVLW 0x0
04F2  3182     MOVLP 0x2
04F3  228D     CALL 0x28D
04F4  3184     MOVLP 0x4
248:                   SPI_ETHWIZ_Write(0x01); //Address = 0x0001
04F5  3001     MOVLW 0x1
04F6  3182     MOVLP 0x2
04F7  228D     CALL 0x28D
04F8  3184     MOVLP 0x4
249:                   SPI_ETHWIZ_Write(s0_reg_write);
04F9  087D     MOVF s0_reg_write, W
04FA  3182     MOVLP 0x2
04FB  228D     CALL 0x28D
04FC  3184     MOVLP 0x4
250:                   SPI_ETHWIZ_Write(0x01); //OPEN = 0x01
04FD  3001     MOVLW 0x1
04FE  3182     MOVLP 0x2
04FF  228D     CALL 0x28D
0500  3184     MOVLP 0x4
251:                   PORTDbits.RD3 = 1;
0501  0020     MOVLB 0x0
0502  158F     BSF PORTD, 0x3
252:                   __delay_ms(1);
0503  300B     MOVLW 0xB
0504  00F1     MOVWF i2cWriteData
0505  3062     MOVLW 0x62
0506  0B89     DECFSZ WREG, F
0507  2D06     GOTO 0x506
0508  0BF1     DECFSZ i2cWriteData, F
0509  2D06     GOTO 0x506
050A  3200     BRA 0x50B
253:           
254:                   //check if the socket is open - CMH
255:                   do{
256:                       PORTDbits.RD3 = 0;
050B  0020     MOVLB 0x0
050C  118F     BCF PORTD, 0x3
257:                       SPI_ETHWIZ_Write(0x00);
050D  3000     MOVLW 0x0
050E  3182     MOVLP 0x2
050F  228D     CALL 0x28D
0510  3184     MOVLP 0x4
258:                       SPI_ETHWIZ_Write(0x03); //Address = 0x0001
0511  3003     MOVLW 0x3
0512  3182     MOVLP 0x2
0513  228D     CALL 0x28D
0514  3184     MOVLP 0x4
259:                       SPI_ETHWIZ_Write(s0_reg_read);
0515  0020     MOVLB 0x0
0516  0837     MOVF s0_reg_read, W
0517  3182     MOVLP 0x2
0518  228D     CALL 0x28D
0519  3184     MOVLP 0x4
260:                       s0_SR_check = SPI_ETHWIZ_Write(0x00); 
051A  3000     MOVLW 0x0
051B  3182     MOVLP 0x2
051C  228D     CALL 0x28D
051D  3184     MOVLP 0x4
051E  00F1     MOVWF i2cWriteData
051F  0871     MOVF i2cWriteData, W
0520  0020     MOVLB 0x0
0521  00A7     MOVWF s0_SR_check
261:                       PORTDbits.RD3 = 1;
0522  158F     BSF PORTD, 0x3
262:                   }while(s0_SR_check != 0x13); //SR needs to equal SOCK_INIT
0523  3013     MOVLW 0x13
0524  0627     XORWF s0_SR_check, W
0525  1D03     BTFSS STATUS, 0x2
0526  2D0B     GOTO 0x50B
263:           
264:                   //Order the socket to listen for a connection request from
265:                   //the "client" - CMH
266:                   PORTDbits.RD3 = 0;
0527  118F     BCF PORTD, 0x3
267:                   SPI_ETHWIZ_Write(0x00);
0528  3000     MOVLW 0x0
0529  3182     MOVLP 0x2
052A  228D     CALL 0x28D
052B  3184     MOVLP 0x4
268:                   SPI_ETHWIZ_Write(0x01); //Address = 0x0001
052C  3001     MOVLW 0x1
052D  3182     MOVLP 0x2
052E  228D     CALL 0x28D
052F  3184     MOVLP 0x4
269:                   SPI_ETHWIZ_Write(s0_reg_write);
0530  087D     MOVF s0_reg_write, W
0531  3182     MOVLP 0x2
0532  228D     CALL 0x28D
0533  3184     MOVLP 0x4
270:                   SPI_ETHWIZ_Write(0x02); //LISTEN = 0x02
0534  3002     MOVLW 0x2
0535  3182     MOVLP 0x2
0536  228D     CALL 0x28D
0537  3184     MOVLP 0x4
271:                   PORTDbits.RD3 = 1;
0538  0020     MOVLB 0x0
0539  158F     BSF PORTD, 0x3
272:                   __delay_ms(1);
053A  300B     MOVLW 0xB
053B  00F1     MOVWF i2cWriteData
053C  3062     MOVLW 0x62
053D  0B89     DECFSZ WREG, F
053E  2D3D     GOTO 0x53D
053F  0BF1     DECFSZ i2cWriteData, F
0540  2D3D     GOTO 0x53D
0541  3200     BRA 0x542
273:           
274:                   //check if the socket is listening for a client - CMH
275:                   do{
276:                       PORTDbits.RD3 = 0;
0542  0020     MOVLB 0x0
0543  118F     BCF PORTD, 0x3
277:                       SPI_ETHWIZ_Write(0x00);
0544  3000     MOVLW 0x0
0545  3182     MOVLP 0x2
0546  228D     CALL 0x28D
0547  3184     MOVLP 0x4
278:                       SPI_ETHWIZ_Write(0x03); //Address = 0x0003
0548  3003     MOVLW 0x3
0549  3182     MOVLP 0x2
054A  228D     CALL 0x28D
054B  3184     MOVLP 0x4
279:                       SPI_ETHWIZ_Write(s0_reg_read);
054C  0020     MOVLB 0x0
054D  0837     MOVF s0_reg_read, W
054E  3182     MOVLP 0x2
054F  228D     CALL 0x28D
0550  3184     MOVLP 0x4
280:                       s0_SR_check = SPI_ETHWIZ_Write(0x00); 
0551  3000     MOVLW 0x0
0552  3182     MOVLP 0x2
0553  228D     CALL 0x28D
0554  3184     MOVLP 0x4
0555  00F1     MOVWF i2cWriteData
0556  0871     MOVF i2cWriteData, W
0557  0020     MOVLB 0x0
0558  00A7     MOVWF s0_SR_check
281:                       PORTDbits.RD3 = 1;
0559  158F     BSF PORTD, 0x3
282:                   }while(s0_SR_check != 0x13); //SR needs to equal SOCKET_LISTEN - CMH
055A  3013     MOVLW 0x13
055B  0627     XORWF s0_SR_check, W
055C  1D03     BTFSS STATUS, 0x2
055D  2D42     GOTO 0x542
283:           
284:                   while(PORTBbits.RB0 != 0) continue; //until INTn is asserted - CMH
055E  180D     BTFSC PORTB, 0x0
055F  2D5E     GOTO 0x55E
285:           
286:                   //Read in the S0_IR and S0_SR register for interrupt checking - CMH
287:                   PORTDbits.RD3 = 0;
0560  118F     BCF PORTD, 0x3
288:                   SPI_ETHWIZ_Write(0x00);
0561  3000     MOVLW 0x0
0562  3182     MOVLP 0x2
0563  228D     CALL 0x28D
0564  3184     MOVLP 0x4
289:                   SPI_ETHWIZ_Write(0x02); //Address = 0x0002
0565  3002     MOVLW 0x2
0566  3182     MOVLP 0x2
0567  228D     CALL 0x28D
0568  3184     MOVLP 0x4
290:                   SPI_ETHWIZ_Write(s0_reg_read);
0569  0020     MOVLB 0x0
056A  0837     MOVF s0_reg_read, W
056B  3182     MOVLP 0x2
056C  228D     CALL 0x28D
056D  3184     MOVLP 0x4
291:                   s0_IR_check = SPI_ETHWIZ_Write(0x00);   //0x0002
056E  3000     MOVLW 0x0
056F  3182     MOVLP 0x2
0570  228D     CALL 0x28D
0571  3184     MOVLP 0x4
0572  00F1     MOVWF i2cWriteData
0573  0871     MOVF i2cWriteData, W
0574  0020     MOVLB 0x0
0575  00A6     MOVWF s0_IR_check
292:                   s0_SR_check = SPI_ETHWIZ_Write(0x00);   //0x0003
0576  3000     MOVLW 0x0
0577  3182     MOVLP 0x2
0578  228D     CALL 0x28D
0579  3184     MOVLP 0x4
057A  00F1     MOVWF i2cWriteData
057B  0871     MOVF i2cWriteData, W
057C  0020     MOVLB 0x0
057D  00A7     MOVWF s0_SR_check
293:                   PORTDbits.RD3 = 1;
057E  158F     BSF PORTD, 0x3
294:               
295:                   //if Timed out and socket closed - CMH
296:                   if((s0_IR_check & 0x08) == 0x08 && s0_SR_check == 0x00){
057F  1DA6     BTFSS s0_IR_check, 0x3
0580  2D99     GOTO 0x599
0581  0827     MOVF s0_SR_check, W
0582  1D03     BTFSS STATUS, 0x2
0583  2D99     GOTO 0x599
297:                       //Clear (by writing a 1) the time out flag 
298:                       //to de-assert the INTn Pin - CMH
299:                       PORTDbits.RD3 = 0;
0584  118F     BCF PORTD, 0x3
300:                       SPI_ETHWIZ_Write(0x00);
0585  3000     MOVLW 0x0
0586  3182     MOVLP 0x2
0587  228D     CALL 0x28D
0588  3184     MOVLP 0x4
301:                       SPI_ETHWIZ_Write(0x02); //Address = 0x0002
0589  3002     MOVLW 0x2
058A  3182     MOVLP 0x2
058B  228D     CALL 0x28D
058C  3184     MOVLP 0x4
302:                       SPI_ETHWIZ_Write(s0_reg_write);
058D  087D     MOVF s0_reg_write, W
058E  3182     MOVLP 0x2
058F  228D     CALL 0x28D
0590  3184     MOVLP 0x4
303:                       SPI_ETHWIZ_Write(0x08);
0591  3008     MOVLW 0x8
0592  3182     MOVLP 0x2
0593  228D     CALL 0x28D
0594  3184     MOVLP 0x4
304:                       PORTDbits.RD3 = 1;
0595  0020     MOVLB 0x0
0596  158F     BSF PORTD, 0x3
305:                       
306:                       connected = 0;
0597  01F2     CLRF connected
307:                   }
0598  2DB4     GOTO 0x5B4
308:                   //if successfully connected and sock_established - CMH
309:                   else if((s0_IR_check & 0x01) == 0x01 && s0_SR_check == 0x17){
0599  1C26     BTFSS s0_IR_check, 0x0
059A  2DB4     GOTO 0x5B4
059B  3017     MOVLW 0x17
059C  0627     XORWF s0_SR_check, W
059D  1D03     BTFSS STATUS, 0x2
059E  2DB4     GOTO 0x5B4
310:                       //Clear (by writing a 1) the tconnection flag 
311:                       //to de-assert the INTn Pin - CMH
312:                       PORTDbits.RD3 = 0;
059F  118F     BCF PORTD, 0x3
313:                       SPI_ETHWIZ_Write(0x00);
05A0  3000     MOVLW 0x0
05A1  3182     MOVLP 0x2
05A2  228D     CALL 0x28D
05A3  3184     MOVLP 0x4
314:                       SPI_ETHWIZ_Write(0x02); //Address = 0x0002
05A4  3002     MOVLW 0x2
05A5  3182     MOVLP 0x2
05A6  228D     CALL 0x28D
05A7  3184     MOVLP 0x4
315:                       SPI_ETHWIZ_Write(s0_reg_write);
05A8  087D     MOVF s0_reg_write, W
05A9  3182     MOVLP 0x2
05AA  228D     CALL 0x28D
05AB  3184     MOVLP 0x4
316:                       SPI_ETHWIZ_Write(0x01);
05AC  3001     MOVLW 0x1
05AD  3182     MOVLP 0x2
05AE  228D     CALL 0x28D
05AF  3184     MOVLP 0x4
317:                       PORTDbits.RD3 = 1;
05B0  0020     MOVLB 0x0
05B1  158F     BSF PORTD, 0x3
318:                       
319:                       //Set the connected flag to exit loop and function - CMH
320:                       connected = 1;
05B2  01F2     CLRF connected
05B3  0AF2     INCF connected, F
321:                   }
322:                   
323:                   
324:               }while(connected == 0);
05B4  0872     MOVF connected, W
05B5  1D03     BTFSS STATUS, 0x2
05B6  0008     RETURN
05B7  2CEF     GOTO 0x4EF
325:                 
326:               
327:           }
328:           
329:           
330:           // ************************************************************
331:           //
332:           //  This function starts the transmission sequence for the 
333:           //  ETH WIZ. It finds the current location of the TX buffer
334:           //  pointer and then starts the write to buffer sequence at
335:           //  the address of the pointer. Data can be written to the
336:           //  buffer after calling this function.
337:           //
338:           // ************************************************************
339:           void eth_wiz_transmit_start(void){
340:               //Read in the starting tx pointer address - CMH
341:               PORTDbits.RD3 = 0;
032C  0020     MOVLB 0x0
032D  118F     BCF PORTD, 0x3
342:               SPI_ETHWIZ_Write(0x00);
032E  3000     MOVLW 0x0
032F  3182     MOVLP 0x2
0330  228D     CALL 0x28D
0331  3183     MOVLP 0x3
343:               SPI_ETHWIZ_Write(0x24); //Address = 0x0024
0332  3024     MOVLW 0x24
0333  3182     MOVLP 0x2
0334  228D     CALL 0x28D
0335  3183     MOVLP 0x3
344:               SPI_ETHWIZ_Write(s0_reg_read);
0336  0020     MOVLB 0x0
0337  0837     MOVF s0_reg_read, W
0338  3182     MOVLP 0x2
0339  228D     CALL 0x28D
033A  3183     MOVLP 0x3
345:               s0_tx_pointer_high = SPI_ETHWIZ_Write(0x00);
033B  3000     MOVLW 0x0
033C  3182     MOVLP 0x2
033D  228D     CALL 0x28D
033E  3183     MOVLP 0x3
033F  00F1     MOVWF i2cWriteData
0340  0871     MOVF i2cWriteData, W
0341  0020     MOVLB 0x0
0342  00AF     MOVWF s0_tx_pointer_high
346:               s0_tx_pointer_low  = SPI_ETHWIZ_Write(0x00);
0343  3000     MOVLW 0x0
0344  3182     MOVLP 0x2
0345  228D     CALL 0x28D
0346  3183     MOVLP 0x3
0347  00F1     MOVWF i2cWriteData
0348  0871     MOVF i2cWriteData, W
0349  0020     MOVLB 0x0
034A  00AE     MOVWF s0_tx_pointer_low
347:               PORTDbits.RD3 = 1;
034B  158F     BSF PORTD, 0x3
348:               PORTDbits.RD3 = 1;
034C  158F     BSF PORTD, 0x3
349:               
350:               //Start the write to buffer sequence - CMH
351:               PORTDbits.RD3 = 0;
034D  118F     BCF PORTD, 0x3
352:               SPI_ETHWIZ_Write(s0_tx_pointer_high);           //Address high
034E  082F     MOVF s0_tx_pointer_high, W
034F  3182     MOVLP 0x2
0350  228D     CALL 0x28D
0351  3183     MOVLP 0x3
353:               SPI_ETHWIZ_Write(s0_tx_pointer_low);            //Address low
0352  0020     MOVLB 0x0
0353  082E     MOVF s0_tx_pointer_low, W
0354  3182     MOVLP 0x2
0355  228D     CALL 0x28D
0356  3183     MOVLP 0x3
354:               SPI_ETHWIZ_Write(s0_tx_buf_write);              //TX Write Command
0357  0020     MOVLB 0x0
0358  0836     MOVF s0_tx_buf_write, W
0359  3182     MOVLP 0x2
035A  228D     CALL 0x28D
355:               
356:               //data can now be written to TX buffer in main program - CMH
357:           }
035B  0008     RETURN
358:           
359:           
360:           // ************************************************************
361:           //
362:           //  This function ends the transmission sequence into the TX
363:           //  buffer and the initiates the SEND sequence by calling the
364:           //  SEND command. After ending the TX write sequence, the TX
365:           //  pointer is updated to its new value by adding the number
366:           //  of written bytes to the previous value of the pointer.
367:           //  After that, the SEND command is sent.
368:           //
369:           // ************************************************************
370:           void eth_wiz_transmit_end(void){
371:               //De-assert RD3 to stop transmission into TX buffer - CMH
372:               PORTDbits.RD3 = 1;
03A1  0020     MOVLB 0x0
03A2  158F     BSF PORTD, 0x3
373:               
374:               //combined high and low bytes of tx pointer and add
375:               //the number of bytes added to buffer - CMH
376:               uint16_t value = (s0_tx_pointer_high << 8) | s0_tx_pointer_low;
03A3  082E     MOVF s0_tx_pointer_low, W
03A4  00F1     MOVWF i2cWriteData
03A5  01F2     CLRF connected
03A6  082F     MOVF s0_tx_pointer_high, W
03A7  00F3     MOVWF 0x73
03A8  01F4     CLRF 0x74
03A9  0873     MOVF 0x73, W
03AA  00F4     MOVWF 0x74
03AB  01F3     CLRF 0x73
03AC  0871     MOVF i2cWriteData, W
03AD  0473     IORWF 0x73, W
03AE  00F6     MOVWF value
03AF  0872     MOVF connected, W
03B0  0474     IORWF 0x74, W
03B1  00F7     MOVWF 0x77
377:               value = (value + 164) & (0xFFFF);
03B2  0876     MOVF value, W
03B3  3EA4     ADDLW 0xA4
03B4  00F6     MOVWF value
03B5  3000     MOVLW 0x0
03B6  3D77     ADDWFC 0x77, W
03B7  00F7     MOVWF 0x77
378:               s0_tx_pointer_high = (value & 0xFF00) >> 8;
03B8  0877     MOVF 0x77, W
03B9  00F1     MOVWF i2cWriteData
03BA  0871     MOVF i2cWriteData, W
03BB  00AF     MOVWF s0_tx_pointer_high
379:               s0_tx_pointer_low  = value & 0x00FF;
03BC  0876     MOVF value, W
03BD  00F1     MOVWF i2cWriteData
03BE  0871     MOVF i2cWriteData, W
03BF  00AE     MOVWF s0_tx_pointer_low
380:               
381:               //Update the pointer address for the amount of data added - CMH
382:               PORTDbits.RD3 = 0;
03C0  118F     BCF PORTD, 0x3
383:               SPI_ETHWIZ_Write(0x00);
03C1  3000     MOVLW 0x0
03C2  3182     MOVLP 0x2
03C3  228D     CALL 0x28D
03C4  3183     MOVLP 0x3
384:               SPI_ETHWIZ_Write(0x24); //Address = 0x0024
03C5  3024     MOVLW 0x24
03C6  3182     MOVLP 0x2
03C7  228D     CALL 0x28D
03C8  3183     MOVLP 0x3
385:               SPI_ETHWIZ_Write(s0_reg_write);
03C9  087D     MOVF s0_reg_write, W
03CA  3182     MOVLP 0x2
03CB  228D     CALL 0x28D
03CC  3183     MOVLP 0x3
386:               SPI_ETHWIZ_Write(s0_tx_pointer_high);
03CD  0020     MOVLB 0x0
03CE  082F     MOVF s0_tx_pointer_high, W
03CF  3182     MOVLP 0x2
03D0  228D     CALL 0x28D
03D1  3183     MOVLP 0x3
387:               SPI_ETHWIZ_Write(s0_tx_pointer_low);
03D2  0020     MOVLB 0x0
03D3  082E     MOVF s0_tx_pointer_low, W
03D4  3182     MOVLP 0x2
03D5  228D     CALL 0x28D
03D6  3183     MOVLP 0x3
388:               PORTDbits.RD3 = 1;
03D7  0020     MOVLB 0x0
03D8  158F     BSF PORTD, 0x3
389:               PORTDbits.RD3 = 1;
03D9  158F     BSF PORTD, 0x3
390:               
391:               //Initiate the send command in the S0_CR Register - CMH
392:               PORTDbits.RD3 = 0;
03DA  118F     BCF PORTD, 0x3
393:               SPI_ETHWIZ_Write(0x00);
03DB  3000     MOVLW 0x0
03DC  3182     MOVLP 0x2
03DD  228D     CALL 0x28D
03DE  3183     MOVLP 0x3
394:               SPI_ETHWIZ_Write(0x01); //Address = 0x0024
03DF  3001     MOVLW 0x1
03E0  3182     MOVLP 0x2
03E1  228D     CALL 0x28D
03E2  3183     MOVLP 0x3
395:               SPI_ETHWIZ_Write(s0_reg_write);
03E3  087D     MOVF s0_reg_write, W
03E4  3182     MOVLP 0x2
03E5  228D     CALL 0x28D
03E6  3183     MOVLP 0x3
396:               SPI_ETHWIZ_Write(0x20);   //SEND = 0x20
03E7  3020     MOVLW 0x20
03E8  3182     MOVLP 0x2
03E9  228D     CALL 0x28D
397:               PORTDbits.RD3 = 1;
03EA  0020     MOVLB 0x0
03EB  158F     BSF PORTD, 0x3
398:               
399:           }
03EC  0008     RETURN
400:           
401:           
402:           // ************************************************************
403:           //
404:           //  This function performs the receive data sequence. Will only
405:           //  be called after a receive interrupt is sent from the ETH
406:           //  WIZ.
407:           //
408:           // ************************************************************
409:           void eth_wiz_receive(void){
410:               //Read in Received Data Size Register (0x0026 - 0x0027),
411:               //the RX Read Data Pointer Register (0x0028 - 0x0029), and
412:               //the RX Write pointer Register (0x002A - 0x002B) - CMH
413:               PORTDbits.RD3 = 0;
414:               SPI_ETHWIZ_Write(0x00);
415:               SPI_ETHWIZ_Write(0x26); //Starting Address = 0x0026
416:               SPI_ETHWIZ_Write(s0_reg_read);
417:               s0_rx_datalength_high = SPI_ETHWIZ_Write(0x00);         //0x0026
418:               s0_rx_datalength_low  = SPI_ETHWIZ_Write(0x00);         //0x0027
419:               s0_rx_readpointer_high = SPI_ETHWIZ_Write(0x00);        //0x0028
420:               s0_rx_readpointer_low  = SPI_ETHWIZ_Write(0x00);        //0x0029
421:               s0_rx_writepointer_high = SPI_ETHWIZ_Write(0x00);       //0x002A
422:               s0_rx_writepointer_low  = SPI_ETHWIZ_Write(0x00);       //0x002B
423:               PORTDbits.RD3 = 1;
424:               
425:               //determine the amount of bytes to read in from RX buffer - CMH
426:               uint16_t datalength = (s0_rx_datalength_high << 8) | s0_rx_datalength_low;
427:               
428:               //Read in data from the RX buffer - CMH
429:               PORTDbits.RD3 = 0;
430:                //Starting Address = RX Read Data Pointer
431:               SPI_ETHWIZ_Write(s0_rx_readpointer_high);
432:               SPI_ETHWIZ_Write(s0_rx_readpointer_low);
433:               SPI_ETHWIZ_Write(s0_rx_buf_read);
434:               for(int i = 0; i < datalength; i++){
435:                   //Collect these values into an array - CMH
436:                   SPI_ETHWIZ_Write(0x00);
437:               }
438:               PORTDbits.RD3 = 1;
439:               __delay_us(1);
440:               
441:               //Update the Read Pointer to the Write Pointer Address - CMH
442:               PORTDbits.RD3 = 0;
443:               SPI_ETHWIZ_Write(0x00);
444:               SPI_ETHWIZ_Write(0x28); //Starting Address = 0x0028
445:               SPI_ETHWIZ_Write(s0_reg_write);
446:               SPI_ETHWIZ_Write(s0_rx_writepointer_high);
447:               SPI_ETHWIZ_Write(s0_rx_writepointer_low);
448:               PORTDbits.RD3 = 1;
449:               
450:               //Order the RECV command to notify W5500 that the data was read in - CMH
451:               PORTDbits.RD3 = 0;
452:               SPI_ETHWIZ_Write(0x00);
453:               SPI_ETHWIZ_Write(0x01); //Address = 0x0024
454:               SPI_ETHWIZ_Write(s0_reg_write);
455:               SPI_ETHWIZ_Write(0x40);   //RECV = 0x40
456:               PORTDbits.RD3 = 1;
457:           }
458:           
---  C:/Users/cmh52/Desktop/SeniorDesign.X/config.c  ----------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: config.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 1.00
12:             */
13:            
14:            
15:            #include "config.h"
16:            
17:            // ************************************************************
18:            //
19:            //  This function setups oscillator to function at 32MHz.
20:            //
21:            // ************************************************************
22:            void OSCILLATOR_Initialize(void) {
23:                OSCCON1 = 0x60;     // NOSC HFINTOSC; NDIV 1; 
024B  3060     MOVLW 0x60
024C  0031     MOVLB 0x11
024D  008D     MOVWF OSCCON1
24:                OSCFRQ = 0x06;      // Fosc set to 32MHz
024E  3006     MOVLW 0x6
024F  0093     MOVWF OSCFRQ
25:            }
0250  0008     RETURN
26:            
27:            
28:            // ************************************************************
29:            //
30:            //  This function is the first Initialization function for 
31:            //  the port pins. Within all pins are set to be digital, set
32:            //  to be either an input or an output, and the various serial
33:            //  protocols have pins mapped for use. The necessary interrupts
34:            //  are enabled and their respective flags are cleared.
35:            //
36:            // ************************************************************
37:            void PORT_PIN_Initialize1(void) {
38:                
39:                //Set all pins of the microcontroller to digital pins - CMH
40:                ANSELA = 0x00;
035C  003E     MOVLB 0x1E
035D  01B8     CLRF ANSELA
41:                ANSELB = 0x00;
035E  01C3     CLRF ANSELB
42:                ANSELC = 0x00;
035F  01CE     CLRF ANSELC
43:                ANSELD = 0x00;
0360  01D9     CLRF ANSELD
44:                ANSELE = 0x00;
0361  01E4     CLRF ANSELE
45:                
46:                //Set up each pin to either be an input(1) or an output(0) based on
47:                //its necessary function. Each binary value corresponds to a port - CMH
48:                TRISA = 0x00;
0362  0020     MOVLB 0x0
0363  0191     CLRF TRISA
49:                TRISB = 0b01100101;
0364  3065     MOVLW 0x65
0365  0092     MOVWF TRISB
50:                TRISC = 0b10011000;
0366  3098     MOVLW 0x98
0367  0093     MOVWF TRISC
51:                TRISD = 0x00;
0368  0194     CLRF TRISD
52:                TRISE = 0x00;
0369  0195     CLRF TRISE
53:                
54:                //Initially set all pins to 0 (low) state - CMH 
55:                PORTA = 0x00;
036A  018C     CLRF PORTA
56:                PORTB = 0x00;
036B  018D     CLRF PORTB
57:                PORTC = 0x00;
036C  018E     CLRF PORTC
58:                PORTD = 0x00;
036D  018F     CLRF PORTD
59:                PORTE = 0x00;
036E  0190     CLRF PORTE
60:                
61:                //Turn off the latch for all pins - CMH
62:                LATA = 0x00;
036F  0196     CLRF LATA
63:                LATB = 0x00;
0370  0197     CLRF LATB
64:                LATC = 0x00;
0371  0198     CLRF LATC
65:                LATD = 0x00;
0372  0199     CLRF LATD
66:                LATE = 0x00;
0373  019A     CLRF LATE
67:                
68:                //Turn off interrupts to allow for the unlocking sequence below - CMH
69:                PIE3bits.RCIE = 0;
0374  002E     MOVLB 0xE
0375  1299     BCF PIE3, 0x5
70:                INTCONbits.PEIE = 0;
0376  130B     BCF 0x70B, 0x6
71:                INTCONbits.GIE = 0;
0377  138B     BCF 0x70B, 0x7
72:                PIE0bits.IOCIE = 0;
0378  1216     BCF PIE0, 0x4
73:                
74:                //Unlock Peripheral Pin Select (PPS) using the unlock sequence - CMH
75:                PPSLOCK = 0x55;
0379  3055     MOVLW 0x55
037A  003D     MOVLB 0x1D
037B  008F     MOVWF PPSLOCK
76:                PPSLOCK = 0xAA;
037C  30AA     MOVLW 0xAA
037D  008F     MOVWF PPSLOCK
77:                PPSLOCKbits.PPSLOCKED = 0;
037E  100F     BCF PPSLOCK, 0x0
78:                
79:                //Sets up the pins for UART between PIC and GNSS 5 - CMH
80:                RC6PPS = 0x10;
037F  3010     MOVLW 0x10
0380  003E     MOVLB 0x1E
0381  00A6     MOVWF RC6PPS
81:                RXPPS = 0x17; 
0382  3017     MOVLW 0x17
0383  003D     MOVLB 0x1D
0384  00CB     MOVWF RXPPS
82:                
83:                //Sets up the pins for SPI on SSP1 between PIC and Cameras - CMH 
84:                SSP1DATPPS = 0x0E;  //MISO - RB6
0385  300E     MOVLW 0xE
0386  00C6     MOVWF SSP1DATPPS
85:                RB7PPS = 0x14;      //SCLK
0387  3014     MOVLW 0x14
0388  003E     MOVLB 0x1E
0389  009F     MOVWF RB7PPS
86:                RC1PPS = 0x15;      //MOSI     
038A  3015     MOVLW 0x15
038B  00A1     MOVWF RC1PPS
87:                    
88:                //Sets up the pins for I2C on SSP2 between PIC and Cameras - CMH
89:                SSP2DATPPS = 0x14;  
038C  3014     MOVLW 0x14
038D  003D     MOVLB 0x1D
038E  00C9     MOVWF SSP2DATPPS
90:                RC3PPS = 0x16;      
038F  3016     MOVLW 0x16
0390  003E     MOVLB 0x1E
0391  00A3     MOVWF RC3PPS
91:                RC4PPS = 0x17;      
0392  3017     MOVLW 0x17
0393  00A4     MOVWF RC4PPS
92:                
93:                //Lock PPS using the locking sequence - CMH
94:                PPSLOCK = 0x55;
0394  3055     MOVLW 0x55
0395  003D     MOVLB 0x1D
0396  008F     MOVWF PPSLOCK
95:                PPSLOCK = 0xAA;
0397  30AA     MOVLW 0xAA
0398  008F     MOVWF PPSLOCK
96:                PPSLOCKbits.PPSLOCKED = 1;
0399  140F     BSF PPSLOCK, 0x0
97:               
98:                //Re-enable the necessary interrupts - CMH
99:                PIE3bits.RCIE = 1;
039A  002E     MOVLB 0xE
039B  1699     BSF PIE3, 0x5
100:               INTCONbits.PEIE = 1;
039C  170B     BSF 0x70B, 0x6
101:               INTCONbits.GIE = 1;
039D  178B     BSF 0x70B, 0x7
102:               PIE0bits.IOCIE = 1;
039E  1616     BSF PIE0, 0x4
103:            
104:               //Clear all the interrupt flags - CMH
105:               PIR3 = 0;               
039F  018F     CLRF PIR3
106:           }
03A0  0008     RETURN
107:           
108:           // ************************************************************
109:           //
110:           //  This function is the second Initialization function for 
111:           //  the port pins. Within all pins are set to be digital, set
112:           //  to be either an input or an output, and the various serial
113:           //  protocols have pins mapped for use. The necessary interrupts
114:           //  are re-enabled and their respective flags are cleared.
115:           //
116:           // ************************************************************
117:           void PORT_PIN_Initialize2(void) {
118:               
119:               //Turn off the interrupts to allow for the PPS unlocking sequence - CMH
120:               PIE3bits.RCIE = 0;
02E2  002E     MOVLB 0xE
02E3  1299     BCF PIE3, 0x5
121:               INTCONbits.PEIE = 0;
02E4  130B     BCF 0x70B, 0x6
122:               INTCONbits.GIE = 0;
02E5  138B     BCF 0x70B, 0x7
123:               PIE0bits.IOCIE = 0;
02E6  1216     BCF PIE0, 0x4
124:               
125:               //Unlock PPS using the unlocking sequence - CMH
126:               PPSLOCK = 0x55;
02E7  3055     MOVLW 0x55
02E8  003D     MOVLB 0x1D
02E9  008F     MOVWF PPSLOCK
127:               PPSLOCK = 0xAA;
02EA  30AA     MOVLW 0xAA
02EB  008F     MOVWF PPSLOCK
128:               PPSLOCKbits.PPSLOCKED = 0;
02EC  100F     BCF PPSLOCK, 0x0
129:               
130:               //Set up the pins for SPI on SSP2 between PIC and ETH WIZ - CMH
131:               //Replaces the I2C that was previously on SSP2 - CMH
132:               SSP2DATPPS = 0x0A;  
02ED  300A     MOVLW 0xA
02EE  00C9     MOVWF SSP2DATPPS
133:               RB1PPS = 0x16;      
02EF  3016     MOVLW 0x16
02F0  003E     MOVLB 0x1E
02F1  0099     MOVWF RB1PPS
134:               RB3PPS = 0x17;      
02F2  3017     MOVLW 0x17
02F3  009B     MOVWF RB3PPS
135:                
136:               //Lock the PPS using the locking sequence - CMH
137:               PPSLOCK = 0x55;
02F4  3055     MOVLW 0x55
02F5  003D     MOVLB 0x1D
02F6  008F     MOVWF PPSLOCK
138:               PPSLOCK = 0xAA;
02F7  30AA     MOVLW 0xAA
02F8  008F     MOVWF PPSLOCK
139:               PPSLOCKbits.PPSLOCKED = 1;
02F9  140F     BSF PPSLOCK, 0x0
140:              
141:               //Re-enable the necessary interrupts - CMH
142:               PIE3bits.RCIE = 1;
02FA  002E     MOVLB 0xE
02FB  1699     BSF PIE3, 0x5
143:               INTCONbits.PEIE = 1;
02FC  170B     BSF 0x70B, 0x6
144:               INTCONbits.GIE = 1;
02FD  178B     BSF 0x70B, 0x7
145:               PIE0bits.IOCIE = 1;
02FE  1616     BSF PIE0, 0x4
146:               
147:               //Clear all the respective interrupt flags - CMH
148:               PIR3 = 0;              
02FF  018F     CLRF PIR3
149:           }
0300  0008     RETURN
---  C:/Users/cmh52/Desktop/SeniorDesign.X/arducam.c  ---------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: arducam.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 0.01
12:             */
13:            
14:            #include "arducam.h"
15:            #include "serial_spi.h"
16:            
17:            // ************************************************************
18:            //
19:            //  This function initializes the arducam to the desired
20:            //  settings through the I2C bus.
21:            //
22:            // ************************************************************
23:            void arducam_initialize(void){
24:                
25:            }
023E  0008     RETURN
26:            
27:            
28:            // ************************************************************
29:            //
30:            //  This function gets the captures an image from the buffer
31:            //  on the Arducam using the SPI bus.
32:            //
33:            // ************************************************************
34:            void arducam_capture(void){
35:                
36:                uint8_t data = SPI_Write(0x00);
37:                
38:                
39:            }
40:            
41:            
42:            // ************************************************************
43:            //
44:            //  This function sends the received image from the Arducam 
45:            //  over the SPI to the ETH WIZ to be sent to the ground 
46:            //  station software.
47:            //
48:            // ************************************************************
49:            void arducam_send(void){
50:                
51:            }
---  C:/Users/cmh52/Desktop/SeniorDesign.X/2  -----------------------------------------------------------
027A  0000     NOP
027B  0000     NOP
027C  0000     NOP
027D  0000     NOP
027E  0000     NOP
027F  0000     NOP
0280  0000     NOP
0281  0000     NOP
0282  0008     RETURN
