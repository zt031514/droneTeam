Disassembly Listing for SeniorDesign
Generated From:
C:/Users/cmh52/Desktop/SeniorDesign.X/dist/default/debug/SeniorDesign.X.debug.elf
Mar 7, 2019 5:24:00 PM

---  C:/Users/cmh52/Desktop/SeniorDesign.X/serial_uart.c  -----------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: serial_uart.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 0.01
12:             */
13:            
14:            #include "serial_uart.h"
15:            
16:            // ************************************************************
17:            //
18:            //  This function initializes the UART that is used to 
19:            //  communicate between the GNSS 5 Click module and the PIC.
20:            //  The UART bus is set up to
21:            //
22:            //      COMMENT NOT COMPLETE
23:            //
24:            // ************************************************************
25:            void UART_Initialize(void) {
26:                
27:                //Initialize UART for Asynchronous 8-bit receive and transmission
28:                BAUD1CON = 0x08;
1006  3008     MOVLW 0x8
1007  0022     MOVLB 0x2
1008  009F     MOVWF BAUD1CON
29:                TX1STA = 0x24;
1009  3024     MOVLW 0x24
100A  009E     MOVWF TX1STA
30:                RC1STA = 0x90;
100B  3090     MOVLW 0x90
100C  009D     MOVWF RC1STA
31:                
32:                //Set Baud rate - 115.2k
33:                SP1BRGL = 0x44;//0x44;    
100D  3044     MOVLW 0x44
100E  009B     MOVWF SP1BRG
34:                SP1BRGH = 0x00;
100F  019C     CLRF SP1BRGH
35:            
36:                //Clear Interrupt flags - CMH
37:                PIR3bits.RCIF = 0;
1010  002E     MOVLB 0xE
1011  128F     BCF PIR3, 0x5
38:            
39:            }
1012  0008     RETURN
40:            
41:            // ************************************************************
42:            //
43:            //  This function reads in data through UART. It first checks
44:            //  to make sure all the various flag are set and looks for an
45:            //  over run error. It then receives the byte of data and clears
46:            //  the necessary flags. The received data is then returned from
47:            //  the function as an unsigned 8bit integer.
48:            //
49:            // ************************************************************
50:            uint8_t UART_Read(void) {
51:                
52:                //Variable for received byte - CMH
53:                uint8_t c;
54:            
55:                //Wait until the receive interrupt flag is set - CMH
56:                while(!(PIR3bits.RCIF));
57:                
58:                if(RC1STAbits.OERR) // check for over run error  - CMH
59:                {
60:                    RC1STAbits.CREN = 0;
61:                    RC1STAbits.CREN = 1; //Reset CREN - CMH
62:                }
63:                //Clear interrupt on change flag - CMH
64:                IOCCFbits.IOCCF0 = 0;
65:                
66:                //Read byte from RC1REG and clear receive interrupt
67:                // flag if receive interrupt flag is set - CMH
68:                if(PIR3bits.RCIF == 1)
69:                {
70:                   c = RC1REG;          //Save received byte in variable - CMH
71:                   PIR3bits.RCIF = 0;   //Clear receive interrupt flag - CMH
72:                }
73:                
74:                //Return received character - CMH
75:                return c;
76:                
77:            }
78:            
79:            // ************************************************************
80:            //
81:            //  This function acts as the write command to be used with
82:            //  printf. It takes in a unsigned 8bit integer as the value
83:            //  to be sent. It then waits until both the transmission 
84:            //  interrupt flag and TRMT are set. The byte is stored in
85:            //  the Transmission register to be sent.
86:            //
87:            // ************************************************************
88:            void putch(unsigned char byte)  
89:            {
90:                //Wait while TXIF and TRMT both are not set - CMH
91:                while(!(PIR3bits.TXIF) && !(TX1STAbits.TRMT)); 
92:                
93:                //Set TX1REG equal to byte - CMH
94:                TX1REG = byte;
95:            }
---  C:/Users/cmh52/Desktop/SeniorDesign.X/serial_spi.c  ------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: serial_spi.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 1.0
12:             */
13:            
14:            #include "serial_spi.h"
15:            
16:            // ************************************************************
17:            //
18:            //  This function initializes the SPI on SSP2 for use between
19:            //  the PIC and the ETH WIZ Click Module. It sets the PIC to
20:            //  be the master, to send a clock of 32 MHz, and to run in
21:            //  SPI Mode 0. It also clears the respective interrupt 
22:            //  flag.
23:            //
24:            // ************************************************************
25:            void SPI_ETHWIZ_Initialize(void) {
26:                
27:                SSP2STAT = 0b11000000;    //Sets sampling to middle of data output time and
1C92  30C0     MOVLW 0xC0
1C93  0023     MOVLB 0x3
1C94  0099     MOVWF SSP2STAT
28:                                    //sets CLK Edge for transmit on transition from active
29:                                    //to idle state - CMH
30:                
31:                SSP2CON1 = 0x20;    //Enables SPI as Master, Sets CLK Idle to low, and
1C95  3020     MOVLW 0x20
1C96  009A     MOVWF SSP2CON1
32:                                    //CLK = Fosc/4 = 8MHz - CMH
33:                
34:                SSP2IF = 0;         //Clear interrupt flag - CMH
1C97  002E     MOVLB 0xE
1C98  110F     BCF PIR3, 0x2
35:              
36:            }
1C99  0008     RETURN
37:            
38:            // ************************************************************
39:            //
40:            //  This function writes data to the ETH WIZ through the SPI bus
41:            //  on SSP2. It takes in an unsigned 8bit integer and immediately
42:            //  puts the value into the buffer to be sent. The program then
43:            //  waits for the interrupt flag to be set, signaling the 
44:            //  transmission is complete. The flag is then cleared. This
45:            //  function also doubles as a SPI Read function because the
46:            //  new value in the buffer that came from the ETH WIZ is returned
47:            //  from the function as an unsigned 8bit integer.
48:            //
49:            // ************************************************************
50:            uint8_t SPI_ETHWIZ_Write(uint8_t data) {
1CB4  00F0     MOVWF 0x770
51:                    
52:                SSP2BUF = data;             //Store value to be sent in buffer - CMH
1CB5  0870     MOVF 0x770, W
1CB6  0023     MOVLB 0x3
1CB7  0096     MOVWF SSP2BUF
53:                while(!SSP2IF) continue;    /*Wait for Interrupt Flag to signal 
1CB8  002E     MOVLB 0xE
1CB9  1D0F     BTFSS PIR3, 0x2
1CBA  2CB8     GOTO 0x4B8
54:                                              transmission complete - CMH*/
55:                SSP2IF = 0;                 //Clear interrupt flag - CMH
1CBB  110F     BCF PIR3, 0x2
56:                return(SSP2BUF);            //Return received value - CMH
1CBC  0023     MOVLB 0x3
1CBD  0816     MOVF SSP2BUF, W
1CBE  0008     RETURN
57:                
58:            }
59:            
60:            // ************************************************************
61:            //
62:            //  This function initializes the SPI bus on SSP1 to work with
63:            //  the FLIR Lepton thermal camera. It sets the PIC to be the 
64:            //  master, to send a clock of 8 MHz, and to run in SPI mode 3.
65:            //  The respective interrupt flag is also cleared.
66:            //
67:            // ************************************************************
68:            void SPI_FLIR_Initialize(void) {
69:                SSP1STAT = 0b10000000;  //Sets sampling to end of data output time and
1C9A  3080     MOVLW 0x80
1C9B  0023     MOVLB 0x3
1C9C  008F     MOVWF SSP1STAT
70:                                        //sets CLK Edge for transmit on transition from idle
71:                                        //to active state - CMH
72:                
73:                SSP1CON1 = 0b00110000;  //Enables SPI as Master, Sets CLK Idle to high, and
1C9D  3030     MOVLW 0x30
1C9E  0090     MOVWF SSP1CON1
74:                                        //CLK = Fosc/(4*(SSP1ADD+1)) - CMH
75:                //SSP1ADD = 0x01;       //CLK = 4 MHz
76:                //SSP1IE = 1;
77:                SSP1IF = 0;             //Clear interrupt flag - CMH
1C9F  002E     MOVLB 0xE
1CA0  100F     BCF PIR3, 0x0
78:              
79:            }
1CA1  0008     RETURN
80:            
81:            // ************************************************************
82:            //
83:            //  This function initializes the SPI bus on SSP1 to work with
84:            //  the Arducam visual camera. It sets the PIC to be the 
85:            //  master, to send a clock of 8 MHz, and to run in SPI mode 0.
86:            //  The respective interrupt flag is also cleared.
87:            //
88:            // ************************************************************
89:            void SPI_Arducam_Initialize(void) {
90:                
91:                SSP1STAT = 0b11000000;    //Sets sampling to end of data output time and
1C8A  30C0     MOVLW 0xC0
1C8B  0023     MOVLB 0x3
1C8C  008F     MOVWF SSP1STAT
92:                                    //sets CLK Edge for transmit on transition from active
93:                                    //to idle state - CMH
94:                
95:                SSP1CON1 = 0b00100000;    //Enables SPI as Master, Sets CLK Idle to low, and
1C8D  3020     MOVLW 0x20
1C8E  0090     MOVWF SSP1CON1
96:                                    //CLK = Fosc/4 = 8MHz - CMHH
97:                        
98:                SSP1IF = 0;         //Clear interrupt flag - CMH
1C8F  002E     MOVLB 0xE
1C90  100F     BCF PIR3, 0x0
99:              
100:           }
1C91  0008     RETURN
101:           
102:           // ************************************************************
103:           //
104:           //  This function is the SPI write function for the SPI bus on
105:           //  SSP1. It takes in an unsigned 8bit integer and immediately
106:           //  puts the value into the buffer to be sent. The program then
107:           //  waits for the interrupt flag to be set, signaling the 
108:           //  transmission is complete. The flag is then cleared. This
109:           //  function also doubles as a SPI Read function because the
110:           //  new value in the buffer that came from the slave is returned
111:           //  from the function as an unsigned 8bit integer.
112:           //
113:           // ************************************************************
114:           uint8_t SPI_Write(uint8_t data) {
115:               
116:               SSP1BUF = data;             //Store value to be sent in buffer - CMH
117:               while(!SSP1IF) continue;    /*Wait for Interrupt Flag to signal 
118:                                             transmission complete - CMH*/
119:               SSP1IF = 0;                 //Clear the interrupt flag - CMH
120:               return(SSP1BUF);            //Return received value - CMH
121:               
122:           }
123:           
124:           
---  C:/Users/cmh52/Desktop/SeniorDesign.X/serial_i2c.c  ------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: serial_i2c.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 1.00
12:             */
13:            
14:            #include "serial_i2c.h"
15:            
16:            
17:            // ************************************************************
18:            //
19:            //  This function initializes the I2C bus on the PIC. I2C 
20:            //  will be used only in the first portion of the program
21:            //  to set the required settings on both the FLIR Lepton
22:            //  thermal camera and the Arducam 2MP visual camera.
23:            //
24:            // ************************************************************
25:            void i2c_initialize(void) {
26:                
27:                SSP2CON1 = 0x28;        //ON with Master Mode - CMH
1CA2  3028     MOVLW 0x28
1CA3  0023     MOVLB 0x3
1CA4  009A     MOVWF SSP2CON1
28:                SSP2CON2 = 0x00;        //Clear Flags - CMH
1CA5  019B     CLRF SSP2CON2
29:                SSP2ADD = 0x4F;         //100 kHz with 4MHz clock - CMH
1CA6  304F     MOVLW 0x4F
1CA7  0097     MOVWF SSP2ADD
30:                SSP2STATbits.CKE = 0;   //Use I2C signal levels - CMH
1CA8  1319     BCF SSP2STAT, 0x6
31:                SSP2STATbits.SMP = 1;   //Standard Speed Mode - CMH
1CA9  1799     BSF SSP2STAT, 0x7
32:            }
1CAA  0008     RETURN
33:            
34:            // ************************************************************
35:            //
36:            //  This function is responsible for waiting for the I2C data
37:            //  line to idle. It is used in many of the I2C functions 
38:            //  written below.
39:            //
40:            // ************************************************************
41:            void i2c_waitForIdle()
42:            {
43:                //Waits for the I2C data line to idle - CMH
44:                while((SSP2CON2 & 0x1F)| SSP2STATbits.R_nW){};
1CBF  0023     MOVLB 0x3
1CC0  0C19     RRF SSP2STAT, W
1CC1  0C89     RRF 0x189, F
1CC2  3901     ANDLW 0x1
1CC3  00F0     MOVWF 0x1F0
1CC4  081B     MOVF SSP2CON2, W
1CC5  391F     ANDLW 0x1F
1CC6  0470     IORWF 0x1F0, W
1CC7  1903     BTFSC 0x183, 0x2
1CC8  0008     RETURN
1CC9  2CBF     GOTO 0x4BF
45:            }
46:            
47:            // ************************************************************
48:            //
49:            //  This function starts the I2C communication. It waits for
50:            //  an idle data line and then sends the start condition.
51:            //
52:            // ************************************************************
53:            void i2c_start()
54:            {
55:                //Wait for Idle - CMH
56:                i2c_waitForIdle();
1C80  319C     MOVLP 0x1C
1C81  24BF     CALL 0x4BF
57:                
58:                //Send Start Condition - CMH
59:                SSP2CON2bits.SEN = 1;
1C82  0023     MOVLB 0x3
1C83  141B     BSF SSP2CON2, 0x0
60:            }
1C84  0008     RETURN
61:            
62:            // ************************************************************
63:            //
64:            //  This function sends a repeat start signal for the I2C bus.
65:            //  It functions as a simultaneous stop then start signal. It
66:            //  waits for I2C to idle then send the repeat start condition.
67:            //
68:            // ************************************************************
69:            void i2c_repStart()
70:            {
71:                //Wait for Idle - CMH
72:                i2c_waitForIdle();
73:                
74:                //Send Restart Condition - CMH
75:                SSP2CON2bits.RSEN = 1;
76:            }
77:            
78:            // ************************************************************
79:            //
80:            //  This function stops transmission on the I2C bus. It waits
81:            //  for idle then sends the stop condition.
82:            //
83:            // ************************************************************
84:            void i2c_stop()
85:            {
86:                //Wait for Idle - CMH
87:                i2c_waitForIdle();
1C85  319C     MOVLP 0x1C
1C86  24BF     CALL 0x4BF
88:                
89:                //Send Stop condition - CMH
90:                SSP2CON2bits.PEN = 1;
1C87  0023     MOVLB 0x3
1C88  151B     BSF SSP2CON2, 0x2
91:            }
1C89  0008     RETURN
92:            
93:            // ************************************************************
94:            //
95:            //  This function reads in data being sent from a slave over
96:            //  the I2C data line. Takes in an unsigned 8bit integer variable 
97:            //  that that should be either a 0 when it is the last byte
98:            //  to be received or a 1 when there are still more bytes to
99:            //  be received. The received data is returned from the function
100:           //  as an unsigned 8bit integer.
101:           //
102:           // ************************************************************
103:           uint8_t i2c_read( uint8_t ack )
104:           {
105:               
106:               uint8_t readData;           //Variable for received data - CMH
107:               
108:               i2c_waitForIdle();          //Wait for Idle - CMH
109:               
110:               SSP2CON2bits.RCEN = 1;      //Enables data reception for a byte - CMH
111:               
112:               i2c_waitForIdle();          //Wait for Idle - CMH
113:               
114:               readData = SSP1BUF;         //Read in the data from the buffer - CMH
115:               
116:               i2c_waitForIdle();          //Wait for Idle - CMH
117:               
118:               //If the not last byte of data, then... else... - CMH
119:               if (ack){
120:                   SSP2CON2bits.ACKDT = 0; //Acknowledge low for more data - CMH
121:               }
122:               else{
123:                   SSP2CON2bits.ACKDT = 1; //Acknowledge high after final byte - CMH
124:               }
125:               
126:               SSP2CON2bits.ACKEN = 1;     //Send Acknowledge sequence - CMH
127:               
128:               return(readData);           //Return the received data - CMH
129:               
130:           }
131:           
132:           
133:           // ************************************************************
134:           //
135:           //  This function writes data to a slave device through the I2C
136:           //  data line. It takes in an unsigned 8bit integer value, waits
137:           //  for idle, then writes the value to the buffer. The function
138:           //  returns the current state of the acknowledge bit.
139:           //
140:           // ************************************************************
141:           uint8_t i2c_write( uint8_t i2cWriteData )
0004  00F1     MOVWF 0x1F1
142:           {
143:               //Wait for Idle - CMH
144:               i2c_waitForIdle();
0005  319C     MOVLP 0x1C
0006  24BF     CALL 0x4BF
145:               
146:               //Write to Buffer to start transmission - CMH
147:               SSP2BUF = i2cWriteData;
0007  0871     MOVF 0x1F1, W
0008  0023     MOVLB 0x3
0009  0096     MOVWF SSP2BUF
148:               
149:               //Returns 1 if transmission is acknowledged - CMH
150:               return(!SSP2CON2bits.ACKSTAT);
000A  081B     MOVF SSP2CON2, W
000B  0008     RETURN
151:               
152:           }
---  C:/Users/cmh52/Desktop/SeniorDesign.X/main.c  ------------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: main.c
8:              * 
9:              * Date Created: 1/14/19
10:             * 
11:             * Revision Date: 2/22/19
12:             * 
13:             * Revision: 0.25
14:             */
15:            
16:            #include "config.h"
17:            #include "serial_uart.h"
18:            #include "serial_i2c.h"
19:            #include "serial_spi.h"
20:            #include "lepton.h"
21:            #include "arducam.h"
22:            #include "eth_wiz.h"
23:            #include "gnss5.h"
24:            
25:            
26:            //Mission Stage Check variable. Will increment through different 
27:            //stages when signal received from ground station - CMH
28:            uint8_t mission_stage_check = 1; //CHANGE TO 0 for final program - CMH
29:            
30:            //Thermal Image Variables - CMH
31:            uint8_t packet_length = 164;    //Length of single VoSPI packet from FLIR - CMH
32:            uint8_t image_packet[164];      //Array for storage of VoSPI packet - CMH
33:            uint8_t num_of_packets = 60;    //Number of packets when telemetry disabled - CMH
34:            uint8_t packet_index = 60;      //Current index of received packets - CMH
35:            uint8_t discard = 0;            //Discard packet flag - CMH
36:            uint8_t num_discard = 0;
37:            
38:            //GPS location variables. Need to turn location variables into strings - CMH
39:            uint16_t GPS_location = 0;          //location of hotspots. To be an array - CMH
40:            uint16_t GPS_location_current = 0;  //Current location of drone - CMH
41:            uint16_t GPS_array_length = 0;      //Length of hotspot location array - CMH
42:            
43:            
44:            //Function Declarations - CMH
45:            void lepton_capture_packet(void);
46:            void lepton_send_packet(void);
47:            extern void delay(void);
48:            
49:            
50:            // ************************************************************
51:            //
52:            //  This function acts as the main function of the program.
53:            //  The consists of three main stages. The first stage is for
54:            //  initializing everything like the serial buses, the cameras,
55:            //  etc. The second stage is for thermal image collection from
56:            //  from the FLIR Lepton and GPS locations from the GNSS 5.
57:            //  The third and final stage is for getting hotspot locations
58:            //  from the ground station, comparing the current GPS location
59:            //  to the list of hotspot locations, and taking a visual image 
60:            //  with the Arducam if at one of the hotspot locations.
61:            //
62:            // ************************************************************
63:            int main(int argc, char** argv) 
64:            {  
65:                //Setup the oscillator - CMH
66:                OSCILLATOR_Initialize();
080B  3190     MOVLP 0x10
080C  2000     CALL 0x0
080D  3188     MOVLP 0x8
67:                
68:                //Run the first port pin initialization - CMH
69:                PORT_PIN_Initialize1();
080E  319D     MOVLP 0x1D
080F  2516     CALL 0x516
0810  3188     MOVLP 0x8
70:                
71:                //Initialize the I2C for camera setup - CMH
72:                i2c_initialize();
0811  319C     MOVLP 0x1C
0812  24A2     CALL 0x4A2
0813  3188     MOVLP 0x8
73:                
74:                //Initialize the Flir Lepton through the I2C - CMH
75:                lepton_initialize();
0814  3190     MOVLP 0x10
0815  2013     CALL 0x13
0816  3188     MOVLP 0x8
76:                
77:                //Initialize the Arducam through the I2C - CMH
78:                arducam_initialize();
0817  319C     MOVLP 0x1C
0818  247E     CALL 0x47E
0819  3188     MOVLP 0x8
79:                
80:                //Run the second Port Pin Initialization - CMH
81:                PORT_PIN_Initialize2();
081A  3180     MOVLP 0x0
081B  200C     CALL 0xC
081C  3188     MOVLP 0x8
82:                
83:                //Initialize the UART for use with the GNSS 5 - CMH
84:                UART_Initialize();
081D  3190     MOVLP 0x10
081E  2006     CALL 0x6
081F  3188     MOVLP 0x8
85:                
86:                //Initialize SPI for use with the ETH WIZ Click - CMH
87:                SPI_ETHWIZ_Initialize();
0820  319C     MOVLP 0x1C
0821  2492     CALL 0x492
0822  3188     MOVLP 0x8
88:                
89:                //Initialize SPI for use with the FLIR Lepton - CMH
90:                SPI_FLIR_Initialize();
0823  319C     MOVLP 0x1C
0824  249A     CALL 0x49A
0825  3188     MOVLP 0x8
91:               
92:                //Pull RST pins high to de-assert - CMH
93:                PORTDbits.RD2 = 1; //ETH WIZ
0826  0020     MOVLB 0x0
0827  150F     BSF PORTD, 0x2
94:                PORTDbits.RD0 = 1; //GNSS 5    
0828  140F     BSF PORTD, 0x0
95:                
96:                //De-assert all Slave Select(SS) for SPI - CMH
97:                PORTCbits.RC0 = 1;  //FLIR
0829  140E     BSF PORTC, 0x0
98:                PORTDbits.RD1 = 1;  //ARDUCAM
082A  148F     BSF PORTD, 0x1
99:                PORTDbits.RD3 = 1;  //ETH WIZ
082B  158F     BSF PORTD, 0x3
100:               
101:               //Toggle SS for Flir to reset - CMH
102:               __delay_ms(1000);
082C  3029     MOVLW 0x29
082D  0020     MOVLB 0x0
082E  00BF     MOVWF 0x3F
082F  3096     MOVLW 0x96
0830  00BE     MOVWF __pcstackBANK0
0831  307F     MOVLW 0x7F
0832  0B89     DECFSZ WREG, F
0833  2832     GOTO 0x32
0834  0BBE     DECFSZ __pcstackBANK0, F
0835  2832     GOTO 0x32
0836  0BBF     DECFSZ 0x3F, F
0837  2832     GOTO 0x32
103:               PORTCbits.RC0 = 0;
0838  0020     MOVLB 0x0
0839  100E     BCF PORTC, 0x0
104:               PORTCbits.RC0 = 1;
083A  140E     BSF PORTC, 0x0
105:               __delay_ms(500);
083B  3015     MOVLW 0x15
083C  0020     MOVLB 0x0
083D  00BF     MOVWF 0x3F
083E  304B     MOVLW 0x4B
083F  00BE     MOVWF __pcstackBANK0
0840  30BE     MOVLW 0xBE
0841  0B89     DECFSZ WREG, F
0842  2841     GOTO 0x41
0843  0BBE     DECFSZ __pcstackBANK0, F
0844  2841     GOTO 0x41
0845  0BBF     DECFSZ 0x3F, F
0846  2841     GOTO 0x41
0847  0000     NOP
106:               
107:               //Initialize the settings on the ETH WIZ - CMH
108:               eth_wiz_configure();
0848  3195     MOVLP 0x15
0849  25DB     CALL 0x5DB
084A  3188     MOVLP 0x8
109:               
110:               //Create the socket for the ETH WIZ - CMH
111:               eth_wiz_createSocket();
084B  3195     MOVLP 0x15
084C  250D     CALL 0x50D
084D  3188     MOVLP 0x8
112:               
113:               //Wait until the start signal is given - CMH
114:               while(mission_stage_check == 0) {
084E  0020     MOVLB 0x0
084F  083D     MOVF mission_stage_check, W
0850  1D03     BTFSS STATUS, 0x2
0851  2862     GOTO 0x62
0852  284E     GOTO 0x4E
115:                   //This will contain code that is constantly polling the
116:                   //ETH WIZ to see if the start signal has been received. - CMH
117:               }
118:               
119:                  
120:               //While still the thermal image stage - CMH
121:               while (mission_stage_check == 1)
0862  033D     DECF mission_stage_check, W
0863  1903     BTFSC STATUS, 0x2
0864  2853     GOTO 0x53
122:               {
123:                   packet_index = -1;
0853  30FF     MOVLW 0xFF
0854  00BE     MOVWF __pcstackBANK0
0855  083E     MOVF __pcstackBANK0, W
0856  00BA     MOVWF packet_index
124:                   do{
125:                       //Capture a packet from the FLIR - CMH
126:                       lepton_capture_packet();
0857  3191     MOVLP 0x11
0858  2197     CALL 0x197
0859  3188     MOVLP 0x8
127:                       
128:                       //Send the packet from FLIR - CMH
129:                       lepton_send_packet();
085A  319D     MOVLP 0x1D
085B  25DF     CALL 0x5DF
085C  3188     MOVLP 0x8
130:                       
131:                   }while(packet_index < 59);
085D  303B     MOVLW 0x3B
085E  0020     MOVLB 0x0
085F  023A     SUBWF packet_index, W
0860  1C03     BTFSS STATUS, 0x0
0861  2857     GOTO 0x57
132:                   
133:                   //Acquire current GPS location - CMH
134:                   //gnss5_acquire();
135:                   
136:                   //Send GPS location over ETH WIZ - CMH
137:                   //ADD CODE HERE
138:                   
139:                   //Look to see if the Visual mission start signal was received - CMH
140:                   //ADD CODE HERE
141:                   
142:               }
143:               
144:               //Set up SPI bus to work with the Arducam - CMH
145:               SPI_Arducam_Initialize();
0865  319C     MOVLP 0x1C
0866  248A     CALL 0x48A
0867  3188     MOVLP 0x8
146:               
147:               
148:               //Runs the visual image collection stage - CMH
149:               while (mission_stage_check == 2){
0868  3002     MOVLW 0x2
0869  0020     MOVLB 0x0
086A  063D     XORWF mission_stage_check, W
086B  1D03     BTFSS STATUS, 0x2
086C  2880     GOTO 0x80
150:                   
151:                   //Get the current GPS location - CMH
152:                   gnss5_acquire();
086D  319C     MOVLP 0x1C
086E  247F     CALL 0x47F
086F  3188     MOVLP 0x8
153:                   
154:                   //Check to see if any of the hotspot locations match the current - CMH
155:                   for(int i = 0; i == GPS_array_length; i++){
0870  0020     MOVLB 0x0
0871  01C0     CLRF i
0872  01C1     CLRF 0x41
156:                       //will need to add some tolerances
157:                       if (GPS_location_current == GPS_location){
158:                           
159:                           //Take visual image with Arducam and send over ETH WIZ - CMH
160:                           //ADD CODE HERE
161:                           
162:                       }
163:                   }
0873  0821     MOVF 0x21, W
0874  0641     XORWF 0x41, W
0875  1D03     BTFSS STATUS, 0x2
0876  2879     GOTO 0x79
0877  0820     MOVF GPS_array_length, W
0878  0640     XORWF i, W
0879  1D03     BTFSS STATUS, 0x2
087A  2868     GOTO 0x68
087B  3001     MOVLW 0x1
087C  07C0     ADDWF i, F
087D  3000     MOVLW 0x0
087E  3DC1     ADDWFC 0x41, F
087F  2873     GOTO 0x73
164:                   
165:               }
166:               
167:               //Infinite loop to end the program - CMH
168:               while(1) continue;
0880  2880     GOTO 0x80
169:           }
170:           
171:           
172:           // ************************************************************
173:           //
174:           //  This function sends a packet of thermal data through
175:           //  the ETH WIZ using the SPI Write function for the ETH WIZ.
176:           //
177:           // ************************************************************
178:           void lepton_send_packet(void){
179:               uint8_t junk = 0;
1DDF  01F9     CLRF junk
180:               //start transmission
181:               eth_wiz_transmit_start();
1DE0  319C     MOVLP 0x1C
182:               
183:               //These four lines below are the write/read sequencence for the SPI on
184:               //the ETH WIZ. It had to be done with these all in a row because the
185:               //XC8 compiler for the PIC does not generate optimized code so
186:               //the program wouldn't run fast enough to get the full image until
187:               //I wrote in this way - CMH
188:               SSP2BUF = image_packet[0];             
1DE3  304C     MOVLW 0x4C
189:               delay();
1DEA  319C     MOVLP 0x1C
190:               image_packet[0] = 0;
1DED  304C     MOVLW 0x4C
191:               SSP2IF = 0;
1DF3  002E     MOVLB 0xE
192:               junk = SSP2BUF;
1DF5  0023     MOVLB 0x3
193:               SSP2BUF = image_packet[1];             
1DFA  304C     MOVLW 0x4C
194:               delay();
1E01  319C     MOVLP 0x1C
195:               image_packet[1] = 0;
1E04  304C     MOVLW 0x4C
196:               SSP2IF = 0;
1E0A  002E     MOVLB 0xE
197:               junk = SSP2BUF;
1E0C  0023     MOVLB 0x3
198:               SSP2BUF = image_packet[2];             
1E11  304C     MOVLW 0x4C
199:               delay();
1E18  319C     MOVLP 0x1C
200:               image_packet[2] = 0;
1E1B  304C     MOVLW 0x4C
201:               SSP2IF = 0;
1E21  002E     MOVLB 0xE
202:               junk = SSP2BUF;
1E23  0023     MOVLB 0x3
203:               SSP2BUF = image_packet[3];             
1E28  304C     MOVLW 0x4C
204:               delay();
1E2F  319C     MOVLP 0x1C
205:               image_packet[3] = 0;
1E32  304C     MOVLW 0x4C
206:               SSP2IF = 0;
1E38  002E     MOVLB 0xE
207:               junk = SSP2BUF;
1E3A  0023     MOVLB 0x3
208:               SSP2BUF = image_packet[4];             
1E3F  304C     MOVLW 0x4C
209:               delay();
1E46  319C     MOVLP 0x1C
210:               image_packet[4] = 0;
1E49  304C     MOVLW 0x4C
211:               SSP2IF = 0;
1E4F  002E     MOVLB 0xE
212:               junk = SSP2BUF;
1E51  0023     MOVLB 0x3
213:               SSP2BUF = image_packet[5];             
1E56  304C     MOVLW 0x4C
214:               delay();
1E5D  319C     MOVLP 0x1C
215:               image_packet[5] = 0;
110B  0086     MOVWF 0x186
1E60  304C     MOVLW 0x4C
216:               SSP2IF = 0;
1110  002E     MOVLB 0xE
217:               junk = SSP2BUF;
1112  0023     MOVLB 0x3
218:               SSP2BUF = image_packet[6];             
1117  304C     MOVLW 0x4C
219:               delay();
111E  319C     MOVLP 0x1C
220:               image_packet[6] = 0;
1121  304C     MOVLW 0x4C
221:               SSP2IF = 0;
1127  002E     MOVLB 0xE
222:               junk = SSP2BUF;
1129  0023     MOVLB 0x3
223:               SSP2BUF = image_packet[7];             
112E  304C     MOVLW 0x4C
224:               delay();
1135  319C     MOVLP 0x1C
225:               image_packet[7] = 0;
1138  304C     MOVLW 0x4C
226:               SSP2IF = 0;
113E  002E     MOVLB 0xE
227:               junk = SSP2BUF;
1140  0023     MOVLB 0x3
228:               SSP2BUF = image_packet[8];             
1145  304C     MOVLW 0x4C
229:               delay();
114C  319C     MOVLP 0x1C
230:               image_packet[8] = 0;
114F  304C     MOVLW 0x4C
231:               SSP2IF = 0;
1155  002E     MOVLB 0xE
232:               junk = SSP2BUF;
1157  0023     MOVLB 0x3
233:               SSP2BUF = image_packet[9];             
115C  304C     MOVLW 0x4C
234:               delay();
1163  319C     MOVLP 0x1C
235:               image_packet[9] = 0;
1166  304C     MOVLW 0x4C
236:               SSP2IF = 0;
116C  002E     MOVLB 0xE
237:               junk = SSP2BUF;
116E  0023     MOVLB 0x3
238:               SSP2BUF = image_packet[10];             
1173  304C     MOVLW 0x4C
239:               delay();
117A  319C     MOVLP 0x1C
240:               image_packet[10] = 0;
117D  304C     MOVLW 0x4C
241:               SSP2IF = 0;
1183  002E     MOVLB 0xE
242:               junk = SSP2BUF;
1185  0023     MOVLB 0x3
243:               SSP2BUF = image_packet[11];             
118A  304C     MOVLW 0x4C
244:               delay();
1191  319C     MOVLP 0x1C
245:               image_packet[11] = 0;
107F  0086     MOVWF 0x186
1194  304C     MOVLW 0x4C
246:               SSP2IF = 0;
1084  002E     MOVLB 0xE
247:               junk = SSP2BUF;
1086  0023     MOVLB 0x3
248:               SSP2BUF = image_packet[12];             
108B  304C     MOVLW 0x4C
249:               delay();
1092  319C     MOVLP 0x1C
250:               image_packet[12] = 0;
1095  304C     MOVLW 0x4C
251:               SSP2IF = 0;
109B  002E     MOVLB 0xE
252:               junk = SSP2BUF;
109D  0023     MOVLB 0x3
253:               SSP2BUF = image_packet[13];             
10A2  304C     MOVLW 0x4C
254:               delay();
10A9  319C     MOVLP 0x1C
255:               image_packet[13] = 0;
10AC  304C     MOVLW 0x4C
256:               SSP2IF = 0;
10B2  002E     MOVLB 0xE
257:               junk = SSP2BUF;
10B4  0023     MOVLB 0x3
258:               SSP2BUF = image_packet[14];             
10B9  304C     MOVLW 0x4C
259:               delay();
10C0  319C     MOVLP 0x1C
260:               image_packet[14] = 0;
10C3  304C     MOVLW 0x4C
261:               SSP2IF = 0;
10C9  002E     MOVLB 0xE
262:               junk = SSP2BUF;
10CB  0023     MOVLB 0x3
263:               SSP2BUF = image_packet[15];             
10D0  304C     MOVLW 0x4C
264:               delay();
10D7  319C     MOVLP 0x1C
265:               image_packet[15] = 0;
10DA  304C     MOVLW 0x4C
266:               SSP2IF = 0;
10E0  002E     MOVLB 0xE
267:               junk = SSP2BUF;
10E2  0023     MOVLB 0x3
268:               SSP2BUF = image_packet[16];             
10E7  304C     MOVLW 0x4C
269:               delay();
10EE  319C     MOVLP 0x1C
270:               image_packet[16] = 0;
10F1  304C     MOVLW 0x4C
271:               SSP2IF = 0;
10F7  002E     MOVLB 0xE
272:               junk = SSP2BUF;
10F9  0023     MOVLB 0x3
273:               SSP2BUF = image_packet[17];             
10FE  304C     MOVLW 0x4C
274:               delay();
1105  319C     MOVLP 0x1C
275:               image_packet[17] = 0;
1108  304C     MOVLW 0x4C
1F74  0086     MOVWF 0x186
276:               SSP2IF = 0;
1F79  002E     MOVLB 0xE
277:               junk = SSP2BUF;
1F7B  0023     MOVLB 0x3
278:               SSP2BUF = image_packet[18];             
1F80  304C     MOVLW 0x4C
279:               delay();
1F87  319C     MOVLP 0x1C
280:               image_packet[18] = 0;
1F8A  304C     MOVLW 0x4C
281:               SSP2IF = 0;
1F90  002E     MOVLB 0xE
282:               junk = SSP2BUF;
1F92  0023     MOVLB 0x3
283:               SSP2BUF = image_packet[19];             
1F97  304C     MOVLW 0x4C
284:               delay();
1F9E  319C     MOVLP 0x1C
285:               image_packet[19] = 0;
1FA1  304C     MOVLW 0x4C
286:               SSP2IF = 0;
1FA7  002E     MOVLB 0xE
287:               junk = SSP2BUF;
1FA9  0023     MOVLB 0x3
288:               SSP2BUF = image_packet[20];             
1FAE  304C     MOVLW 0x4C
289:               delay();
1FB5  319C     MOVLP 0x1C
290:               image_packet[20] = 0;
1FB8  304C     MOVLW 0x4C
291:               SSP2IF = 0;
1FBE  002E     MOVLB 0xE
292:               junk = SSP2BUF;
1FC0  0023     MOVLB 0x3
293:               SSP2BUF = image_packet[21];             
1FC5  304C     MOVLW 0x4C
294:               delay();
1FCC  319C     MOVLP 0x1C
295:               image_packet[21] = 0;
1FCF  304C     MOVLW 0x4C
296:               SSP2IF = 0;
1FD5  002E     MOVLB 0xE
297:               junk = SSP2BUF;
1FD7  0023     MOVLB 0x3
298:               SSP2BUF = image_packet[22];             
1FDC  304C     MOVLW 0x4C
299:               delay();
1FE3  319C     MOVLP 0x1C
300:               image_packet[22] = 0;
1FE6  304C     MOVLW 0x4C
301:               SSP2IF = 0;
1FEC  002E     MOVLB 0xE
302:               junk = SSP2BUF;
1FEE  0023     MOVLB 0x3
303:               SSP2BUF = image_packet[23];             
1FF3  304C     MOVLW 0x4C
304:               delay();
1FFA  319C     MOVLP 0x1C
305:               image_packet[23] = 0;
1FFD  304C     MOVLW 0x4C
306:               SSP2IF = 0;
1EED  002E     MOVLB 0xE
307:               junk = SSP2BUF;
1EEF  0023     MOVLB 0x3
308:               SSP2BUF = image_packet[24];             
1EF4  304C     MOVLW 0x4C
309:               delay();
1EFB  319C     MOVLP 0x1C
310:               image_packet[24] = 0;
1EFE  304C     MOVLW 0x4C
311:               SSP2IF = 0;
1F04  002E     MOVLB 0xE
312:               junk = SSP2BUF;
1F06  0023     MOVLB 0x3
313:               SSP2BUF = image_packet[25];             
1F0B  304C     MOVLW 0x4C
314:               delay();
1F12  319C     MOVLP 0x1C
315:               image_packet[25] = 0;
1F15  304C     MOVLW 0x4C
316:               SSP2IF = 0;
1F1B  002E     MOVLB 0xE
317:               junk = SSP2BUF;
1F1D  0023     MOVLB 0x3
318:               SSP2BUF = image_packet[26];             
1F22  304C     MOVLW 0x4C
319:               delay();
1F29  319C     MOVLP 0x1C
320:               image_packet[26] = 0;
1F2C  304C     MOVLW 0x4C
321:               SSP2IF = 0;
1F32  002E     MOVLB 0xE
322:               junk = SSP2BUF;
1F34  0023     MOVLB 0x3
323:               SSP2BUF = image_packet[27];             
1F39  304C     MOVLW 0x4C
324:               delay();
1F40  319C     MOVLP 0x1C
325:               image_packet[27] = 0;
1F43  304C     MOVLW 0x4C
326:               SSP2IF = 0;
1F49  002E     MOVLB 0xE
327:               junk = SSP2BUF;
1F4B  0023     MOVLB 0x3
328:               SSP2BUF = image_packet[28];             
1F50  304C     MOVLW 0x4C
329:               delay();
1F57  319C     MOVLP 0x1C
330:               image_packet[28] = 0;
1F5A  304C     MOVLW 0x4C
331:               SSP2IF = 0;
1F60  002E     MOVLB 0xE
332:               junk = SSP2BUF;
1F62  0023     MOVLB 0x3
333:               SSP2BUF = image_packet[29];             
1F67  304C     MOVLW 0x4C
334:               delay();
1F6E  319C     MOVLP 0x1C
335:               image_packet[29] = 0;
1F71  304C     MOVLW 0x4C
336:               SSP2IF = 0;
1E68  002E     MOVLB 0xE
337:               junk = SSP2BUF;
1E6A  0023     MOVLB 0x3
338:               SSP2BUF = image_packet[30];             
1E6F  304C     MOVLW 0x4C
339:               delay();
1E76  319C     MOVLP 0x1C
340:               image_packet[30] = 0;
1E79  304C     MOVLW 0x4C
341:               SSP2IF = 0;
1E7F  002E     MOVLB 0xE
342:               junk = SSP2BUF;
1E81  0023     MOVLB 0x3
343:               SSP2BUF = image_packet[31];             
1E86  304C     MOVLW 0x4C
344:               delay();
1E8D  319C     MOVLP 0x1C
345:               image_packet[31] = 0;
1E90  304C     MOVLW 0x4C
346:               SSP2IF = 0;
1E96  002E     MOVLB 0xE
347:               junk = SSP2BUF;
1E98  0023     MOVLB 0x3
348:               SSP2BUF = image_packet[32];             
1E9D  306C     MOVLW 0x6C
349:               delay();
1EA3  319C     MOVLP 0x1C
350:               image_packet[32] = 0;
1EA6  306C     MOVLW 0x6C
351:               SSP2IF = 0;
1EAB  002E     MOVLB 0xE
352:               junk = SSP2BUF;
1EAD  0023     MOVLB 0x3
353:               SSP2BUF = image_packet[33];             
1EB2  306D     MOVLW 0x6D
354:               delay();
1EB8  319C     MOVLP 0x1C
355:               image_packet[33] = 0;
1EBB  306D     MOVLW 0x6D
356:               SSP2IF = 0;
1EC0  002E     MOVLB 0xE
357:               junk = SSP2BUF;
1EC2  0023     MOVLB 0x3
358:               SSP2BUF = image_packet[34];             
1EC7  306E     MOVLW 0x6E
359:               delay();
1ECD  319C     MOVLP 0x1C
360:               image_packet[34] = 0;
1ED0  306E     MOVLW 0x6E
361:               SSP2IF = 0;
1ED5  002E     MOVLB 0xE
362:               junk = SSP2BUF;
1ED7  0023     MOVLB 0x3
363:               SSP2BUF = image_packet[35];             
1EDC  306F     MOVLW 0x6F
364:               delay();
1EE2  319C     MOVLP 0x1C
365:               image_packet[35] = 0;
1EE5  306F     MOVLW 0x6F
366:               SSP2IF = 0;
147C  002E     MOVLB 0xE
367:               junk = SSP2BUF;
147E  0023     MOVLB 0x3
368:               SSP2BUF = image_packet[36];             
1483  3070     MOVLW 0x70
369:               delay();
1489  319C     MOVLP 0x1C
370:               image_packet[36] = 0;
148C  3070     MOVLW 0x70
371:               SSP2IF = 0;
1491  002E     MOVLB 0xE
372:               junk = SSP2BUF;
1493  0023     MOVLB 0x3
373:               SSP2BUF = image_packet[37];             
1498  3071     MOVLW 0x71
374:               delay();
149E  319C     MOVLP 0x1C
375:               image_packet[37] = 0;
14A1  3071     MOVLW 0x71
376:               SSP2IF = 0;
14A6  002E     MOVLB 0xE
377:               junk = SSP2BUF;
14A8  0023     MOVLB 0x3
378:               SSP2BUF = image_packet[38];             
14AD  3072     MOVLW 0x72
379:               delay();
14B3  319C     MOVLP 0x1C
380:               image_packet[38] = 0;
14B6  3072     MOVLW 0x72
381:               SSP2IF = 0;
14BB  002E     MOVLB 0xE
382:               junk = SSP2BUF;
14BD  0023     MOVLB 0x3
383:               SSP2BUF = image_packet[39];             
14C2  3073     MOVLW 0x73
384:               delay();
14C8  319C     MOVLP 0x1C
385:               image_packet[39] = 0;
14CB  3073     MOVLW 0x73
386:               SSP2IF = 0;
14D0  002E     MOVLB 0xE
387:               junk = SSP2BUF;
14D2  0023     MOVLB 0x3
388:               SSP2BUF = image_packet[40];             
14D7  3074     MOVLW 0x74
389:               delay();
14DD  319C     MOVLP 0x1C
390:               image_packet[40] = 0;
14E0  3074     MOVLW 0x74
391:               SSP2IF = 0;
14E5  002E     MOVLB 0xE
392:               junk = SSP2BUF;
14E7  0023     MOVLB 0x3
393:               SSP2BUF = image_packet[41];             
14EC  3075     MOVLW 0x75
394:               delay();
14F2  319C     MOVLP 0x1C
395:               image_packet[41] = 0;
14F5  3075     MOVLW 0x75
396:               SSP2IF = 0;
14FA  002E     MOVLB 0xE
397:               junk = SSP2BUF;
14FC  0023     MOVLB 0x3
398:               SSP2BUF = image_packet[42];             
1501  3076     MOVLW 0x76
399:               delay();
1507  319C     MOVLP 0x1C
400:               image_packet[42] = 0;
150A  3076     MOVLW 0x76
401:               SSP2IF = 0;
13E7  002E     MOVLB 0xE
402:               junk = SSP2BUF;
13E9  0023     MOVLB 0x3
403:               SSP2BUF = image_packet[43];             
13EE  3077     MOVLW 0x77
404:               delay();
13F4  319C     MOVLP 0x1C
405:               image_packet[43] = 0;
13F7  3077     MOVLW 0x77
406:               SSP2IF = 0;
13FC  002E     MOVLB 0xE
407:               junk = SSP2BUF;
13FE  0023     MOVLB 0x3
408:               SSP2BUF = image_packet[44];             
1403  3078     MOVLW 0x78
409:               delay();
1409  319C     MOVLP 0x1C
410:               image_packet[44] = 0;
140C  3078     MOVLW 0x78
411:               SSP2IF = 0;
1411  002E     MOVLB 0xE
412:               junk = SSP2BUF;
1413  0023     MOVLB 0x3
413:               SSP2BUF = image_packet[45];             
1418  3079     MOVLW 0x79
414:               delay();
141E  319C     MOVLP 0x1C
415:               image_packet[45] = 0;
1421  3079     MOVLW 0x79
416:               SSP2IF = 0;
1426  002E     MOVLB 0xE
417:               junk = SSP2BUF;
1428  0023     MOVLB 0x3
418:               SSP2BUF = image_packet[46];             
142D  307A     MOVLW 0x7A
419:               delay();
1433  319C     MOVLP 0x1C
420:               image_packet[46] = 0;
1436  307A     MOVLW 0x7A
421:               SSP2IF = 0;
143B  002E     MOVLB 0xE
422:               junk = SSP2BUF;
143D  0023     MOVLB 0x3
423:               SSP2BUF = image_packet[47];             
1442  307B     MOVLW 0x7B
424:               delay();
1448  319C     MOVLP 0x1C
425:               image_packet[47] = 0;
144B  307B     MOVLW 0x7B
426:               SSP2IF = 0;
1450  002E     MOVLB 0xE
427:               junk = SSP2BUF;
1452  0023     MOVLB 0x3
428:               SSP2BUF = image_packet[48];             
1457  307C     MOVLW 0x7C
429:               delay();
145D  319C     MOVLP 0x1C
430:               image_packet[48] = 0;
1460  307C     MOVLW 0x7C
431:               SSP2IF = 0;
1465  002E     MOVLB 0xE
432:               junk = SSP2BUF;
1467  0023     MOVLB 0x3
433:               SSP2BUF = image_packet[49];             
146C  307D     MOVLW 0x7D
434:               delay();
1472  319C     MOVLP 0x1C
435:               image_packet[49] = 0;
1475  307D     MOVLW 0x7D
436:               SSP2IF = 0;
1352  002E     MOVLB 0xE
437:               junk = SSP2BUF;
1354  0023     MOVLB 0x3
438:               SSP2BUF = image_packet[50];             
1359  307E     MOVLW 0x7E
439:               delay();
135F  319C     MOVLP 0x1C
440:               image_packet[50] = 0;
1362  307E     MOVLW 0x7E
441:               SSP2IF = 0;
1367  002E     MOVLB 0xE
442:               junk = SSP2BUF;
1369  0023     MOVLB 0x3
443:               SSP2BUF = image_packet[51];             
136E  307F     MOVLW 0x7F
444:               delay();
1374  319C     MOVLP 0x1C
445:               image_packet[51] = 0;
1377  307F     MOVLW 0x7F
446:               SSP2IF = 0;
137C  002E     MOVLB 0xE
447:               junk = SSP2BUF;
137E  0023     MOVLB 0x3
448:               SSP2BUF = image_packet[52];             
1383  3080     MOVLW 0x80
449:               delay();
1389  319C     MOVLP 0x1C
450:               image_packet[52] = 0;
138C  3080     MOVLW 0x80
451:               SSP2IF = 0;
1391  002E     MOVLB 0xE
452:               junk = SSP2BUF;
1393  0023     MOVLB 0x3
453:               SSP2BUF = image_packet[53];             
1398  3081     MOVLW 0x81
454:               delay();
139E  319C     MOVLP 0x1C
455:               image_packet[53] = 0;
13A1  3081     MOVLW 0x81
456:               SSP2IF = 0;
13A6  002E     MOVLB 0xE
457:               junk = SSP2BUF;
13A8  0023     MOVLB 0x3
458:               SSP2BUF = image_packet[54];             
13AD  3082     MOVLW 0x82
459:               delay();
13B3  319C     MOVLP 0x1C
460:               image_packet[54] = 0;
13B6  3082     MOVLW 0x82
461:               SSP2IF = 0;
13BB  002E     MOVLB 0xE
462:               junk = SSP2BUF;
13BD  0023     MOVLB 0x3
463:               SSP2BUF = image_packet[55];             
13C2  3083     MOVLW 0x83
464:               delay();
13C8  319C     MOVLP 0x1C
465:               image_packet[55] = 0;
13CB  3083     MOVLW 0x83
466:               SSP2IF = 0;
13D0  002E     MOVLB 0xE
467:               junk = SSP2BUF;
13D2  0023     MOVLB 0x3
468:               SSP2BUF = image_packet[56];             
13D7  3084     MOVLW 0x84
469:               delay();
13DD  319C     MOVLP 0x1C
470:               image_packet[56] = 0;
13E0  3084     MOVLW 0x84
471:               SSP2IF = 0;
12BD  002E     MOVLB 0xE
472:               junk = SSP2BUF;
12BF  0023     MOVLB 0x3
473:               SSP2BUF = image_packet[57];             
12C4  3085     MOVLW 0x85
474:               delay();
12CA  319C     MOVLP 0x1C
475:               image_packet[57] = 0;
12CD  3085     MOVLW 0x85
476:               SSP2IF = 0;
12D2  002E     MOVLB 0xE
477:               junk = SSP2BUF;
12D4  0023     MOVLB 0x3
478:               SSP2BUF = image_packet[58];             
12D9  3086     MOVLW 0x86
479:               delay();
12DF  319C     MOVLP 0x1C
480:               image_packet[58] = 0;
12E2  3086     MOVLW 0x86
481:               SSP2IF = 0;
12E7  002E     MOVLB 0xE
482:               junk = SSP2BUF;
12E9  0023     MOVLB 0x3
483:               SSP2BUF = image_packet[59];             
12EE  3087     MOVLW 0x87
484:               delay();
12F4  319C     MOVLP 0x1C
485:               image_packet[59] = 0;
12F7  3087     MOVLW 0x87
486:               SSP2IF = 0;
12FC  002E     MOVLB 0xE
487:               junk = SSP2BUF;
12FE  0023     MOVLB 0x3
488:               SSP2BUF = image_packet[60];             
1303  3088     MOVLW 0x88
489:               delay();
1309  319C     MOVLP 0x1C
490:               image_packet[60] = 0;
130C  3088     MOVLW 0x88
491:               SSP2IF = 0;
1311  002E     MOVLB 0xE
492:               junk = SSP2BUF;
1313  0023     MOVLB 0x3
493:               SSP2BUF = image_packet[61];             
1318  3089     MOVLW 0x89
494:               delay();
131E  319C     MOVLP 0x1C
495:               image_packet[61] = 0;
1321  3089     MOVLW 0x89
496:               SSP2IF = 0;
1326  002E     MOVLB 0xE
497:               junk = SSP2BUF;
1328  0023     MOVLB 0x3
498:               SSP2BUF = image_packet[62];             
132D  308A     MOVLW 0x8A
499:               delay();
1333  319C     MOVLP 0x1C
500:               image_packet[62] = 0;
1336  308A     MOVLW 0x8A
501:               SSP2IF = 0;
133B  002E     MOVLB 0xE
502:               junk = SSP2BUF;
133D  0023     MOVLB 0x3
503:               SSP2BUF = image_packet[63];             
1342  308B     MOVLW 0x8B
504:               delay();
1348  319C     MOVLP 0x1C
505:               image_packet[63] = 0;
134B  308B     MOVLW 0x8B
506:               SSP2IF = 0;
1228  002E     MOVLB 0xE
507:               junk = SSP2BUF;
122A  0023     MOVLB 0x3
508:               SSP2BUF = image_packet[64];             
122F  308C     MOVLW 0x8C
509:               delay();
1235  319C     MOVLP 0x1C
510:               image_packet[64] = 0;
1238  308C     MOVLW 0x8C
511:               SSP2IF = 0;
123D  002E     MOVLB 0xE
512:               junk = SSP2BUF;
123F  0023     MOVLB 0x3
513:               SSP2BUF = image_packet[65];             
1244  308D     MOVLW 0x8D
514:               delay();
124A  319C     MOVLP 0x1C
515:               image_packet[65] = 0;
124D  308D     MOVLW 0x8D
516:               SSP2IF = 0;
1252  002E     MOVLB 0xE
517:               junk = SSP2BUF;
1254  0023     MOVLB 0x3
518:               SSP2BUF = image_packet[66];             
1259  308E     MOVLW 0x8E
519:               delay();
125F  319C     MOVLP 0x1C
520:               image_packet[66] = 0;
1262  308E     MOVLW 0x8E
521:               SSP2IF = 0;
1267  002E     MOVLB 0xE
522:               junk = SSP2BUF;
1269  0023     MOVLB 0x3
523:               SSP2BUF = image_packet[67];             
126E  308F     MOVLW 0x8F
524:               delay();
1274  319C     MOVLP 0x1C
525:               image_packet[67] = 0;
1277  308F     MOVLW 0x8F
526:               SSP2IF = 0;
127C  002E     MOVLB 0xE
527:               junk = SSP2BUF;
127E  0023     MOVLB 0x3
528:               SSP2BUF = image_packet[68];             
1283  3090     MOVLW 0x90
529:               delay();
1289  319C     MOVLP 0x1C
530:               image_packet[68] = 0;
128C  3090     MOVLW 0x90
531:               SSP2IF = 0;
1291  002E     MOVLB 0xE
532:               junk = SSP2BUF;
1293  0023     MOVLB 0x3
533:               SSP2BUF = image_packet[69];             
1298  3091     MOVLW 0x91
534:               delay();
129E  319C     MOVLP 0x1C
535:               image_packet[69] = 0;
12A1  3091     MOVLW 0x91
536:               SSP2IF = 0;
12A6  002E     MOVLB 0xE
537:               junk = SSP2BUF;
12A8  0023     MOVLB 0x3
538:               SSP2BUF = image_packet[70];             
12AD  3092     MOVLW 0x92
539:               delay();
12B3  319C     MOVLP 0x1C
540:               image_packet[70] = 0;
12B6  3092     MOVLW 0x92
541:               SSP2IF = 0;
002F  002E     MOVLB 0xE
542:               junk = SSP2BUF;
0031  0023     MOVLB 0x3
543:               SSP2BUF = image_packet[71];             
0036  3093     MOVLW 0x93
544:               delay();
003C  319C     MOVLP 0x1C
545:               image_packet[71] = 0;
003F  3093     MOVLW 0x93
546:               SSP2IF = 0;
0044  002E     MOVLB 0xE
547:               junk = SSP2BUF;
0046  0023     MOVLB 0x3
548:               SSP2BUF = image_packet[72];             
004B  3094     MOVLW 0x94
549:               delay();
0051  319C     MOVLP 0x1C
550:               image_packet[72] = 0;
0054  3094     MOVLW 0x94
551:               SSP2IF = 0;
0059  002E     MOVLB 0xE
552:               junk = SSP2BUF;
005B  0023     MOVLB 0x3
553:               SSP2BUF = image_packet[73];             
0060  3095     MOVLW 0x95
554:               delay();
0066  319C     MOVLP 0x1C
555:               image_packet[73] = 0;
0069  3095     MOVLW 0x95
556:               SSP2IF = 0;
006E  002E     MOVLB 0xE
557:               junk = SSP2BUF;
0070  0023     MOVLB 0x3
558:               SSP2BUF = image_packet[74];             
0075  3096     MOVLW 0x96
559:               delay();
007B  319C     MOVLP 0x1C
560:               image_packet[74] = 0;
007E  3096     MOVLW 0x96
561:               SSP2IF = 0;
0083  002E     MOVLB 0xE
562:               junk = SSP2BUF;
0085  0023     MOVLB 0x3
563:               SSP2BUF = image_packet[75];             
008A  3097     MOVLW 0x97
564:               delay();
0090  319C     MOVLP 0x1C
565:               image_packet[75] = 0;
0093  3097     MOVLW 0x97
566:               SSP2IF = 0;
0098  002E     MOVLB 0xE
567:               junk = SSP2BUF;
009A  0023     MOVLB 0x3
568:               SSP2BUF = image_packet[76];             
009F  3098     MOVLW 0x98
569:               delay();
00A5  319C     MOVLP 0x1C
570:               image_packet[76] = 0;
00A8  3098     MOVLW 0x98
571:               SSP2IF = 0;
00AD  002E     MOVLB 0xE
572:               junk = SSP2BUF;
00AF  0023     MOVLB 0x3
573:               SSP2BUF = image_packet[77];             
00B4  3099     MOVLW 0x99
574:               delay();
00BA  319C     MOVLP 0x1C
575:               image_packet[77] = 0;
00BD  3099     MOVLW 0x99
576:               SSP2IF = 0;
00C2  002E     MOVLB 0xE
577:               junk = SSP2BUF;
00C4  0023     MOVLB 0x3
578:               SSP2BUF = image_packet[78];             
00C9  309A     MOVLW 0x9A
579:               delay();
00CF  319C     MOVLP 0x1C
580:               image_packet[78] = 0;
00D2  309A     MOVLW 0x9A
581:               SSP2IF = 0;
00D7  002E     MOVLB 0xE
582:               junk = SSP2BUF;
00D9  0023     MOVLB 0x3
583:               SSP2BUF = image_packet[79];             
00DE  309B     MOVLW 0x9B
584:               delay();
00E4  319C     MOVLP 0x1C
585:               image_packet[79] = 0;
00E7  309B     MOVLW 0x9B
586:               SSP2IF = 0;
00EC  002E     MOVLB 0xE
587:               junk = SSP2BUF;
00EE  0023     MOVLB 0x3
588:               SSP2BUF = image_packet[80];             
00F3  309C     MOVLW 0x9C
589:               delay();
00F9  319C     MOVLP 0x1C
590:               image_packet[80] = 0;
00FC  309C     MOVLW 0x9C
591:               SSP2IF = 0;
0101  002E     MOVLB 0xE
592:               junk = SSP2BUF;
0103  0023     MOVLB 0x3
593:               SSP2BUF = image_packet[81];             
0108  309D     MOVLW 0x9D
594:               delay();
010E  319C     MOVLP 0x1C
595:               image_packet[81] = 0;
0111  309D     MOVLW 0x9D
596:               SSP2IF = 0;
0116  002E     MOVLB 0xE
597:               junk = SSP2BUF;
0118  0023     MOVLB 0x3
598:               SSP2BUF = image_packet[82];             
011D  309E     MOVLW 0x9E
599:               delay();
0123  319C     MOVLP 0x1C
600:               image_packet[82] = 0;
0126  309E     MOVLW 0x9E
601:               SSP2IF = 0;
012B  002E     MOVLB 0xE
602:               junk = SSP2BUF;
012D  0023     MOVLB 0x3
603:               SSP2BUF = image_packet[83];             
0132  309F     MOVLW 0x9F
604:               delay();
0138  319C     MOVLP 0x1C
605:               image_packet[83] = 0;
013B  309F     MOVLW 0x9F
606:               SSP2IF = 0;
0140  002E     MOVLB 0xE
607:               junk = SSP2BUF;
0142  0023     MOVLB 0x3
608:               SSP2BUF = image_packet[84];             
0147  30A0     MOVLW 0xA0
609:               delay();
014D  319C     MOVLP 0x1C
610:               image_packet[84] = 0;
0150  30A0     MOVLW 0xA0
611:               SSP2IF = 0;
0155  002E     MOVLB 0xE
612:               junk = SSP2BUF;
0157  0023     MOVLB 0x3
613:               SSP2BUF = image_packet[85];             
015C  30A1     MOVLW 0xA1
614:               delay();
0162  319C     MOVLP 0x1C
615:               image_packet[85] = 0;
0165  30A1     MOVLW 0xA1
616:               SSP2IF = 0;
016A  002E     MOVLB 0xE
617:               junk = SSP2BUF;
016C  0023     MOVLB 0x3
618:               SSP2BUF = image_packet[86];             
0171  30A2     MOVLW 0xA2
619:               delay();
0177  319C     MOVLP 0x1C
620:               image_packet[86] = 0;
017A  30A2     MOVLW 0xA2
621:               SSP2IF = 0;
017F  002E     MOVLB 0xE
622:               junk = SSP2BUF;
0181  0023     MOVLB 0x3
623:               SSP2BUF = image_packet[87];             
0186  30A3     MOVLW 0xA3
624:               delay();
018C  319C     MOVLP 0x1C
625:               image_packet[87] = 0;
018F  30A3     MOVLW 0xA3
626:               SSP2IF = 0;
0194  002E     MOVLB 0xE
627:               junk = SSP2BUF;
0196  0023     MOVLB 0x3
628:               SSP2BUF = image_packet[88];             
019B  30A4     MOVLW 0xA4
629:               delay();
01A1  319C     MOVLP 0x1C
630:               image_packet[88] = 0;
01A4  30A4     MOVLW 0xA4
631:               SSP2IF = 0;
01A9  002E     MOVLB 0xE
632:               junk = SSP2BUF;
01AB  0023     MOVLB 0x3
633:               SSP2BUF = image_packet[89];             
01B0  30A5     MOVLW 0xA5
634:               delay();
01B6  319C     MOVLP 0x1C
635:               image_packet[89] = 0;
01B9  30A5     MOVLW 0xA5
636:               SSP2IF = 0;
01BE  002E     MOVLB 0xE
637:               junk = SSP2BUF;
01C0  0023     MOVLB 0x3
638:               SSP2BUF = image_packet[90];             
01C5  30A6     MOVLW 0xA6
639:               delay();
01CB  319C     MOVLP 0x1C
640:               image_packet[90] = 0;
01CE  30A6     MOVLW 0xA6
641:               SSP2IF = 0;
01D3  002E     MOVLB 0xE
642:               junk = SSP2BUF;
01D5  0023     MOVLB 0x3
643:               SSP2BUF = image_packet[91];             
01DA  30A7     MOVLW 0xA7
644:               delay();
01E0  319C     MOVLP 0x1C
645:               image_packet[91] = 0;
01E3  30A7     MOVLW 0xA7
646:               SSP2IF = 0;
01E8  002E     MOVLB 0xE
647:               junk = SSP2BUF;
01EA  0023     MOVLB 0x3
648:               SSP2BUF = image_packet[92];             
01EF  30A8     MOVLW 0xA8
649:               delay();
01F5  319C     MOVLP 0x1C
650:               image_packet[92] = 0;
01F8  30A8     MOVLW 0xA8
651:               SSP2IF = 0;
01FD  002E     MOVLB 0xE
652:               junk = SSP2BUF;
01FF  0023     MOVLB 0x3
653:               SSP2BUF = image_packet[93];             
0204  30A9     MOVLW 0xA9
654:               delay();
020A  319C     MOVLP 0x1C
655:               image_packet[93] = 0;
020D  30A9     MOVLW 0xA9
656:               SSP2IF = 0;
0212  002E     MOVLB 0xE
657:               junk = SSP2BUF;
0214  0023     MOVLB 0x3
658:               SSP2BUF = image_packet[94];             
0219  30AA     MOVLW 0xAA
659:               delay();
021F  319C     MOVLP 0x1C
660:               image_packet[94] = 0;
0222  30AA     MOVLW 0xAA
661:               SSP2IF = 0;
0227  002E     MOVLB 0xE
662:               junk = SSP2BUF;
0229  0023     MOVLB 0x3
663:               SSP2BUF = image_packet[95];             
022E  30AB     MOVLW 0xAB
664:               delay();
0234  319C     MOVLP 0x1C
665:               image_packet[95] = 0;
0237  30AB     MOVLW 0xAB
666:               SSP2IF = 0;
023C  002E     MOVLB 0xE
667:               junk = SSP2BUF;
023E  0023     MOVLB 0x3
668:               SSP2BUF = image_packet[96];             
0243  30AC     MOVLW 0xAC
669:               delay();
0249  319C     MOVLP 0x1C
670:               image_packet[96] = 0;
024C  30AC     MOVLW 0xAC
671:               SSP2IF = 0;
0251  002E     MOVLB 0xE
672:               junk = SSP2BUF;
0253  0023     MOVLB 0x3
673:               SSP2BUF = image_packet[97];             
0258  30AD     MOVLW 0xAD
674:               delay();
025E  319C     MOVLP 0x1C
675:               image_packet[97] = 0;
0261  30AD     MOVLW 0xAD
676:               SSP2IF = 0;
0266  002E     MOVLB 0xE
677:               junk = SSP2BUF;
0268  0023     MOVLB 0x3
678:               SSP2BUF = image_packet[98];             
026D  30AE     MOVLW 0xAE
679:               delay();
0273  319C     MOVLP 0x1C
680:               image_packet[98] = 0;
0276  30AE     MOVLW 0xAE
681:               SSP2IF = 0;
027B  002E     MOVLB 0xE
682:               junk = SSP2BUF;
027D  0023     MOVLB 0x3
683:               SSP2BUF = image_packet[99];             
0282  30AF     MOVLW 0xAF
684:               delay();
0288  319C     MOVLP 0x1C
685:               image_packet[99] = 0;
028B  30AF     MOVLW 0xAF
686:               SSP2IF = 0;
0290  002E     MOVLB 0xE
687:               junk = SSP2BUF;
0292  0023     MOVLB 0x3
688:               SSP2BUF = image_packet[100];             
0297  30B0     MOVLW 0xB0
689:               delay();
029D  319C     MOVLP 0x1C
690:               image_packet[100] = 0;
02A0  30B0     MOVLW 0xB0
691:               SSP2IF = 0;
02A5  002E     MOVLB 0xE
692:               junk = SSP2BUF;
02A7  0023     MOVLB 0x3
693:               SSP2BUF = image_packet[101];             
02AC  30B1     MOVLW 0xB1
694:               delay();
02B2  319C     MOVLP 0x1C
695:               image_packet[101] = 0;
02B5  30B1     MOVLW 0xB1
696:               SSP2IF = 0;
02BA  002E     MOVLB 0xE
697:               junk = SSP2BUF;
02BC  0023     MOVLB 0x3
698:               SSP2BUF = image_packet[102];             
02C1  30B2     MOVLW 0xB2
699:               delay();
02C7  319C     MOVLP 0x1C
700:               image_packet[102] = 0;
02CA  30B2     MOVLW 0xB2
701:               SSP2IF = 0;
02CF  002E     MOVLB 0xE
702:               junk = SSP2BUF;
02D1  0023     MOVLB 0x3
703:               SSP2BUF = image_packet[103];             
02D6  30B3     MOVLW 0xB3
704:               delay();
02DC  319C     MOVLP 0x1C
705:               image_packet[103] = 0;
02DF  30B3     MOVLW 0xB3
706:               SSP2IF = 0;
02E4  002E     MOVLB 0xE
707:               junk = SSP2BUF;
02E6  0023     MOVLB 0x3
708:               SSP2BUF = image_packet[104];             
02EB  30B4     MOVLW 0xB4
709:               delay();
02F1  319C     MOVLP 0x1C
710:               image_packet[104] = 0;
02F4  30B4     MOVLW 0xB4
711:               SSP2IF = 0;
02F9  002E     MOVLB 0xE
712:               junk = SSP2BUF;
02FB  0023     MOVLB 0x3
713:               SSP2BUF = image_packet[105];             
0300  30B5     MOVLW 0xB5
714:               delay();
0306  319C     MOVLP 0x1C
715:               image_packet[105] = 0;
0309  30B5     MOVLW 0xB5
716:               SSP2IF = 0;
030E  002E     MOVLB 0xE
717:               junk = SSP2BUF;
0310  0023     MOVLB 0x3
718:               SSP2BUF = image_packet[106];             
0315  30B6     MOVLW 0xB6
719:               delay();
031B  319C     MOVLP 0x1C
720:               image_packet[106] = 0;
031E  30B6     MOVLW 0xB6
721:               SSP2IF = 0;
0323  002E     MOVLB 0xE
722:               junk = SSP2BUF;
0325  0023     MOVLB 0x3
723:               SSP2BUF = image_packet[107];             
032A  30B7     MOVLW 0xB7
724:               delay();
0330  319C     MOVLP 0x1C
725:               image_packet[107] = 0;
0333  30B7     MOVLW 0xB7
726:               SSP2IF = 0;
0338  002E     MOVLB 0xE
727:               junk = SSP2BUF;
033A  0023     MOVLB 0x3
728:               SSP2BUF = image_packet[108];             
033F  30B8     MOVLW 0xB8
729:               delay();
0345  319C     MOVLP 0x1C
730:               image_packet[108] = 0;
0348  30B8     MOVLW 0xB8
731:               SSP2IF = 0;
034D  002E     MOVLB 0xE
732:               junk = SSP2BUF;
034F  0023     MOVLB 0x3
733:               SSP2BUF = image_packet[109];             
0354  30B9     MOVLW 0xB9
734:               delay();
035A  319C     MOVLP 0x1C
735:               image_packet[109] = 0;
035D  30B9     MOVLW 0xB9
736:               SSP2IF = 0;
0362  002E     MOVLB 0xE
737:               junk = SSP2BUF;
0364  0023     MOVLB 0x3
738:               SSP2BUF = image_packet[110];             
0369  30BA     MOVLW 0xBA
739:               delay();
036F  319C     MOVLP 0x1C
740:               image_packet[110] = 0;
0372  30BA     MOVLW 0xBA
741:               SSP2IF = 0;
0377  002E     MOVLB 0xE
742:               junk = SSP2BUF;
0379  0023     MOVLB 0x3
743:               SSP2BUF = image_packet[111];             
037E  30BB     MOVLW 0xBB
744:               delay();
0384  319C     MOVLP 0x1C
745:               image_packet[111] = 0;
0387  30BB     MOVLW 0xBB
746:               SSP2IF = 0;
038C  002E     MOVLB 0xE
747:               junk = SSP2BUF;
038E  0023     MOVLB 0x3
748:               SSP2BUF = image_packet[112];             
0393  30BC     MOVLW 0xBC
749:               delay();
0399  319C     MOVLP 0x1C
750:               image_packet[112] = 0;
039C  30BC     MOVLW 0xBC
751:               SSP2IF = 0;
03A1  002E     MOVLB 0xE
752:               junk = SSP2BUF;
03A3  0023     MOVLB 0x3
753:               SSP2BUF = image_packet[113];             
03A8  30BD     MOVLW 0xBD
754:               delay();
03AE  319C     MOVLP 0x1C
755:               image_packet[113] = 0;
03B1  30BD     MOVLW 0xBD
756:               SSP2IF = 0;
03B6  002E     MOVLB 0xE
757:               junk = SSP2BUF;
03B8  0023     MOVLB 0x3
758:               SSP2BUF = image_packet[114];             
03BD  30BE     MOVLW 0xBE
759:               delay();
03C3  319C     MOVLP 0x1C
760:               image_packet[114] = 0;
03C6  30BE     MOVLW 0xBE
761:               SSP2IF = 0;
03CB  002E     MOVLB 0xE
762:               junk = SSP2BUF;
03CD  0023     MOVLB 0x3
763:               SSP2BUF = image_packet[115];             
03D2  30BF     MOVLW 0xBF
764:               delay();
03D8  319C     MOVLP 0x1C
765:               image_packet[115] = 0;
03DB  30BF     MOVLW 0xBF
766:               SSP2IF = 0;
03E0  002E     MOVLB 0xE
767:               junk = SSP2BUF;
03E2  0023     MOVLB 0x3
768:               SSP2BUF = image_packet[116];             
03E7  30C0     MOVLW 0xC0
769:               delay();
03ED  319C     MOVLP 0x1C
770:               image_packet[116] = 0;
03F0  30C0     MOVLW 0xC0
771:               SSP2IF = 0;
03F5  002E     MOVLB 0xE
772:               junk = SSP2BUF;
03F7  0023     MOVLB 0x3
773:               SSP2BUF = image_packet[117];             
03FC  30C1     MOVLW 0xC1
774:               delay();
0402  319C     MOVLP 0x1C
775:               image_packet[117] = 0;
0405  30C1     MOVLW 0xC1
776:               SSP2IF = 0;
040A  002E     MOVLB 0xE
777:               junk = SSP2BUF;
040C  0023     MOVLB 0x3
778:               SSP2BUF = image_packet[118];             
0411  30C2     MOVLW 0xC2
779:               delay();
0417  319C     MOVLP 0x1C
780:               image_packet[118] = 0;
041A  30C2     MOVLW 0xC2
781:               SSP2IF = 0;
041F  002E     MOVLB 0xE
782:               junk = SSP2BUF;
0421  0023     MOVLB 0x3
783:               SSP2BUF = image_packet[119];             
0426  30C3     MOVLW 0xC3
784:               delay();
042C  319C     MOVLP 0x1C
785:               image_packet[119] = 0;
042F  30C3     MOVLW 0xC3
786:               SSP2IF = 0;
0434  002E     MOVLB 0xE
787:               junk = SSP2BUF;
0436  0023     MOVLB 0x3
788:               SSP2BUF = image_packet[120];             
043B  30C4     MOVLW 0xC4
789:               delay();
0441  319C     MOVLP 0x1C
790:               image_packet[120] = 0;
0444  30C4     MOVLW 0xC4
791:               SSP2IF = 0;
0449  002E     MOVLB 0xE
792:               junk = SSP2BUF;
044B  0023     MOVLB 0x3
793:               SSP2BUF = image_packet[121];             
0450  30C5     MOVLW 0xC5
794:               delay();
0456  319C     MOVLP 0x1C
795:               image_packet[121] = 0;
0459  30C5     MOVLW 0xC5
796:               SSP2IF = 0;
045E  002E     MOVLB 0xE
797:               junk = SSP2BUF;
0460  0023     MOVLB 0x3
798:               SSP2BUF = image_packet[122];             
0465  30C6     MOVLW 0xC6
799:               delay();
046B  319C     MOVLP 0x1C
800:               image_packet[122] = 0;
046E  30C6     MOVLW 0xC6
801:               SSP2IF = 0;
0473  002E     MOVLB 0xE
802:               junk = SSP2BUF;
0475  0023     MOVLB 0x3
803:               SSP2BUF = image_packet[123];             
047A  30C7     MOVLW 0xC7
804:               delay();
0480  319C     MOVLP 0x1C
805:               image_packet[123] = 0;
0483  30C7     MOVLW 0xC7
806:               SSP2IF = 0;
0488  002E     MOVLB 0xE
807:               junk = SSP2BUF;
048A  0023     MOVLB 0x3
808:               SSP2BUF = image_packet[124];             
048F  30C8     MOVLW 0xC8
809:               delay();
0495  319C     MOVLP 0x1C
810:               image_packet[124] = 0;
0498  30C8     MOVLW 0xC8
811:               SSP2IF = 0;
049D  002E     MOVLB 0xE
812:               junk = SSP2BUF;
049F  0023     MOVLB 0x3
813:               SSP2BUF = image_packet[125];             
04A4  30C9     MOVLW 0xC9
814:               delay();
04AA  319C     MOVLP 0x1C
815:               image_packet[125] = 0;
04AD  30C9     MOVLW 0xC9
816:               SSP2IF = 0;
04B2  002E     MOVLB 0xE
817:               junk = SSP2BUF;
04B4  0023     MOVLB 0x3
818:               SSP2BUF = image_packet[126];             
04B9  30CA     MOVLW 0xCA
819:               delay();
04BF  319C     MOVLP 0x1C
820:               image_packet[126] = 0;
04C2  30CA     MOVLW 0xCA
821:               SSP2IF = 0;
04C7  002E     MOVLB 0xE
822:               junk = SSP2BUF;
04C9  0023     MOVLB 0x3
823:               SSP2BUF = image_packet[127];             
04CE  30CB     MOVLW 0xCB
824:               delay();
04D4  319C     MOVLP 0x1C
825:               image_packet[127] = 0;
04D7  30CB     MOVLW 0xCB
826:               SSP2IF = 0;
04DC  002E     MOVLB 0xE
827:               junk = SSP2BUF;
04DE  0023     MOVLB 0x3
828:               SSP2BUF = image_packet[128];             
04E3  30CC     MOVLW 0xCC
829:               delay();
04E9  319C     MOVLP 0x1C
830:               image_packet[128] = 0;
04EC  30CC     MOVLW 0xCC
831:               SSP2IF = 0;
04F1  002E     MOVLB 0xE
832:               junk = SSP2BUF;
04F3  0023     MOVLB 0x3
833:               SSP2BUF = image_packet[129];             
04F8  30CD     MOVLW 0xCD
834:               delay();
04FE  319C     MOVLP 0x1C
835:               image_packet[129] = 0;
0501  30CD     MOVLW 0xCD
836:               SSP2IF = 0;
0506  002E     MOVLB 0xE
837:               junk = SSP2BUF;
0508  0023     MOVLB 0x3
838:               SSP2BUF = image_packet[130];             
050D  30CE     MOVLW 0xCE
839:               delay();
0513  319C     MOVLP 0x1C
840:               image_packet[130] = 0;
0516  30CE     MOVLW 0xCE
841:               SSP2IF = 0;
051B  002E     MOVLB 0xE
842:               junk = SSP2BUF;
051D  0023     MOVLB 0x3
843:               SSP2BUF = image_packet[131];             
0522  30CF     MOVLW 0xCF
844:               delay();
0528  319C     MOVLP 0x1C
845:               image_packet[131] = 0;
052B  30CF     MOVLW 0xCF
846:               SSP2IF = 0;
0530  002E     MOVLB 0xE
847:               junk = SSP2BUF;
0532  0023     MOVLB 0x3
848:               SSP2BUF = image_packet[132];             
0537  30D0     MOVLW 0xD0
849:               delay();
053D  319C     MOVLP 0x1C
850:               image_packet[132] = 0;
0540  30D0     MOVLW 0xD0
851:               SSP2IF = 0;
0545  002E     MOVLB 0xE
852:               junk = SSP2BUF;
0547  0023     MOVLB 0x3
853:               SSP2BUF = image_packet[133];             
054C  30D1     MOVLW 0xD1
854:               delay();
0552  319C     MOVLP 0x1C
855:               image_packet[133] = 0;
0555  30D1     MOVLW 0xD1
856:               SSP2IF = 0;
055A  002E     MOVLB 0xE
857:               junk = SSP2BUF;
055C  0023     MOVLB 0x3
858:               SSP2BUF = image_packet[134];             
0561  30D2     MOVLW 0xD2
859:               delay();
0567  319C     MOVLP 0x1C
860:               image_packet[134] = 0;
056A  30D2     MOVLW 0xD2
861:               SSP2IF = 0;
056F  002E     MOVLB 0xE
862:               junk = SSP2BUF;
0571  0023     MOVLB 0x3
863:               SSP2BUF = image_packet[135];             
0576  30D3     MOVLW 0xD3
864:               delay();
057C  319C     MOVLP 0x1C
865:               image_packet[135] = 0;
057F  30D3     MOVLW 0xD3
866:               SSP2IF = 0;
0584  002E     MOVLB 0xE
867:               junk = SSP2BUF;
0586  0023     MOVLB 0x3
868:               SSP2BUF = image_packet[136];             
058B  30D4     MOVLW 0xD4
869:               delay();
0591  319C     MOVLP 0x1C
870:               image_packet[136] = 0;
0594  30D4     MOVLW 0xD4
871:               SSP2IF = 0;
0599  002E     MOVLB 0xE
872:               junk = SSP2BUF;
059B  0023     MOVLB 0x3
873:               SSP2BUF = image_packet[137];             
05A0  30D5     MOVLW 0xD5
874:               delay();
05A6  319C     MOVLP 0x1C
875:               image_packet[137] = 0;
05A9  30D5     MOVLW 0xD5
876:               SSP2IF = 0;
05AE  002E     MOVLB 0xE
877:               junk = SSP2BUF;
05B0  0023     MOVLB 0x3
878:               SSP2BUF = image_packet[138];             
05B5  30D6     MOVLW 0xD6
879:               delay();
05BB  319C     MOVLP 0x1C
880:               image_packet[138] = 0;
05BE  30D6     MOVLW 0xD6
881:               SSP2IF = 0;
05C3  002E     MOVLB 0xE
882:               junk = SSP2BUF;
05C5  0023     MOVLB 0x3
883:               SSP2BUF = image_packet[139];             
05CA  30D7     MOVLW 0xD7
884:               delay();
05D0  319C     MOVLP 0x1C
885:               image_packet[139] = 0;
05D3  30D7     MOVLW 0xD7
886:               SSP2IF = 0;
05D8  002E     MOVLB 0xE
887:               junk = SSP2BUF;
05DA  0023     MOVLB 0x3
888:               SSP2BUF = image_packet[140];             
05DF  30D8     MOVLW 0xD8
889:               delay();
05E5  319C     MOVLP 0x1C
890:               image_packet[140] = 0;
05E8  30D8     MOVLW 0xD8
891:               SSP2IF = 0;
05ED  002E     MOVLB 0xE
892:               junk = SSP2BUF;
05EF  0023     MOVLB 0x3
893:               SSP2BUF = image_packet[141];             
05F4  30D9     MOVLW 0xD9
894:               delay();
05FA  319C     MOVLP 0x1C
895:               image_packet[141] = 0;
05FD  30D9     MOVLW 0xD9
896:               SSP2IF = 0;
0602  002E     MOVLB 0xE
897:               junk = SSP2BUF;
0604  0023     MOVLB 0x3
898:               SSP2BUF = image_packet[142];             
0609  30DA     MOVLW 0xDA
899:               delay();
060F  319C     MOVLP 0x1C
900:               image_packet[142] = 0;
0612  30DA     MOVLW 0xDA
901:               SSP2IF = 0;
0617  002E     MOVLB 0xE
902:               junk = SSP2BUF;
0619  0023     MOVLB 0x3
903:               SSP2BUF = image_packet[143];             
061E  30DB     MOVLW 0xDB
904:               delay();
0624  319C     MOVLP 0x1C
905:               image_packet[143] = 0;
0627  30DB     MOVLW 0xDB
906:               SSP2IF = 0;
062C  002E     MOVLB 0xE
907:               junk = SSP2BUF;
062E  0023     MOVLB 0x3
908:               SSP2BUF = image_packet[144];             
0633  30DC     MOVLW 0xDC
909:               delay();
0639  319C     MOVLP 0x1C
910:               image_packet[144] = 0;
063C  30DC     MOVLW 0xDC
911:               SSP2IF = 0;
0641  002E     MOVLB 0xE
912:               junk = SSP2BUF;
0643  0023     MOVLB 0x3
913:               SSP2BUF = image_packet[145];             
0648  30DD     MOVLW 0xDD
914:               delay();
064E  319C     MOVLP 0x1C
915:               image_packet[145] = 0;
0651  30DD     MOVLW 0xDD
916:               SSP2IF = 0;
0656  002E     MOVLB 0xE
917:               junk = SSP2BUF;
0658  0023     MOVLB 0x3
918:               SSP2BUF = image_packet[146];             
065D  30DE     MOVLW 0xDE
919:               delay();
0663  319C     MOVLP 0x1C
920:               image_packet[146] = 0;
0666  30DE     MOVLW 0xDE
921:               SSP2IF = 0;
066B  002E     MOVLB 0xE
922:               junk = SSP2BUF;
066D  0023     MOVLB 0x3
923:               SSP2BUF = image_packet[147];             
0672  30DF     MOVLW 0xDF
924:               delay();
0678  319C     MOVLP 0x1C
925:               image_packet[147] = 0;
067B  30DF     MOVLW 0xDF
926:               SSP2IF = 0;
0680  002E     MOVLB 0xE
927:               junk = SSP2BUF;
0682  0023     MOVLB 0x3
928:               SSP2BUF = image_packet[148];             
0687  30E0     MOVLW 0xE0
929:               delay();
068D  319C     MOVLP 0x1C
930:               image_packet[148] = 0;
0690  30E0     MOVLW 0xE0
931:               SSP2IF = 0;
0695  002E     MOVLB 0xE
932:               junk = SSP2BUF;
0697  0023     MOVLB 0x3
933:               SSP2BUF = image_packet[149];             
069C  30E1     MOVLW 0xE1
934:               delay();
06A2  319C     MOVLP 0x1C
935:               image_packet[149] = 0;
06A5  30E1     MOVLW 0xE1
936:               SSP2IF = 0;
06AA  002E     MOVLB 0xE
937:               junk = SSP2BUF;
06AC  0023     MOVLB 0x3
938:               SSP2BUF = image_packet[150];             
06B1  30E2     MOVLW 0xE2
939:               delay();
06B7  319C     MOVLP 0x1C
940:               image_packet[150] = 0;
06BA  30E2     MOVLW 0xE2
941:               SSP2IF = 0;
06BF  002E     MOVLB 0xE
942:               junk = SSP2BUF;
06C1  0023     MOVLB 0x3
943:               SSP2BUF = image_packet[151];             
06C6  30E3     MOVLW 0xE3
944:               delay();
06CC  319C     MOVLP 0x1C
945:               image_packet[151] = 0;
06CF  30E3     MOVLW 0xE3
946:               SSP2IF = 0;
06D4  002E     MOVLB 0xE
947:               junk = SSP2BUF;
06D6  0023     MOVLB 0x3
948:               SSP2BUF = image_packet[152];             
06DB  30E4     MOVLW 0xE4
949:               delay();
06E1  319C     MOVLP 0x1C
950:               image_packet[152] = 0;
06E4  30E4     MOVLW 0xE4
951:               SSP2IF = 0;
06E9  002E     MOVLB 0xE
952:               junk = SSP2BUF;
06EB  0023     MOVLB 0x3
953:               SSP2BUF = image_packet[153];             
06F0  30E5     MOVLW 0xE5
954:               delay();
06F6  319C     MOVLP 0x1C
955:               image_packet[153] = 0;
06F9  30E5     MOVLW 0xE5
956:               SSP2IF = 0;
06FE  002E     MOVLB 0xE
957:               junk = SSP2BUF;
0700  0023     MOVLB 0x3
958:               SSP2BUF = image_packet[154];             
0705  30E6     MOVLW 0xE6
959:               delay();
070B  319C     MOVLP 0x1C
960:               image_packet[154] = 0;
070E  30E6     MOVLW 0xE6
961:               SSP2IF = 0;
0713  002E     MOVLB 0xE
962:               junk = SSP2BUF;
0715  0023     MOVLB 0x3
963:               SSP2BUF = image_packet[155];             
071A  30E7     MOVLW 0xE7
964:               delay();
0720  319C     MOVLP 0x1C
965:               image_packet[155] = 0;
0723  30E7     MOVLW 0xE7
966:               SSP2IF = 0;
0728  002E     MOVLB 0xE
967:               junk = SSP2BUF;
072A  0023     MOVLB 0x3
968:               SSP2BUF = image_packet[156];             
072F  30E8     MOVLW 0xE8
969:               delay();
0735  319C     MOVLP 0x1C
970:               image_packet[156] = 0;
0738  30E8     MOVLW 0xE8
971:               SSP2IF = 0;
073D  002E     MOVLB 0xE
972:               junk = SSP2BUF;
073F  0023     MOVLB 0x3
973:               SSP2BUF = image_packet[157];             
0744  30E9     MOVLW 0xE9
974:               delay();
074A  319C     MOVLP 0x1C
975:               image_packet[157] = 0;
074D  30E9     MOVLW 0xE9
976:               SSP2IF = 0;
0752  002E     MOVLB 0xE
977:               junk = SSP2BUF;
0754  0023     MOVLB 0x3
978:               SSP2BUF = image_packet[158];             
0759  30EA     MOVLW 0xEA
979:               delay();
075F  319C     MOVLP 0x1C
980:               image_packet[158] = 0;
0762  30EA     MOVLW 0xEA
981:               SSP2IF = 0;
0767  002E     MOVLB 0xE
982:               junk = SSP2BUF;
0769  0023     MOVLB 0x3
983:               SSP2BUF = image_packet[159];             
076E  30EB     MOVLW 0xEB
984:               delay();
0774  319C     MOVLP 0x1C
985:               image_packet[159] = 0;
0777  30EB     MOVLW 0xEB
986:               SSP2IF = 0;
077C  002E     MOVLB 0xE
987:               junk = SSP2BUF;
077E  0023     MOVLB 0x3
988:               SSP2BUF = image_packet[160];             
0783  30EC     MOVLW 0xEC
989:               delay();
0789  319C     MOVLP 0x1C
990:               image_packet[160] = 0;
078C  30EC     MOVLW 0xEC
991:               SSP2IF = 0;
0791  002E     MOVLB 0xE
992:               junk = SSP2BUF;
0793  0023     MOVLB 0x3
993:               SSP2BUF = image_packet[161];             
0798  30ED     MOVLW 0xED
994:               delay();
079E  319C     MOVLP 0x1C
995:               image_packet[161] = 0;
07A1  30ED     MOVLW 0xED
996:               SSP2IF = 0;
07A6  002E     MOVLB 0xE
997:               junk = SSP2BUF;
07A8  0023     MOVLB 0x3
998:               SSP2BUF = image_packet[162];             
07AD  30EE     MOVLW 0xEE
999:               delay();
07B3  319C     MOVLP 0x1C
1000:              image_packet[162] = 0;
07B6  30EE     MOVLW 0xEE
1001:              SSP2IF = 0;
07BB  002E     MOVLB 0xE
1002:              junk = SSP2BUF;
07BD  0023     MOVLB 0x3
1003:              SSP2BUF = image_packet[163];             
07C2  30EF     MOVLW 0xEF
1004:              delay();
07C8  319C     MOVLP 0x1C
1005:              image_packet[163] = 0;
07CB  30EF     MOVLW 0xEF
1006:              SSP2IF = 0;
07D0  002E     MOVLB 0xE
1007:              junk = SSP2BUF;
07D2  0023     MOVLB 0x3
1008:              
1009:              
1010:              eth_wiz_transmit_end();
07D7  3190     MOVLP 0x10
1011:          }
07D9  0008     RETURN
1012:          
1013:          
1014:          
1015:          // ************************************************************
1016:          //
1017:          //  This function captures a packet of thermal image data
1018:          //  from the Flir Lepton over the SPI bus. The FLIR does not
1019:          //  use traditional SPI and instead uses a proprietary SPI
1020:          //  based protocol called VoSPI (Video over SPI). It doesn't
1021:          //  send one byte at a time and instead sends over a whole 
1022:          //  packet of data (164 bytes) continuously. This function
1023:          //  is set up to handle that constant stream of data.
1024:          //
1025:          // ************************************************************
1026:          void lepton_capture_packet(void){
1027:              //Initially set the discard flag to 0 - CMH
1028:              discard = 0;
1197  0020     MOVLB 0x0
1029:              
1030:              //Assert the Slave Select (CS) pin for the FLIR - CMH
1031:              PORTCbits.RC0 = 0;
1199  100E     BCF PORTC, 0x0
1032:              
1033:              //These four lines below are the write/read sequencence for the VoSPI on
1034:              //the FLIR. It had to be done with these all in a row because the
1035:              //XC8 compiler for the PIC does not generate optimized code so
1036:              //the program wouldn't run fast enough to get the full image until
1037:              //I wrote in this way - CMH
1038:              SSP1BUF = 0x00;             
119A  0023     MOVLB 0x3
1039:              delay();
119C  319C     MOVLP 0x1C
1040:              SSP1IF = 0;                 
119F  002E     MOVLB 0xE
1041:              image_packet[0] = SSP1BUF;
11A1  304C     MOVLW 0x4C
1042:              
1043:              SSP1BUF = 0x00;             
11A8  018C     CLRF PIR0
1044:              delay();  
11A9  319C     MOVLP 0x1C
1045:              SSP1IF = 0;                 
11AC  002E     MOVLB 0xE
1046:              image_packet[1] = SSP1BUF;
11AE  304D     MOVLW 0x4D
1047:              SSP1BUF = 0x00;             
11B5  018C     CLRF PIR0
1048:              delay();   
11B6  319C     MOVLP 0x1C
1049:              SSP1IF = 0;                 
11B9  002E     MOVLB 0xE
1050:              image_packet[2] = SSP1BUF;
11BB  304E     MOVLW 0x4E
1051:              SSP1BUF = 0x00;             
11C2  018C     CLRF PIR0
1052:              delay();   
11C3  319C     MOVLP 0x1C
1053:              SSP1IF = 0;                 
11C6  002E     MOVLB 0xE
1054:              image_packet[3] = SSP1BUF;
11C8  304F     MOVLW 0x4F
1055:              SSP1BUF = 0x00;             
11CF  018C     CLRF PIR0
1056:              delay();  
11D0  319C     MOVLP 0x1C
1057:              SSP1IF = 0;                 
11D3  002E     MOVLB 0xE
1058:              image_packet[4] = SSP1BUF;
11D5  3050     MOVLW 0x50
1059:              SSP1BUF = 0x00;             
11DC  018C     CLRF PIR0
1060:              delay();     
11DD  319C     MOVLP 0x1C
1061:              SSP1IF = 0;                 
11E0  002E     MOVLB 0xE
1062:              image_packet[5] = SSP1BUF;
11E2  3051     MOVLW 0x51
1063:              SSP1BUF = 0x00;             
11E9  018C     CLRF PIR0
1064:              delay();      
11EA  319C     MOVLP 0x1C
1065:              SSP1IF = 0;                 
11ED  002E     MOVLB 0xE
1066:              image_packet[6] = SSP1BUF;
11EF  3052     MOVLW 0x52
1067:              SSP1BUF = 0x00;             
11F6  018C     CLRF PIR0
1068:              delay();       
11F7  319C     MOVLP 0x1C
1069:              SSP1IF = 0;                 
11FA  002E     MOVLB 0xE
1070:              image_packet[7] = SSP1BUF;
11FC  3053     MOVLW 0x53
1071:              SSP1BUF = 0x00;             
1203  018C     CLRF PIR0
1072:              delay();       
1204  319C     MOVLP 0x1C
1073:              SSP1IF = 0;                 
1207  002E     MOVLB 0xE
1074:              image_packet[8] = SSP1BUF;
1209  3054     MOVLW 0x54
1075:              SSP1BUF = 0x00;             
1210  018C     CLRF PIR0
1076:              delay();       
1211  319C     MOVLP 0x1C
1077:              SSP1IF = 0;                 
1214  002E     MOVLB 0xE
1078:              image_packet[9] = SSP1BUF;
1216  3055     MOVLW 0x55
1079:              SSP1BUF = 0x00;             
121D  018C     CLRF PIR0
1080:              delay();      
121E  319C     MOVLP 0x1C
1081:              SSP1IF = 0;                 
1221  002E     MOVLB 0xE
1D5B  100F     BCF PIR3, 0x0
1082:              image_packet[10] = SSP1BUF;
1D5C  3056     MOVLW 0x56
1083:              SSP1BUF = 0x00;             
1D63  018C     CLRF PIR0
1084:              delay();   
1D64  319C     MOVLP 0x1C
1085:              SSP1IF = 0;                 
1D67  002E     MOVLB 0xE
1086:              image_packet[11] = SSP1BUF;
1D69  3057     MOVLW 0x57
1087:              SSP1BUF = 0x00;             
1D70  018C     CLRF PIR0
1088:              delay();     
1D71  319C     MOVLP 0x1C
1089:              SSP1IF = 0;                 
1D74  002E     MOVLB 0xE
1090:              image_packet[12] = SSP1BUF;
1D76  3058     MOVLW 0x58
1091:              SSP1BUF = 0x00;             
1D7D  018C     CLRF PIR0
1092:              delay();     
1D7E  319C     MOVLP 0x1C
1093:              SSP1IF = 0;                 
1D81  002E     MOVLB 0xE
1094:              image_packet[13] = SSP1BUF;
1D83  3059     MOVLW 0x59
1095:              SSP1BUF = 0x00;             
1D8A  018C     CLRF PIR0
1096:              delay();       
1D8B  319C     MOVLP 0x1C
1097:              SSP1IF = 0;                 
1D8E  002E     MOVLB 0xE
1098:              image_packet[14] = SSP1BUF;
1D90  305A     MOVLW 0x5A
1099:              SSP1BUF = 0x00;             
1D97  018C     CLRF PIR0
1100:              delay();       
1D98  319C     MOVLP 0x1C
1101:              SSP1IF = 0;                 
1D9B  002E     MOVLB 0xE
1102:              image_packet[15] = SSP1BUF;
1D9D  305B     MOVLW 0x5B
1103:              SSP1BUF = 0x00;             
1DA4  018C     CLRF PIR0
1104:              delay();       
1DA5  319C     MOVLP 0x1C
1105:              SSP1IF = 0;                 
1DA8  002E     MOVLB 0xE
1106:              image_packet[16] = SSP1BUF;
1DAA  305C     MOVLW 0x5C
1107:              SSP1BUF = 0x00;             
1DB1  018C     CLRF PIR0
1108:              delay();        
1DB2  319C     MOVLP 0x1C
1109:              SSP1IF = 0;                 
1DB5  002E     MOVLB 0xE
1110:              image_packet[17] = SSP1BUF;
1DB7  305D     MOVLW 0x5D
1111:              SSP1BUF = 0x00;             
1DBE  018C     CLRF PIR0
1112:              delay();       
1DBF  319C     MOVLP 0x1C
1113:              SSP1IF = 0;                 
1DC2  002E     MOVLB 0xE
1114:              image_packet[18] = SSP1BUF;
1DC4  305E     MOVLW 0x5E
1115:              SSP1BUF = 0x00;             
1DCB  018C     CLRF PIR0
1116:              delay();      
1DCC  319C     MOVLP 0x1C
1117:              SSP1IF = 0;                 
1DCF  002E     MOVLB 0xE
1118:              image_packet[19] = SSP1BUF;
1DD1  305F     MOVLW 0x5F
1119:              SSP1BUF = 0x00;             
1DD8  018C     CLRF PIR0
1120:              delay();       
1DD9  319C     MOVLP 0x1C
1121:              SSP1IF = 0;                 
0881  100F     BCF PIR3, 0x0
1DDC  002E     MOVLB 0xE
1122:              image_packet[20] = SSP1BUF;
0882  3060     MOVLW 0x60
1123:              SSP1BUF = 0x00;             
0889  018C     CLRF PIR0
1124:              delay();       
088A  319C     MOVLP 0x1C
1125:              SSP1IF = 0;                 
088D  002E     MOVLB 0xE
1126:              image_packet[21] = SSP1BUF;
088F  3061     MOVLW 0x61
1127:              SSP1BUF = 0x00;             
0896  018C     CLRF PIR0
1128:              delay();       
0897  319C     MOVLP 0x1C
1129:              SSP1IF = 0;                 
089A  002E     MOVLB 0xE
1130:              image_packet[22] = SSP1BUF;
089C  3062     MOVLW 0x62
1131:              SSP1BUF = 0x00;             
08A3  018C     CLRF PIR0
1132:              delay();       
08A4  319C     MOVLP 0x1C
1133:              SSP1IF = 0;                 
08A7  002E     MOVLB 0xE
1134:              image_packet[23] = SSP1BUF;
08A9  3063     MOVLW 0x63
1135:              SSP1BUF = 0x00;             
08B0  018C     CLRF PIR0
1136:              delay();     
08B1  319C     MOVLP 0x1C
1137:              SSP1IF = 0;                 
08B4  002E     MOVLB 0xE
1138:              image_packet[24] = SSP1BUF;
08B6  3064     MOVLW 0x64
1139:              SSP1BUF = 0x00;             
08BD  018C     CLRF PIR0
1140:              delay();       
08BE  319C     MOVLP 0x1C
1141:              SSP1IF = 0;                 
08C1  002E     MOVLB 0xE
1142:              image_packet[25] = SSP1BUF;
08C3  3065     MOVLW 0x65
1143:              SSP1BUF = 0x00;             
08CA  018C     CLRF PIR0
1144:              delay();
08CB  319C     MOVLP 0x1C
1145:              SSP1IF = 0;                 
08CE  002E     MOVLB 0xE
1146:              image_packet[26] = SSP1BUF;
08D0  3066     MOVLW 0x66
1147:              SSP1BUF = 0x00;             
08D7  018C     CLRF PIR0
1148:              delay();
08D8  319C     MOVLP 0x1C
1149:              SSP1IF = 0;                 
08DB  002E     MOVLB 0xE
1150:              image_packet[27] = SSP1BUF;
08DD  3067     MOVLW 0x67
1151:              SSP1BUF = 0x00;             
08E4  018C     CLRF PIR0
1152:              delay();
08E5  319C     MOVLP 0x1C
1153:              SSP1IF = 0;                 
08E8  002E     MOVLB 0xE
1154:              image_packet[28] = SSP1BUF;
08EA  3068     MOVLW 0x68
1155:              SSP1BUF = 0x00;             
08F1  018C     CLRF PIR0
1156:              delay();
08F2  319C     MOVLP 0x1C
1157:              SSP1IF = 0;                 
08F5  002E     MOVLB 0xE
1158:              image_packet[29] = SSP1BUF;
08F7  3069     MOVLW 0x69
1159:              SSP1BUF = 0x00;             
08FE  018C     CLRF PIR0
1160:              delay();
08FF  319C     MOVLP 0x1C
1161:              SSP1IF = 0;                 
0902  002E     MOVLB 0xE
1162:              image_packet[30] = SSP1BUF;
0904  306A     MOVLW 0x6A
1163:              SSP1BUF = 0x00;             
090B  018C     CLRF PIR0
1164:              delay();
090C  319C     MOVLP 0x1C
1165:              SSP1IF = 0;                 
090F  002E     MOVLB 0xE
1166:              image_packet[31] = SSP1BUF;
0911  306B     MOVLW 0x6B
1167:              SSP1BUF = 0x00;             
0918  018C     CLRF PIR0
1168:              delay();
0919  319C     MOVLP 0x1C
1169:              SSP1IF = 0;                 
091C  002E     MOVLB 0xE
1170:              image_packet[32] = SSP1BUF;
091E  306C     MOVLW 0x6C
1171:              SSP1BUF = 0x00;             
0925  018C     CLRF PIR0
1172:              delay();
0926  319C     MOVLP 0x1C
1173:              SSP1IF = 0;                 
0929  002E     MOVLB 0xE
1174:              image_packet[33] = SSP1BUF;
092B  306D     MOVLW 0x6D
1175:              SSP1BUF = 0x00;             
0932  018C     CLRF PIR0
1176:              delay();
0933  319C     MOVLP 0x1C
1177:              SSP1IF = 0;                 
0936  002E     MOVLB 0xE
1178:              image_packet[34] = SSP1BUF;
0938  306E     MOVLW 0x6E
1179:              SSP1BUF = 0x00;             
093F  018C     CLRF PIR0
1180:              delay();
0940  319C     MOVLP 0x1C
1181:              SSP1IF = 0;                 
0943  002E     MOVLB 0xE
1182:              image_packet[35] = SSP1BUF;
0945  306F     MOVLW 0x6F
1183:              SSP1BUF = 0x00;             
094C  018C     CLRF PIR0
1184:              delay();
094D  319C     MOVLP 0x1C
1185:              SSP1IF = 0;                 
0950  002E     MOVLB 0xE
1186:              image_packet[36] = SSP1BUF;
0952  3070     MOVLW 0x70
1187:              SSP1BUF = 0x00;             
0959  018C     CLRF PIR0
1188:              delay();
095A  319C     MOVLP 0x1C
1189:              SSP1IF = 0;                 
095D  002E     MOVLB 0xE
1190:              image_packet[37] = SSP1BUF;
095F  3071     MOVLW 0x71
1191:              SSP1BUF = 0x00;             
0966  018C     CLRF PIR0
1192:              delay();
0967  319C     MOVLP 0x1C
1193:              SSP1IF = 0;                 
096A  002E     MOVLB 0xE
1194:              image_packet[38] = SSP1BUF;
096C  3072     MOVLW 0x72
1195:              SSP1BUF = 0x00;             
0973  018C     CLRF PIR0
1196:              delay();
0974  319C     MOVLP 0x1C
1197:              SSP1IF = 0;                 
0977  002E     MOVLB 0xE
1198:              image_packet[39] = SSP1BUF;
0979  3073     MOVLW 0x73
1199:              SSP1BUF = 0x00;             
0980  018C     CLRF PIR0
1200:              delay();
0981  319C     MOVLP 0x1C
1201:              SSP1IF = 0;                 
0984  002E     MOVLB 0xE
1202:              image_packet[40] = SSP1BUF;
0986  3074     MOVLW 0x74
1203:              SSP1BUF = 0x00;             
098D  018C     CLRF PIR0
1204:              delay();
098E  319C     MOVLP 0x1C
1205:              SSP1IF = 0;                 
0991  002E     MOVLB 0xE
1206:              image_packet[41] = SSP1BUF;
0993  3075     MOVLW 0x75
1207:              SSP1BUF = 0x00;             
099A  018C     CLRF PIR0
1208:              delay();
099B  319C     MOVLP 0x1C
1209:              SSP1IF = 0;                 
099E  002E     MOVLB 0xE
1210:              image_packet[42] = SSP1BUF;
09A0  3076     MOVLW 0x76
1211:              SSP1BUF = 0x00;             
09A7  018C     CLRF PIR0
1212:              delay();
09A8  319C     MOVLP 0x1C
1213:              SSP1IF = 0;                 
09AB  002E     MOVLB 0xE
1214:              image_packet[43] = SSP1BUF;
09AD  3077     MOVLW 0x77
1215:              SSP1BUF = 0x00;             
09B4  018C     CLRF PIR0
1216:              delay();
09B5  319C     MOVLP 0x1C
1217:              SSP1IF = 0;                 
09B8  002E     MOVLB 0xE
1218:              image_packet[44] = SSP1BUF;
09BA  3078     MOVLW 0x78
1219:              SSP1BUF = 0x00;             
09C1  018C     CLRF PIR0
1220:              delay();
09C2  319C     MOVLP 0x1C
1221:              SSP1IF = 0;                 
09C5  002E     MOVLB 0xE
1222:              image_packet[45] = SSP1BUF;
09C7  3079     MOVLW 0x79
1223:              SSP1BUF = 0x00;             
09CE  018C     CLRF PIR0
1224:              delay();
09CF  319C     MOVLP 0x1C
1225:              SSP1IF = 0;                 
09D2  002E     MOVLB 0xE
1226:              image_packet[46] = SSP1BUF;
09D4  307A     MOVLW 0x7A
1227:              SSP1BUF = 0x00;             
09DB  018C     CLRF PIR0
1228:              delay();
09DC  319C     MOVLP 0x1C
1229:              SSP1IF = 0;                 
09DF  002E     MOVLB 0xE
1230:              image_packet[47] = SSP1BUF;
09E1  307B     MOVLW 0x7B
1231:              SSP1BUF = 0x00;             
09E8  018C     CLRF PIR0
1232:              delay();
09E9  319C     MOVLP 0x1C
1233:              SSP1IF = 0;                 
09EC  002E     MOVLB 0xE
1234:              image_packet[48] = SSP1BUF;
09EE  307C     MOVLW 0x7C
1235:              SSP1BUF = 0x00;             
09F5  018C     CLRF PIR0
1236:              delay();
09F6  319C     MOVLP 0x1C
1237:              SSP1IF = 0;                 
09F9  002E     MOVLB 0xE
1238:              image_packet[49] = SSP1BUF;
09FB  307D     MOVLW 0x7D
1239:              SSP1BUF = 0x00;             
0A02  018C     CLRF PIR0
1240:              delay();
0A03  319C     MOVLP 0x1C
1241:              SSP1IF = 0;                 
0A06  002E     MOVLB 0xE
1242:              image_packet[50] = SSP1BUF;
0A08  307E     MOVLW 0x7E
1243:              SSP1BUF = 0x00;             
0A0F  018C     CLRF PIR0
1244:              delay();
0A10  319C     MOVLP 0x1C
1245:              SSP1IF = 0;                 
0A13  002E     MOVLB 0xE
1246:              image_packet[51] = SSP1BUF;
0A15  307F     MOVLW 0x7F
1247:              SSP1BUF = 0x00;             
0A1C  018C     CLRF PIR0
1248:              delay();
0A1D  319C     MOVLP 0x1C
1249:              SSP1IF = 0;                 
0A20  002E     MOVLB 0xE
1250:              image_packet[52] = SSP1BUF;
0A22  3080     MOVLW 0x80
1251:              SSP1BUF = 0x00;             
0A29  018C     CLRF PIR0
1252:              delay();
0A2A  319C     MOVLP 0x1C
1253:              SSP1IF = 0;                 
0A2D  002E     MOVLB 0xE
1254:              image_packet[53] = SSP1BUF;
0A2F  3081     MOVLW 0x81
1255:              SSP1BUF = 0x00;             
0A36  018C     CLRF PIR0
1256:              delay();
0A37  319C     MOVLP 0x1C
1257:              SSP1IF = 0;                 
0A3A  002E     MOVLB 0xE
1258:              image_packet[54] = SSP1BUF;
0A3C  3082     MOVLW 0x82
1259:              SSP1BUF = 0x00;             
0A43  018C     CLRF PIR0
1260:              delay();
0A44  319C     MOVLP 0x1C
1261:              SSP1IF = 0;                 
0A47  002E     MOVLB 0xE
1262:              image_packet[55] = SSP1BUF;
0A49  3083     MOVLW 0x83
1263:              SSP1BUF = 0x00;             
0A50  018C     CLRF PIR0
1264:              delay();
0A51  319C     MOVLP 0x1C
1265:              SSP1IF = 0;                 
0A54  002E     MOVLB 0xE
1266:              image_packet[56] = SSP1BUF;
0A56  3084     MOVLW 0x84
1267:              SSP1BUF = 0x00;             
0A5D  018C     CLRF PIR0
1268:              delay();
0A5E  319C     MOVLP 0x1C
1269:              SSP1IF = 0;                 
0A61  002E     MOVLB 0xE
1270:              image_packet[57] = SSP1BUF;
0A63  3085     MOVLW 0x85
1271:              SSP1BUF = 0x00;             
0A6A  018C     CLRF PIR0
1272:              delay();
0A6B  319C     MOVLP 0x1C
1273:              SSP1IF = 0;                 
0A6E  002E     MOVLB 0xE
1274:              image_packet[58] = SSP1BUF;
0A70  3086     MOVLW 0x86
1275:              SSP1BUF = 0x00;             
0A77  018C     CLRF PIR0
1276:              delay();
0A78  319C     MOVLP 0x1C
1277:              SSP1IF = 0;                 
0A7B  002E     MOVLB 0xE
1278:              image_packet[59] = SSP1BUF;
0A7D  3087     MOVLW 0x87
1279:              SSP1BUF = 0x00;             
0A84  018C     CLRF PIR0
1280:              delay();    
0A85  319C     MOVLP 0x1C
1281:              SSP1IF = 0;                 
0A88  002E     MOVLB 0xE
1282:              image_packet[60] = SSP1BUF;
0A8A  3088     MOVLW 0x88
1283:              SSP1BUF = 0x00;             
0A91  018C     CLRF PIR0
1284:              delay();
0A92  319C     MOVLP 0x1C
1285:              SSP1IF = 0;                 
0A95  002E     MOVLB 0xE
1286:              image_packet[61] = SSP1BUF;
0A97  3089     MOVLW 0x89
1287:              SSP1BUF = 0x00;             
0A9E  018C     CLRF PIR0
1288:              delay();
0A9F  319C     MOVLP 0x1C
1289:              SSP1IF = 0;                 
0AA2  002E     MOVLB 0xE
1290:              image_packet[62] = SSP1BUF;
0AA4  308A     MOVLW 0x8A
1291:              SSP1BUF = 0x00;             
0AAB  018C     CLRF PIR0
1292:              delay();
0AAC  319C     MOVLP 0x1C
1293:              SSP1IF = 0;                 
0AAF  002E     MOVLB 0xE
1294:              image_packet[63] = SSP1BUF;
0AB1  308B     MOVLW 0x8B
1295:              SSP1BUF = 0x00;             
0AB8  018C     CLRF PIR0
1296:              delay();
0AB9  319C     MOVLP 0x1C
1297:              SSP1IF = 0;                 
0ABC  002E     MOVLB 0xE
1298:              image_packet[64] = SSP1BUF;
0ABE  308C     MOVLW 0x8C
1299:              SSP1BUF = 0x00;             
0AC5  018C     CLRF PIR0
1300:              delay();
0AC6  319C     MOVLP 0x1C
1301:              SSP1IF = 0;                 
0AC9  002E     MOVLB 0xE
1302:              image_packet[65] = SSP1BUF;
0ACB  308D     MOVLW 0x8D
1303:              SSP1BUF = 0x00;             
0AD2  018C     CLRF PIR0
1304:              delay();
0AD3  319C     MOVLP 0x1C
1305:              SSP1IF = 0;                 
0AD6  002E     MOVLB 0xE
1306:              image_packet[66] = SSP1BUF;
0AD8  308E     MOVLW 0x8E
1307:              SSP1BUF = 0x00;             
0ADF  018C     CLRF PIR0
1308:              delay();        
0AE0  319C     MOVLP 0x1C
1309:              SSP1IF = 0;                 
0AE3  002E     MOVLB 0xE
1310:              image_packet[67] = SSP1BUF;
0AE5  308F     MOVLW 0x8F
1311:              SSP1BUF = 0x00;             
0AEC  018C     CLRF PIR0
1312:              delay();        
0AED  319C     MOVLP 0x1C
1313:              SSP1IF = 0;                 
0AF0  002E     MOVLB 0xE
1314:              image_packet[68] = SSP1BUF;
0AF2  3090     MOVLW 0x90
1315:              SSP1BUF = 0x00;             
0AF9  018C     CLRF PIR0
1316:              delay();        
0AFA  319C     MOVLP 0x1C
1317:              SSP1IF = 0;                 
0AFD  002E     MOVLB 0xE
1318:              image_packet[69] = SSP1BUF;
0AFF  3091     MOVLW 0x91
1319:              SSP1BUF = 0x00;             
0B06  018C     CLRF PIR0
1320:              delay();        
0B07  319C     MOVLP 0x1C
1321:              SSP1IF = 0;                 
0B0A  002E     MOVLB 0xE
1322:              image_packet[70] = SSP1BUF;
0B0C  3092     MOVLW 0x92
1323:              SSP1BUF = 0x00;            
0B13  018C     CLRF PIR0
1324:              delay();        
0B14  319C     MOVLP 0x1C
1325:              SSP1IF = 0;                 
0B17  002E     MOVLB 0xE
1326:              image_packet[71] = SSP1BUF;
0B19  3093     MOVLW 0x93
1327:              SSP1BUF = 0x00;             
0B20  018C     CLRF PIR0
1328:              delay();        
0B21  319C     MOVLP 0x1C
1329:              SSP1IF = 0;                 
0B24  002E     MOVLB 0xE
1330:              image_packet[72] = SSP1BUF;
0B26  3094     MOVLW 0x94
1331:              SSP1BUF = 0x00;             
0B2D  018C     CLRF PIR0
1332:              delay();        
0B2E  319C     MOVLP 0x1C
1333:              SSP1IF = 0;                 
0B31  002E     MOVLB 0xE
1334:              image_packet[73] = SSP1BUF;
0B33  3095     MOVLW 0x95
1335:              SSP1BUF = 0x00;             
0B3A  018C     CLRF PIR0
1336:              delay();        
0B3B  319C     MOVLP 0x1C
1337:              SSP1IF = 0;                 
0B3E  002E     MOVLB 0xE
1338:              image_packet[74] = SSP1BUF;
0B40  3096     MOVLW 0x96
1339:              SSP1BUF = 0x00;             
0B47  018C     CLRF PIR0
1340:              delay();        
0B48  319C     MOVLP 0x1C
1341:              SSP1IF = 0;                 
0B4B  002E     MOVLB 0xE
1342:              image_packet[75] = SSP1BUF;
0B4D  3097     MOVLW 0x97
1343:              SSP1BUF = 0x00;             
0B54  018C     CLRF PIR0
1344:              delay();        
0B55  319C     MOVLP 0x1C
1345:              SSP1IF = 0;                 
0B58  002E     MOVLB 0xE
1346:              image_packet[76] = SSP1BUF;
0B5A  3098     MOVLW 0x98
1347:              SSP1BUF = 0x00;             
0B61  018C     CLRF PIR0
1348:              delay();        
0B62  319C     MOVLP 0x1C
1349:              SSP1IF = 0;                 
0B65  002E     MOVLB 0xE
1350:              image_packet[77] = SSP1BUF;
0B67  3099     MOVLW 0x99
1351:              SSP1BUF = 0x00;             
0B6E  018C     CLRF PIR0
1352:              delay();        
0B6F  319C     MOVLP 0x1C
1353:              SSP1IF = 0;                 
0B72  002E     MOVLB 0xE
1354:              image_packet[78] = SSP1BUF;
0B74  309A     MOVLW 0x9A
1355:              SSP1BUF = 0x00;             
0B7B  018C     CLRF PIR0
1356:              delay();        
0B7C  319C     MOVLP 0x1C
1357:              SSP1IF = 0;                 
0B7F  002E     MOVLB 0xE
1358:              image_packet[79] = SSP1BUF;
0B81  309B     MOVLW 0x9B
1359:              SSP1BUF = 0x00;             
0B88  018C     CLRF PIR0
1360:              delay();        
0B89  319C     MOVLP 0x1C
1361:              SSP1IF = 0;                 
0B8C  002E     MOVLB 0xE
1362:              image_packet[80] = SSP1BUF;
0B8E  309C     MOVLW 0x9C
1363:              SSP1BUF = 0x00;             
0B95  018C     CLRF PIR0
1364:              delay();        
0B96  319C     MOVLP 0x1C
1365:              SSP1IF = 0;                 
0B99  002E     MOVLB 0xE
1366:              image_packet[81] = SSP1BUF;
0B9B  309D     MOVLW 0x9D
1367:              SSP1BUF = 0x00;             
0BA2  018C     CLRF PIR0
1368:              delay();        
0BA3  319C     MOVLP 0x1C
1369:              SSP1IF = 0;                 
0BA6  002E     MOVLB 0xE
1370:              image_packet[82] = SSP1BUF;
0BA8  309E     MOVLW 0x9E
1371:              SSP1BUF = 0x00;             
0BAF  018C     CLRF PIR0
1372:              delay();        
0BB0  319C     MOVLP 0x1C
1373:              SSP1IF = 0;                 
0BB3  002E     MOVLB 0xE
1374:              image_packet[83] = SSP1BUF;
0BB5  309F     MOVLW 0x9F
1375:              SSP1BUF = 0x00;             
0BBC  018C     CLRF PIR0
1376:              delay();        
0BBD  319C     MOVLP 0x1C
1377:              SSP1IF = 0;                 
0BC0  002E     MOVLB 0xE
1378:              image_packet[84] = SSP1BUF;
0BC2  30A0     MOVLW 0xA0
1379:              SSP1BUF = 0x00;             
0BC9  018C     CLRF PIR0
1380:              delay();        
0BCA  319C     MOVLP 0x1C
1381:              SSP1IF = 0;                 
0BCD  002E     MOVLB 0xE
1382:              image_packet[85] = SSP1BUF;
0BCF  30A1     MOVLW 0xA1
1383:              SSP1BUF = 0x00;             
0BD6  018C     CLRF PIR0
1384:              delay();        
0BD7  319C     MOVLP 0x1C
1385:              SSP1IF = 0;                 
0BDA  002E     MOVLB 0xE
1386:              image_packet[86] = SSP1BUF;
0BDC  30A2     MOVLW 0xA2
1387:              SSP1BUF = 0x00;             
0BE3  018C     CLRF PIR0
1388:              delay();        
0BE4  319C     MOVLP 0x1C
1389:              SSP1IF = 0;                 
0BE7  002E     MOVLB 0xE
1390:              image_packet[87] = SSP1BUF;
0BE9  30A3     MOVLW 0xA3
1391:              SSP1BUF = 0x00;             
0BF0  018C     CLRF PIR0
1392:              delay();        
0BF1  319C     MOVLP 0x1C
1393:              SSP1IF = 0;                 
0BF4  002E     MOVLB 0xE
1394:              image_packet[88] = SSP1BUF;
0BF6  30A4     MOVLW 0xA4
1395:              SSP1BUF = 0x00;             
0BFD  018C     CLRF PIR0
1396:              delay();        
0BFE  319C     MOVLP 0x1C
1397:              SSP1IF = 0;                 
0C01  002E     MOVLB 0xE
1398:              image_packet[89] = SSP1BUF;
0C03  30A5     MOVLW 0xA5
1399:              SSP1BUF = 0x00;             
0C0A  018C     CLRF PIR0
1400:              delay();        
0C0B  319C     MOVLP 0x1C
1401:              SSP1IF = 0;                 
0C0E  002E     MOVLB 0xE
1402:              image_packet[90] = SSP1BUF;
0C10  30A6     MOVLW 0xA6
1403:              SSP1BUF = 0x00;             
0C17  018C     CLRF PIR0
1404:              delay();        
0C18  319C     MOVLP 0x1C
1405:              SSP1IF = 0;                 
0C1B  002E     MOVLB 0xE
1406:              image_packet[91] = SSP1BUF;
0C1D  30A7     MOVLW 0xA7
1407:              SSP1BUF = 0x00;             
0C24  018C     CLRF PIR0
1408:              delay();        
0C25  319C     MOVLP 0x1C
1409:              SSP1IF = 0;                 
0C28  002E     MOVLB 0xE
1410:              image_packet[92] = SSP1BUF;
0C2A  30A8     MOVLW 0xA8
1411:              SSP1BUF = 0x00;             
0C31  018C     CLRF PIR0
1412:              delay();        
0C32  319C     MOVLP 0x1C
1413:              SSP1IF = 0;                 
0C35  002E     MOVLB 0xE
1414:              image_packet[93] = SSP1BUF;
0C37  30A9     MOVLW 0xA9
1415:              SSP1BUF = 0x00;             
0C3E  018C     CLRF PIR0
1416:              delay();        
0C3F  319C     MOVLP 0x1C
1417:              SSP1IF = 0;                 
0C42  002E     MOVLB 0xE
1418:              image_packet[94] = SSP1BUF;
0C44  30AA     MOVLW 0xAA
1419:              SSP1BUF = 0x00;             
0C4B  018C     CLRF PIR0
1420:              delay();        
0C4C  319C     MOVLP 0x1C
1421:              SSP1IF = 0;                 
0C4F  002E     MOVLB 0xE
1422:              image_packet[95] = SSP1BUF;
0C51  30AB     MOVLW 0xAB
1423:              SSP1BUF = 0x00;             
0C58  018C     CLRF PIR0
1424:              delay();        
0C59  319C     MOVLP 0x1C
1425:              SSP1IF = 0;                 
0C5C  002E     MOVLB 0xE
1426:              image_packet[96] = SSP1BUF;
0C5E  30AC     MOVLW 0xAC
1427:              SSP1BUF = 0x00;             
0C65  018C     CLRF PIR0
1428:              delay();        
0C66  319C     MOVLP 0x1C
1429:              SSP1IF = 0;                 
0C69  002E     MOVLB 0xE
1430:              image_packet[97] = SSP1BUF;
0C6B  30AD     MOVLW 0xAD
1431:              SSP1BUF = 0x00;             
0C72  018C     CLRF PIR0
1432:              delay();        
0C73  319C     MOVLP 0x1C
1433:              SSP1IF = 0;                 
0C76  002E     MOVLB 0xE
1434:              image_packet[98] = SSP1BUF;
0C78  30AE     MOVLW 0xAE
1435:              SSP1BUF = 0x00;             
0C7F  018C     CLRF PIR0
1436:              delay();        
0C80  319C     MOVLP 0x1C
1437:              SSP1IF = 0;                 
0C83  002E     MOVLB 0xE
1438:              image_packet[99] = SSP1BUF;
0C85  30AF     MOVLW 0xAF
1439:              SSP1BUF = 0x00;             
0C8C  018C     CLRF PIR0
1440:              delay();        
0C8D  319C     MOVLP 0x1C
1441:              SSP1IF = 0;                 
0C90  002E     MOVLB 0xE
1442:              image_packet[100] = SSP1BUF;
0C92  30B0     MOVLW 0xB0
1443:              SSP1BUF = 0x00;             
0C99  018C     CLRF PIR0
1444:              delay();        
0C9A  319C     MOVLP 0x1C
1445:              SSP1IF = 0;                 
0C9D  002E     MOVLB 0xE
1446:              image_packet[101] = SSP1BUF;
0C9F  30B1     MOVLW 0xB1
1447:              SSP1BUF = 0x00;             
0CA6  018C     CLRF PIR0
1448:              delay();        
0CA7  319C     MOVLP 0x1C
1449:              SSP1IF = 0;                 
0CAA  002E     MOVLB 0xE
1450:              image_packet[102] = SSP1BUF;
0CAC  30B2     MOVLW 0xB2
1451:              SSP1BUF = 0x00;             
0CB3  018C     CLRF PIR0
1452:              delay();        
0CB4  319C     MOVLP 0x1C
1453:              SSP1IF = 0;                 
0CB7  002E     MOVLB 0xE
1454:              image_packet[103] = SSP1BUF;
0CB9  30B3     MOVLW 0xB3
1455:              SSP1BUF = 0x00;             
0CC0  018C     CLRF PIR0
1456:              delay();        
0CC1  319C     MOVLP 0x1C
1457:              SSP1IF = 0;                 
0CC4  002E     MOVLB 0xE
1458:              image_packet[104] = SSP1BUF;
0CC6  30B4     MOVLW 0xB4
1459:              SSP1BUF = 0x00;             
0CCD  018C     CLRF PIR0
1460:              delay();        
0CCE  319C     MOVLP 0x1C
1461:              SSP1IF = 0;                 
0CD1  002E     MOVLB 0xE
1462:              image_packet[105] = SSP1BUF;
0CD3  30B5     MOVLW 0xB5
1463:              SSP1BUF = 0x00;             
0CDA  018C     CLRF PIR0
1464:              delay();        
0CDB  319C     MOVLP 0x1C
1465:              SSP1IF = 0;                 
0CDE  002E     MOVLB 0xE
1466:              image_packet[106] = SSP1BUF;
0CE0  30B6     MOVLW 0xB6
1467:              SSP1BUF = 0x00;             
0CE7  018C     CLRF PIR0
1468:              delay();        
0CE8  319C     MOVLP 0x1C
1469:              SSP1IF = 0;                 
0CEB  002E     MOVLB 0xE
1470:              image_packet[107] = SSP1BUF;
0CED  30B7     MOVLW 0xB7
1471:              SSP1BUF = 0x00;             
0CF4  018C     CLRF PIR0
1472:              delay();        
0CF5  319C     MOVLP 0x1C
1473:              SSP1IF = 0;                 
0CF8  002E     MOVLB 0xE
1474:              image_packet[108] = SSP1BUF;
0CFA  30B8     MOVLW 0xB8
1475:              SSP1BUF = 0x00;             
0D01  018C     CLRF PIR0
1476:              delay();        
0D02  319C     MOVLP 0x1C
1477:              SSP1IF = 0;                 
0D05  002E     MOVLB 0xE
1478:              image_packet[109] = SSP1BUF;
0D07  30B9     MOVLW 0xB9
1479:              SSP1BUF = 0x00;             
0D0E  018C     CLRF PIR0
1480:              delay();        
0D0F  319C     MOVLP 0x1C
1481:              SSP1IF = 0;                 
0D12  002E     MOVLB 0xE
1482:              image_packet[110] = SSP1BUF;
0D14  30BA     MOVLW 0xBA
1483:              SSP1BUF = 0x00;             
0D1B  018C     CLRF PIR0
1484:              delay();        
0D1C  319C     MOVLP 0x1C
1485:              SSP1IF = 0;                 
0D1F  002E     MOVLB 0xE
1486:              image_packet[111] = SSP1BUF;
0D21  30BB     MOVLW 0xBB
1487:              SSP1BUF = 0x00;             
0D28  018C     CLRF PIR0
1488:              delay();        
0D29  319C     MOVLP 0x1C
1489:              SSP1IF = 0;                 
0D2C  002E     MOVLB 0xE
1490:              image_packet[112] = SSP1BUF;
0D2E  30BC     MOVLW 0xBC
1491:              SSP1BUF = 0x00;             
0D35  018C     CLRF PIR0
1492:              delay();        
0D36  319C     MOVLP 0x1C
1493:              SSP1IF = 0;                 
0D39  002E     MOVLB 0xE
1494:              image_packet[113] = SSP1BUF;
0D3B  30BD     MOVLW 0xBD
1495:              SSP1BUF = 0x00;             
0D42  018C     CLRF PIR0
1496:              delay();        
0D43  319C     MOVLP 0x1C
1497:              SSP1IF = 0;                 
0D46  002E     MOVLB 0xE
1498:              image_packet[114] = SSP1BUF;
0D48  30BE     MOVLW 0xBE
1499:              SSP1BUF = 0x00;             
0D4F  018C     CLRF PIR0
1500:              delay();        
0D50  319C     MOVLP 0x1C
1501:              SSP1IF = 0;                 
0D53  002E     MOVLB 0xE
1502:              image_packet[115] = SSP1BUF;
0D55  30BF     MOVLW 0xBF
1503:              SSP1BUF = 0x00;             
0D5C  018C     CLRF PIR0
1504:              delay();        
0D5D  319C     MOVLP 0x1C
1505:              SSP1IF = 0;                 
0D60  002E     MOVLB 0xE
1506:              image_packet[116] = SSP1BUF;
0D62  30C0     MOVLW 0xC0
1507:              SSP1BUF = 0x00;             
0D69  018C     CLRF PIR0
1508:              delay();        
0D6A  319C     MOVLP 0x1C
1509:              SSP1IF = 0;                 
0D6D  002E     MOVLB 0xE
1510:              image_packet[117] = SSP1BUF;
0D6F  30C1     MOVLW 0xC1
1511:              SSP1BUF = 0x00;             
0D76  018C     CLRF PIR0
1512:              delay();        
0D77  319C     MOVLP 0x1C
1513:              SSP1IF = 0;                 
0D7A  002E     MOVLB 0xE
1514:              image_packet[118] = SSP1BUF;
0D7C  30C2     MOVLW 0xC2
1515:              SSP1BUF = 0x00;             
0D83  018C     CLRF PIR0
1516:              delay();       
0D84  319C     MOVLP 0x1C
1517:              SSP1IF = 0;                 
0D87  002E     MOVLB 0xE
1518:              image_packet[119] = SSP1BUF;
0D89  30C3     MOVLW 0xC3
1519:              SSP1BUF = 0x00;             
0D90  018C     CLRF PIR0
1520:              delay();        
0D91  319C     MOVLP 0x1C
1521:              SSP1IF = 0;                 
0D94  002E     MOVLB 0xE
1522:              image_packet[120] = SSP1BUF;
0D96  30C4     MOVLW 0xC4
1523:              SSP1BUF = 0x00;             
0D9D  018C     CLRF PIR0
1524:              delay();        
0D9E  319C     MOVLP 0x1C
1525:              SSP1IF = 0;                 
0DA1  002E     MOVLB 0xE
1526:              image_packet[121] = SSP1BUF;
0DA3  30C5     MOVLW 0xC5
1527:              SSP1BUF = 0x00;             
0DAA  018C     CLRF PIR0
1528:              delay();        
0DAB  319C     MOVLP 0x1C
1529:              SSP1IF = 0;                 
0DAE  002E     MOVLB 0xE
1530:              image_packet[122] = SSP1BUF;
0DB0  30C6     MOVLW 0xC6
1531:              SSP1BUF = 0x00;             
0DB7  018C     CLRF PIR0
1532:              delay();        
0DB8  319C     MOVLP 0x1C
1533:              SSP1IF = 0;                 
0DBB  002E     MOVLB 0xE
1534:              image_packet[123] = SSP1BUF;
0DBD  30C7     MOVLW 0xC7
1535:              SSP1BUF = 0x00;             
0DC4  018C     CLRF PIR0
1536:              delay();        
0DC5  319C     MOVLP 0x1C
1537:              SSP1IF = 0;                 
0DC8  002E     MOVLB 0xE
1538:              image_packet[124] = SSP1BUF;
0DCA  30C8     MOVLW 0xC8
1539:              SSP1BUF = 0x00;             
0DD1  018C     CLRF PIR0
1540:              delay();        
0DD2  319C     MOVLP 0x1C
1541:              SSP1IF = 0;                 
0DD5  002E     MOVLB 0xE
1542:              image_packet[125] = SSP1BUF;
0DD7  30C9     MOVLW 0xC9
1543:              SSP1BUF = 0x00;             
0DDE  018C     CLRF PIR0
1544:              delay();        
0DDF  319C     MOVLP 0x1C
1545:              SSP1IF = 0;                 
0DE2  002E     MOVLB 0xE
1546:              image_packet[126] = SSP1BUF;
0DE4  30CA     MOVLW 0xCA
1547:              SSP1BUF = 0x00;             
0DEB  018C     CLRF PIR0
1548:              delay();        
0DEC  319C     MOVLP 0x1C
1549:              SSP1IF = 0;                 
0DEF  002E     MOVLB 0xE
1550:              image_packet[127] = SSP1BUF;
0DF1  30CB     MOVLW 0xCB
1551:              SSP1BUF = 0x00;             
0DF8  018C     CLRF PIR0
1552:              delay();        
0DF9  319C     MOVLP 0x1C
1553:              SSP1IF = 0;                 
0DFC  002E     MOVLB 0xE
1554:              image_packet[128] = SSP1BUF;
0DFE  30CC     MOVLW 0xCC
1555:              SSP1BUF = 0x00;             
0E05  018C     CLRF PIR0
1556:              delay();        
0E06  319C     MOVLP 0x1C
1557:              SSP1IF = 0;                 
0E09  002E     MOVLB 0xE
1558:              image_packet[129] = SSP1BUF;
0E0B  30CD     MOVLW 0xCD
1559:              SSP1BUF = 0x00;             
0E12  018C     CLRF PIR0
1560:              delay();        
0E13  319C     MOVLP 0x1C
1561:              SSP1IF = 0;                 
0E16  002E     MOVLB 0xE
1562:              image_packet[130] = SSP1BUF;
0E18  30CE     MOVLW 0xCE
1563:              SSP1BUF = 0x00;             
0E1F  018C     CLRF PIR0
1564:              delay();        
0E20  319C     MOVLP 0x1C
1565:              SSP1IF = 0;                 
0E23  002E     MOVLB 0xE
1566:              image_packet[131] = SSP1BUF;
0E25  30CF     MOVLW 0xCF
1567:              SSP1BUF = 0x00;             
0E2C  018C     CLRF PIR0
1568:              delay();        
0E2D  319C     MOVLP 0x1C
1569:              SSP1IF = 0;                 
0E30  002E     MOVLB 0xE
1570:              image_packet[132] = SSP1BUF;
0E32  30D0     MOVLW 0xD0
1571:              SSP1BUF = 0x00;             
0E39  018C     CLRF PIR0
1572:              delay();        
0E3A  319C     MOVLP 0x1C
1573:              SSP1IF = 0;                 
0E3D  002E     MOVLB 0xE
1574:              image_packet[133] = SSP1BUF;
0E3F  30D1     MOVLW 0xD1
1575:              SSP1BUF = 0x00;             
0E46  018C     CLRF PIR0
1576:              delay();        
0E47  319C     MOVLP 0x1C
1577:             SSP1IF = 0;                 
0E4A  002E     MOVLB 0xE
1578:              image_packet[134] = SSP1BUF;
0E4C  30D2     MOVLW 0xD2
1579:              SSP1BUF = 0x00;             
0E53  018C     CLRF PIR0
1580:              delay();        
0E54  319C     MOVLP 0x1C
1581:              SSP1IF = 0;                 
0E57  002E     MOVLB 0xE
1582:              image_packet[135] = SSP1BUF;
0E59  30D3     MOVLW 0xD3
1583:              SSP1BUF = 0x00;             
0E60  018C     CLRF PIR0
1584:              delay();        
0E61  319C     MOVLP 0x1C
1585:              SSP1IF = 0;                 
0E64  002E     MOVLB 0xE
1586:              image_packet[136] = SSP1BUF;
0E66  30D4     MOVLW 0xD4
1587:              SSP1BUF = 0x00;             
0E6D  018C     CLRF PIR0
1588:              delay();        
0E6E  319C     MOVLP 0x1C
1589:              SSP1IF = 0;                 
0E71  002E     MOVLB 0xE
1590:              image_packet[137] = SSP1BUF;
0E73  30D5     MOVLW 0xD5
1591:              SSP1BUF = 0x00;             
0E7A  018C     CLRF PIR0
1592:              delay();        
0E7B  319C     MOVLP 0x1C
1593:              SSP1IF = 0;                 
0E7E  002E     MOVLB 0xE
1594:              image_packet[138] = SSP1BUF;
0E80  30D6     MOVLW 0xD6
1595:              SSP1BUF = 0x00;             
0E87  018C     CLRF PIR0
1596:              delay();        
0E88  319C     MOVLP 0x1C
1597:              SSP1IF = 0;                 
0E8B  002E     MOVLB 0xE
1598:              image_packet[139] = SSP1BUF;
0E8D  30D7     MOVLW 0xD7
1599:              SSP1BUF = 0x00;             
0E94  018C     CLRF PIR0
1600:              delay();        
0E95  319C     MOVLP 0x1C
1601:              SSP1IF = 0;                 
0E98  002E     MOVLB 0xE
1602:              image_packet[140] = SSP1BUF;
0E9A  30D8     MOVLW 0xD8
1603:              SSP1BUF = 0x00;             
0EA1  018C     CLRF PIR0
1604:              delay();        
0EA2  319C     MOVLP 0x1C
1605:              SSP1IF = 0;                 
0EA5  002E     MOVLB 0xE
1606:              image_packet[141] = SSP1BUF;
0EA7  30D9     MOVLW 0xD9
1607:              SSP1BUF = 0x00;             
0EAE  018C     CLRF PIR0
1608:              delay();        
0EAF  319C     MOVLP 0x1C
1609:             SSP1IF = 0;                 
0EB2  002E     MOVLB 0xE
1610:              image_packet[142] = SSP1BUF;
0EB4  30DA     MOVLW 0xDA
1611:              SSP1BUF = 0x00;             
0EBB  018C     CLRF PIR0
1612:              delay();       
0EBC  319C     MOVLP 0x1C
1613:              SSP1IF = 0;                 
0EBF  002E     MOVLB 0xE
1614:              image_packet[143] = SSP1BUF;
0EC1  30DB     MOVLW 0xDB
1615:              SSP1BUF = 0x00;             
0EC8  018C     CLRF PIR0
1616:              delay();        
0EC9  319C     MOVLP 0x1C
1617:              SSP1IF = 0;                 
0ECC  002E     MOVLB 0xE
1618:              image_packet[144] = SSP1BUF;
0ECE  30DC     MOVLW 0xDC
1619:              SSP1BUF = 0x00;             
0ED5  018C     CLRF PIR0
1620:              delay();        
0ED6  319C     MOVLP 0x1C
1621:              SSP1IF = 0;                 
0ED9  002E     MOVLB 0xE
1622:              image_packet[145] = SSP1BUF;
0EDB  30DD     MOVLW 0xDD
1623:              SSP1BUF = 0x00;             
0EE2  018C     CLRF PIR0
1624:              delay();        
0EE3  319C     MOVLP 0x1C
1625:              SSP1IF = 0;                 
0EE6  002E     MOVLB 0xE
1626:              image_packet[146] = SSP1BUF;
0EE8  30DE     MOVLW 0xDE
1627:              SSP1BUF = 0x00;             
0EEF  018C     CLRF PIR0
1628:              delay();        
0EF0  319C     MOVLP 0x1C
1629:              SSP1IF = 0;                 
0EF3  002E     MOVLB 0xE
1630:              image_packet[147] = SSP1BUF;
0EF5  30DF     MOVLW 0xDF
1631:              SSP1BUF = 0x00;             
0EFC  018C     CLRF PIR0
1632:              delay();        
0EFD  319C     MOVLP 0x1C
1633:              SSP1IF = 0;                 
0F00  002E     MOVLB 0xE
1634:              image_packet[148] = SSP1BUF;
0F02  30E0     MOVLW 0xE0
1635:              SSP1BUF = 0x00;             
0F09  018C     CLRF PIR0
1636:              delay();       
0F0A  319C     MOVLP 0x1C
1637:              SSP1IF = 0;                 
0F0D  002E     MOVLB 0xE
1638:              image_packet[149] = SSP1BUF;
0F0F  30E1     MOVLW 0xE1
1639:              SSP1BUF = 0x00;             
0F16  018C     CLRF PIR0
1640:              delay();        
0F17  319C     MOVLP 0x1C
1641:              SSP1IF = 0;                 
0F1A  002E     MOVLB 0xE
1642:              image_packet[150] = SSP1BUF;
0F1C  30E2     MOVLW 0xE2
1643:              SSP1BUF = 0x00;             
0F23  018C     CLRF PIR0
1644:              delay();        
0F24  319C     MOVLP 0x1C
1645:              SSP1IF = 0;                 
0F27  002E     MOVLB 0xE
1646:              image_packet[151] = SSP1BUF;
0F29  30E3     MOVLW 0xE3
1647:              SSP1BUF = 0x00;             
0F30  018C     CLRF PIR0
1648:              delay();        
0F31  319C     MOVLP 0x1C
1649:              SSP1IF = 0;                 
0F34  002E     MOVLB 0xE
1650:              image_packet[152] = SSP1BUF;
0F36  30E4     MOVLW 0xE4
1651:              SSP1BUF = 0x00;             
0F3D  018C     CLRF PIR0
1652:              delay();        
0F3E  319C     MOVLP 0x1C
1653:             SSP1IF = 0;                 
0F41  002E     MOVLB 0xE
1654:              image_packet[153] = SSP1BUF;
0F43  30E5     MOVLW 0xE5
1655:              SSP1BUF = 0x00;             
0F4A  018C     CLRF PIR0
1656:              delay();        
0F4B  319C     MOVLP 0x1C
1657:              SSP1IF = 0;                 
0F4E  002E     MOVLB 0xE
1658:              image_packet[154] = SSP1BUF;
0F50  30E6     MOVLW 0xE6
1659:              SSP1BUF = 0x00;             
0F57  018C     CLRF PIR0
1660:              delay();        
0F58  319C     MOVLP 0x1C
1661:              SSP1IF = 0;                 
0F5B  002E     MOVLB 0xE
1662:              image_packet[155] = SSP1BUF;
0F5D  30E7     MOVLW 0xE7
1663:              SSP1BUF = 0x00;             
0F64  018C     CLRF PIR0
1664:              delay();        
0F65  319C     MOVLP 0x1C
1665:             SSP1IF = 0;                 
0F68  002E     MOVLB 0xE
1666:              image_packet[156] = SSP1BUF;
0F6A  30E8     MOVLW 0xE8
1667:              SSP1BUF = 0x00;             
0F71  018C     CLRF PIR0
1668:              delay();        
0F72  319C     MOVLP 0x1C
1669:             SSP1IF = 0;                 
0F75  002E     MOVLB 0xE
1670:              image_packet[157] = SSP1BUF;
0F77  30E9     MOVLW 0xE9
1671:              SSP1BUF = 0x00;             
0F7E  018C     CLRF PIR0
1672:              delay();       
0F7F  319C     MOVLP 0x1C
1673:             SSP1IF = 0;                 
0F82  002E     MOVLB 0xE
1674:              image_packet[158] = SSP1BUF;
0F84  30EA     MOVLW 0xEA
1675:              SSP1BUF = 0x00;             
0F8B  018C     CLRF PIR0
1676:              delay();        
0F8C  319C     MOVLP 0x1C
1677:              SSP1IF = 0;                 
0F8F  002E     MOVLB 0xE
1678:              image_packet[159] = SSP1BUF;
0F91  30EB     MOVLW 0xEB
1679:              SSP1BUF = 0x00;             
0F98  018C     CLRF PIR0
1680:              delay();        
0F99  319C     MOVLP 0x1C
1681:              SSP1IF = 0;                 
0F9C  002E     MOVLB 0xE
1682:              image_packet[160] = SSP1BUF;
0F9E  30EC     MOVLW 0xEC
1683:              SSP1BUF = 0x00;             
0FA5  018C     CLRF PIR0
1684:              delay();        
0FA6  319C     MOVLP 0x1C
1685:             SSP1IF = 0;                 
0FA9  002E     MOVLB 0xE
1686:              image_packet[161] = SSP1BUF;
0FAB  30ED     MOVLW 0xED
1687:              SSP1BUF = 0x00;             
0FB2  018C     CLRF PIR0
1688:              delay();        
0FB3  319C     MOVLP 0x1C
1689:              SSP1IF = 0;                 
0FB6  002E     MOVLB 0xE
1690:              image_packet[162] = SSP1BUF;
0FB8  30EE     MOVLW 0xEE
1691:              SSP1BUF = 0x00;             
0FBF  018C     CLRF PIR0
1692:              delay();        
0FC0  319C     MOVLP 0x1C
1693:              SSP1IF = 0;                 
0FC3  002E     MOVLB 0xE
1694:              image_packet[163] = SSP1BUF;
0FC5  30EF     MOVLW 0xEF
1695:              
1696:              //De-assert the CS pin so next byte is not received until
1697:              //pin is asserted again - CMH
1698:              PORTCbits.RC0 = 1;
0FCC  0020     MOVLB 0x0
1699:              
1700:              //If the first byte of data says the entire packet is a discard packet - CMH
1701:              if((image_packet[0]&0x0F) == 0x0F){
0FCE  304C     MOVLW 0x4C
1702:                  discard = 1;        //Set the discard flag - CMH
0FD9  01B2     CLRF discard
1703:                  num_discard++;      //Increment the number of discard packets - CMH
0FDB  3001     MOVLW 0x1
1704:                  packet_index = -1;  //set packet index to -1 so next real packet can
0FDF  30FF     MOVLW 0xFF
1705:                                      //have the index of 0 when incremented below - CMH
1706:              }
0FE3  2FED     GOTO 0x7ED
1707:              //If it is not a discard packet - CMH
1708:              else{
1709:                  num_discard = 0;        //Reset the number of discarded packets - CMH
0FE4  01B1     CLRF num_discard
1710:                  packet_index++;         //increment to the current index - CMH
0FE5  3001     MOVLW 0x1
1711:                  if( packet_index > 59){ //If the index is incremented past the
0FE9  303C     MOVLW 0x3C
1712:                      packet_index = 0;   //final index, set back to 0 - CMH
0FEC  01BA     CLRF packet_index
1713:                  }
1714:              }
1715:              
1716:              //If there has been more than 150 discarded packets in a row,
1717:              //wait for two seconds so the FLIR VoSPI can reset itself.
1718:              //Also reset the number of discarded packets to 0 - CMH
1719:              if(num_discard > 150){
0FED  3097     MOVLW 0x97
1720:                  __delay_ms(2000);
0FF1  3052     MOVLW 0x52
1721:                  num_discard = 0;
0FFD  0020     MOVLB 0x0
1722:              }
1723:              
1724:          }
1725:          
1726:          
1727:          
1728:          
---  C:/Users/cmh52/Desktop/SeniorDesign.X/lepton.c  ----------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: lepton.c
8:              * 
9:              * Date Created: 1/14/19
10:             * 
11:             * Revision Date: 2/11/19
12:             * 
13:             * Revision: 1.00
14:             */
15:            
16:            #include "lepton.h"
17:            #include "serial_i2c.h"
18:            
19:            
20:            // ************************************************************
21:            //
22:            //  This function initializes the necessary settings within
23:            //  the FLIR Lepton Thermal Camera through the I2C bus. Due
24:            //  to many of the settings needed being default within the
25:            //  Lepton like Telemetry disabled, Radiometry disabled, and 
26:            //  it being unnecessary to run Far Field Correction (FFC),
27:            //  the only AGC feature needs to be enabled on the Lepton.
28:            //
29:            // ************************************************************
30:            void lepton_initialize(){
31:                
32:                //Enable the AGC - CMH
33:                i2c_start();
1013  319C     MOVLP 0x1C
1014  2480     CALL 0x480
1015  3190     MOVLP 0x10
34:                i2c_write(0x2A);    //Device Address - CMH
1016  302A     MOVLW 0x2A
1017  3180     MOVLP 0x0
1018  2004     CALL 0x4
1019  3190     MOVLP 0x10
35:                i2c_write(0x01);    //AGC Address - CMH
101A  3001     MOVLW 0x1
101B  3180     MOVLP 0x0
101C  2004     CALL 0x4
101D  3190     MOVLP 0x10
36:                i2c_write(0x05);    //Write Command - CMH
101E  3005     MOVLW 0x5
101F  3180     MOVLP 0x0
1020  2004     CALL 0x4
1021  3190     MOVLP 0x10
37:                i2c_write(0x00);    //Enable AGC with 8-bit compression (1) - CMH
1022  3000     MOVLW 0x0
1023  3180     MOVLP 0x0
1024  2004     CALL 0x4
1025  3190     MOVLP 0x10
38:                i2c_write(0x01);    //Enable AGC with 8-bit compression (2) - CMH
1026  3001     MOVLW 0x1
1027  3180     MOVLP 0x0
1028  2004     CALL 0x4
1029  3190     MOVLP 0x10
39:                i2c_stop();
102A  319C     MOVLP 0x1C
102B  2485     CALL 0x485
40:                
41:                //Telemetry is default disabled - CMH
42:                
43:                //Radiometry is default diabled - CMH
44:                
45:                //FFC does not need to run - CMH
46:            }
102C  0008     RETURN
---  C:/Users/cmh52/Desktop/SeniorDesign.X/gnss5.c  -----------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: gnss5.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 0.01
12:             */
13:            
14:            #include "gnss5.h"
15:            
16:            // ************************************************************
17:            //
18:            //  This function acquires the current coordinates from the 
19:            //  GNSS 5 Click module.
20:            //
21:            // ************************************************************
22:            void gnss5_acquire(void){
23:                
24:            }
1C7F  0008     RETURN
---  C:/Users/cmh52/Desktop/SeniorDesign.X/eth_wiz.c  ---------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: eth_wiz.c
8:              * 
9:              * Date Created: 1/14/19
10:             * 
11:             * Revision Date: 3/5/19
12:             * 
13:             * Revision: 0.04
14:             */
15:            
16:            #include <xc.h>
17:            #include <stdio.h>
18:            #include <stdlib.h>
19:            #include <stdint.h>
20:            #include <stdbool.h>
21:            #include "config.h"
22:            #include "eth_wiz.h"
23:            #include "serial_spi.h"
24:            
25:            //Control Phase value for block and R/W selection in ETH WIZ - CMH
26:            uint8_t common_reg_write = 0b00000100;
27:            uint8_t common_reg_read  = 0b00000000;
28:            uint8_t s0_reg_write     = 0b00001100;
29:            uint8_t s0_reg_read      = 0b00001000;
30:            uint8_t s0_tx_buf_write  = 0b00010100;
31:            uint8_t s0_tx_buf_read   = 0b00010000;
32:            uint8_t s0_rx_buf_write  = 0b00011100;
33:            uint8_t s0_rx_buf_read    = 0b00011000;
34:            
35:            //Variables for pointer registers of TX and RX - CMH
36:            uint8_t s0_tx_pointer_high = 0x00;
37:            uint8_t s0_tx_pointer_low = 0x00;
38:            uint8_t s0_rx_readpointer_high = 0x00;
39:            uint8_t s0_rx_readpointer_low = 0x00;
40:            uint8_t s0_rx_writepointer_high = 0x00;
41:            uint8_t s0_rx_writepointer_low = 0x00;
42:            uint8_t s0_rx_datalength_high = 0x00;
43:            uint8_t s0_rx_datalength_low = 0x00;
44:            uint8_t s0_SR_check = 0x00;
45:            uint8_t s0_IR_check = 0x00;
46:            
47:            
48:            // ************************************************************
49:            //
50:            //  This function configures the proper settings on the W5500
51:            //  (the chipset on the ETH WIZ Click). See comments below to 
52:            //  see the exact settings for each register. Overall setup is
53:            //  for TCP through Socket 0.
54:            //
55:            // ************************************************************
56:            void eth_wiz_configure(void){
57:                
58:                /*
59:                 * Start of the Common Registers set up
60:                 */
61:                
62:                //Mode Register - Wake on LAN disabled, Pinf Block Mode enabled,
63:                //PPPoE mode disabled, and Force ARP disabled - CMH
64:                PORTDbits.RD3 = 0;
15DB  0020     MOVLB 0x0
15DC  118F     BCF PORTD, 0x3
65:                SPI_ETHWIZ_Write(0x00);
15DD  3000     MOVLW 0x0
15DE  319C     MOVLP 0x1C
15DF  24B4     CALL 0x4B4
15E0  3195     MOVLP 0x15
66:                SPI_ETHWIZ_Write(0x00); //Address = 0x0000
15E1  3000     MOVLW 0x0
15E2  319C     MOVLP 0x1C
15E3  24B4     CALL 0x4B4
15E4  3195     MOVLP 0x15
67:                SPI_ETHWIZ_Write(common_reg_write);
15E5  0020     MOVLB 0x0
15E6  0839     MOVF common_reg_write, W
15E7  319C     MOVLP 0x1C
15E8  24B4     CALL 0x4B4
15E9  3195     MOVLP 0x15
68:                SPI_ETHWIZ_Write(0b00010000);
15EA  3010     MOVLW 0x10
15EB  319C     MOVLP 0x1C
15EC  24B4     CALL 0x4B4
15ED  3195     MOVLP 0x15
69:                PORTDbits.RD3 = 1;
15EE  0020     MOVLB 0x0
15EF  158F     BSF PORTD, 0x3
70:                __delay_ms(1);
15F0  300B     MOVLW 0xB
15F1  00F1     MOVWF i2cWriteData
15F2  3062     MOVLW 0x62
15F3  0B89     DECFSZ WREG, F
15F4  2DF3     GOTO 0x5F3
15F5  0BF1     DECFSZ i2cWriteData, F
15F6  2DF3     GOTO 0x5F3
15F7  3200     BRA 0x15F8
71:                
72:                //Set the Gateway IP Address to 10.0.0.254 - CMH
73:                PORTDbits.RD3 = 0;
15F8  0020     MOVLB 0x0
15F9  118F     BCF PORTD, 0x3
74:                SPI_ETHWIZ_Write(0x00);
15FA  3000     MOVLW 0x0
15FB  319C     MOVLP 0x1C
15FC  24B4     CALL 0x4B4
15FD  3195     MOVLP 0x15
75:                SPI_ETHWIZ_Write(0x01); //Start Address = 0x0001
15FE  3001     MOVLW 0x1
15FF  319C     MOVLP 0x1C
1600  24B4     CALL 0x4B4
1601  3195     MOVLP 0x15
76:                SPI_ETHWIZ_Write(common_reg_write);
1602  0020     MOVLB 0x0
1603  0839     MOVF common_reg_write, W
1604  319C     MOVLP 0x1C
1605  24B4     CALL 0x4B4
1606  3195     MOVLP 0x15
77:                SPI_ETHWIZ_Write(0x0A); //10
1607  300A     MOVLW 0xA
1608  319C     MOVLP 0x1C
1609  24B4     CALL 0x4B4
160A  3195     MOVLP 0x15
78:                SPI_ETHWIZ_Write(0x00); //0
160B  3000     MOVLW 0x0
160C  319C     MOVLP 0x1C
160D  24B4     CALL 0x4B4
160E  3195     MOVLP 0x15
79:                SPI_ETHWIZ_Write(0x00); //0
160F  3000     MOVLW 0x0
1610  319C     MOVLP 0x1C
1611  24B4     CALL 0x4B4
1612  3195     MOVLP 0x15
80:                SPI_ETHWIZ_Write(0xFE); //254
1613  30FE     MOVLW 0xFE
1614  319C     MOVLP 0x1C
1615  24B4     CALL 0x4B4
1616  3195     MOVLP 0x15
81:                PORTDbits.RD3 = 1;
1617  0020     MOVLB 0x0
1618  158F     BSF PORTD, 0x3
82:                __delay_ms(1);
1619  300B     MOVLW 0xB
161A  00F1     MOVWF i2cWriteData
161B  3062     MOVLW 0x62
161C  0B89     DECFSZ WREG, F
161D  2E1C     GOTO 0x61C
161E  0BF1     DECFSZ i2cWriteData, F
161F  2E1C     GOTO 0x61C
1620  3200     BRA 0x1621
83:            
84:                //Set the Subnet Mask address to 255.255.0.0 - CMH
85:                PORTDbits.RD3 = 0;
1621  0020     MOVLB 0x0
1622  118F     BCF PORTD, 0x3
86:                SPI_ETHWIZ_Write(0x00);
1623  3000     MOVLW 0x0
1624  319C     MOVLP 0x1C
1625  24B4     CALL 0x4B4
1626  3195     MOVLP 0x15
87:                SPI_ETHWIZ_Write(0x05); //Start Address = 0x0005
1627  3005     MOVLW 0x5
1628  319C     MOVLP 0x1C
1629  24B4     CALL 0x4B4
162A  3195     MOVLP 0x15
88:                SPI_ETHWIZ_Write(common_reg_write);
162B  0020     MOVLB 0x0
162C  0839     MOVF common_reg_write, W
162D  319C     MOVLP 0x1C
162E  24B4     CALL 0x4B4
162F  3195     MOVLP 0x15
89:                SPI_ETHWIZ_Write(0xFF); //255
1630  30FF     MOVLW 0xFF
1631  319C     MOVLP 0x1C
1632  24B4     CALL 0x4B4
1633  3195     MOVLP 0x15
90:                SPI_ETHWIZ_Write(0xFF); //255
1634  30FF     MOVLW 0xFF
1635  319C     MOVLP 0x1C
1636  24B4     CALL 0x4B4
1637  3195     MOVLP 0x15
91:                SPI_ETHWIZ_Write(0x00); //0
1638  3000     MOVLW 0x0
1639  319C     MOVLP 0x1C
163A  24B4     CALL 0x4B4
163B  3195     MOVLP 0x15
92:                SPI_ETHWIZ_Write(0x00); //0
163C  3000     MOVLW 0x0
163D  319C     MOVLP 0x1C
163E  24B4     CALL 0x4B4
163F  3195     MOVLP 0x15
93:                PORTDbits.RD3 = 1;
1640  0020     MOVLB 0x0
1641  158F     BSF PORTD, 0x3
94:                __delay_ms(1);
1642  300B     MOVLW 0xB
1643  00F1     MOVWF i2cWriteData
1644  3062     MOVLW 0x62
1645  0B89     DECFSZ WREG, F
1646  2E45     GOTO 0x645
1647  0BF1     DECFSZ i2cWriteData, F
1648  2E45     GOTO 0x645
1649  3200     BRA 0x164A
95:                
96:                //Set the Source Hardware Address address to 00.21.74.08.36.85 - CMH
97:                PORTDbits.RD3 = 0;
164A  0020     MOVLB 0x0
164B  118F     BCF PORTD, 0x3
98:                SPI_ETHWIZ_Write(0x00);
164C  3000     MOVLW 0x0
164D  319C     MOVLP 0x1C
164E  24B4     CALL 0x4B4
164F  3195     MOVLP 0x15
99:                SPI_ETHWIZ_Write(0x09); //Start Address = 0x0009
1650  3009     MOVLW 0x9
1651  319C     MOVLP 0x1C
1652  24B4     CALL 0x4B4
1653  3195     MOVLP 0x15
100:               SPI_ETHWIZ_Write(common_reg_write);
1654  0020     MOVLB 0x0
1655  0839     MOVF common_reg_write, W
1656  319C     MOVLP 0x1C
1657  24B4     CALL 0x4B4
1658  3195     MOVLP 0x15
101:               SPI_ETHWIZ_Write(0x00); //00
1659  3000     MOVLW 0x0
165A  319C     MOVLP 0x1C
165B  24B4     CALL 0x4B4
165C  3195     MOVLP 0x15
102:               SPI_ETHWIZ_Write(0x21); //21
165D  3021     MOVLW 0x21
165E  319C     MOVLP 0x1C
165F  24B4     CALL 0x4B4
1660  3195     MOVLP 0x15
103:               SPI_ETHWIZ_Write(0x74); //74
1661  3074     MOVLW 0x74
1662  319C     MOVLP 0x1C
1663  24B4     CALL 0x4B4
1664  3195     MOVLP 0x15
104:               SPI_ETHWIZ_Write(0x08); //08
1665  3008     MOVLW 0x8
1666  319C     MOVLP 0x1C
1667  24B4     CALL 0x4B4
1668  3195     MOVLP 0x15
105:               SPI_ETHWIZ_Write(0x36); //36
1669  3036     MOVLW 0x36
166A  319C     MOVLP 0x1C
166B  24B4     CALL 0x4B4
166C  3195     MOVLP 0x15
106:               SPI_ETHWIZ_Write(0x85); //85
166D  3085     MOVLW 0x85
166E  319C     MOVLP 0x1C
166F  24B4     CALL 0x4B4
1670  3195     MOVLP 0x15
107:               PORTDbits.RD3 = 1;
1671  0020     MOVLB 0x0
1672  158F     BSF PORTD, 0x3
108:               __delay_ms(1);
1673  300B     MOVLW 0xB
1674  00F1     MOVWF i2cWriteData
1675  3062     MOVLW 0x62
1676  0B89     DECFSZ WREG, F
1677  2E76     GOTO 0x676
1678  0BF1     DECFSZ i2cWriteData, F
1679  2E76     GOTO 0x676
167A  3200     BRA 0x167B
109:               
110:               //Set the Source IP address to 10.0.0.2 - CMH
111:               PORTDbits.RD3 = 0;
167B  0020     MOVLB 0x0
167C  118F     BCF PORTD, 0x3
112:               SPI_ETHWIZ_Write(0x00);
167D  3000     MOVLW 0x0
167E  319C     MOVLP 0x1C
167F  24B4     CALL 0x4B4
1680  3195     MOVLP 0x15
113:               SPI_ETHWIZ_Write(0x0F); //Start Address = 0x000F
1681  300F     MOVLW 0xF
1682  319C     MOVLP 0x1C
1683  24B4     CALL 0x4B4
1684  3195     MOVLP 0x15
114:               SPI_ETHWIZ_Write(common_reg_write);
1685  0020     MOVLB 0x0
1686  0839     MOVF common_reg_write, W
1687  319C     MOVLP 0x1C
1688  24B4     CALL 0x4B4
1689  3195     MOVLP 0x15
115:               SPI_ETHWIZ_Write(0x0A); //10
168A  300A     MOVLW 0xA
168B  319C     MOVLP 0x1C
168C  24B4     CALL 0x4B4
168D  3195     MOVLP 0x15
116:               SPI_ETHWIZ_Write(0x00); //0
168E  3000     MOVLW 0x0
168F  319C     MOVLP 0x1C
1690  24B4     CALL 0x4B4
1691  3195     MOVLP 0x15
117:               SPI_ETHWIZ_Write(0x00); //0
1692  3000     MOVLW 0x0
1693  319C     MOVLP 0x1C
1694  24B4     CALL 0x4B4
1695  3195     MOVLP 0x15
118:               SPI_ETHWIZ_Write(0x02); //2
1696  3002     MOVLW 0x2
1697  319C     MOVLP 0x1C
1698  24B4     CALL 0x4B4
1699  3195     MOVLP 0x15
119:               PORTDbits.RD3 = 1;
169A  0020     MOVLB 0x0
169B  158F     BSF PORTD, 0x3
120:               __delay_ms(1);
169C  300B     MOVLW 0xB
169D  00F1     MOVWF i2cWriteData
169E  3062     MOVLW 0x62
169F  0B89     DECFSZ WREG, F
16A0  2E9F     GOTO 0x69F
16A1  0BF1     DECFSZ i2cWriteData, F
16A2  2E9F     GOTO 0x69F
16A3  3200     BRA 0x16A4
121:               
122:               //Set the Destination unreachable interrupt mask to enabled - CMH
123:               PORTDbits.RD3 = 0;
16A4  0020     MOVLB 0x0
16A5  118F     BCF PORTD, 0x3
124:               SPI_ETHWIZ_Write(0x00);
16A6  3000     MOVLW 0x0
16A7  319C     MOVLP 0x1C
16A8  24B4     CALL 0x4B4
16A9  3195     MOVLP 0x15
125:               SPI_ETHWIZ_Write(0x15); //Address = 0x0015
16AA  3015     MOVLW 0x15
16AB  319C     MOVLP 0x1C
16AC  24B4     CALL 0x4B4
16AD  3195     MOVLP 0x15
126:               SPI_ETHWIZ_Write(common_reg_write);
16AE  0020     MOVLB 0x0
16AF  0839     MOVF common_reg_write, W
16B0  319C     MOVLP 0x1C
16B1  24B4     CALL 0x4B4
16B2  3195     MOVLP 0x15
127:               SPI_ETHWIZ_Write(0b01000000);
16B3  3040     MOVLW 0x40
16B4  319C     MOVLP 0x1C
16B5  24B4     CALL 0x4B4
16B6  3195     MOVLP 0x15
128:               PORTDbits.RD3 = 1;
16B7  0020     MOVLB 0x0
16B8  158F     BSF PORTD, 0x3
129:               __delay_ms(1);
16B9  300B     MOVLW 0xB
16BA  00F1     MOVWF i2cWriteData
16BB  3062     MOVLW 0x62
16BC  0B89     DECFSZ WREG, F
16BD  2EBC     GOTO 0x6BC
16BE  0BF1     DECFSZ i2cWriteData, F
16BF  2EBC     GOTO 0x6BC
16C0  3200     BRA 0x16C1
130:               
131:               //Enable the Socket 0 and disable all other sockets - CMH
132:               PORTDbits.RD3 = 0;
16C1  0020     MOVLB 0x0
16C2  118F     BCF PORTD, 0x3
133:               SPI_ETHWIZ_Write(0x00);
16C3  3000     MOVLW 0x0
16C4  319C     MOVLP 0x1C
16C5  24B4     CALL 0x4B4
16C6  3195     MOVLP 0x15
134:               SPI_ETHWIZ_Write(0x18); //Address = 0x0018
16C7  3018     MOVLW 0x18
16C8  319C     MOVLP 0x1C
16C9  24B4     CALL 0x4B4
16CA  3195     MOVLP 0x15
135:               SPI_ETHWIZ_Write(common_reg_write);
16CB  0020     MOVLB 0x0
16CC  0839     MOVF common_reg_write, W
16CD  319C     MOVLP 0x1C
16CE  24B4     CALL 0x4B4
16CF  3195     MOVLP 0x15
136:               SPI_ETHWIZ_Write(0b00000001);
16D0  3001     MOVLW 0x1
16D1  319C     MOVLP 0x1C
16D2  24B4     CALL 0x4B4
16D3  3195     MOVLP 0x15
137:               PORTDbits.RD3 = 1;
16D4  0020     MOVLB 0x0
16D5  158F     BSF PORTD, 0x3
138:               __delay_ms(1);
16D6  300B     MOVLW 0xB
16D7  00F1     MOVWF i2cWriteData
16D8  3062     MOVLW 0x62
16D9  0B89     DECFSZ WREG, F
16DA  2ED9     GOTO 0x6D9
16DB  0BF1     DECFSZ i2cWriteData, F
16DC  2ED9     GOTO 0x6D9
16DD  3200     BRA 0x16DE
139:               
140:               //Set Retry Count Register to 0 (=RCR+1) - CMH
141:               PORTDbits.RD3 = 0;
16DE  0020     MOVLB 0x0
16DF  118F     BCF PORTD, 0x3
142:               SPI_ETHWIZ_Write(0x00);
16E0  3000     MOVLW 0x0
16E1  319C     MOVLP 0x1C
16E2  24B4     CALL 0x4B4
16E3  3195     MOVLP 0x15
143:               SPI_ETHWIZ_Write(0x1B); //Address = 0x001B
16E4  301B     MOVLW 0x1B
16E5  319C     MOVLP 0x1C
16E6  24B4     CALL 0x4B4
16E7  3195     MOVLP 0x15
144:               SPI_ETHWIZ_Write(common_reg_write);
16E8  0020     MOVLB 0x0
16E9  0839     MOVF common_reg_write, W
16EA  319C     MOVLP 0x1C
16EB  24B4     CALL 0x4B4
16EC  3195     MOVLP 0x15
145:               SPI_ETHWIZ_Write(0b00000000);
16ED  3000     MOVLW 0x0
16EE  319C     MOVLP 0x1C
16EF  24B4     CALL 0x4B4
16F0  3195     MOVLP 0x15
146:               PORTDbits.RD3 = 1;
16F1  0020     MOVLB 0x0
16F2  158F     BSF PORTD, 0x3
147:               __delay_ms(1);
16F3  300B     MOVLW 0xB
16F4  00F1     MOVWF i2cWriteData
16F5  3062     MOVLW 0x62
16F6  0B89     DECFSZ WREG, F
16F7  2EF6     GOTO 0x6F6
16F8  0BF1     DECFSZ i2cWriteData, F
16F9  2EF6     GOTO 0x6F6
16FA  3200     BRA 0x16FB
148:               
149:               //Set the Physical Operation Mode to all capable - CMH
150:               PORTDbits.RD3 = 0;
16FB  0020     MOVLB 0x0
16FC  118F     BCF PORTD, 0x3
151:               SPI_ETHWIZ_Write(0x00);
16FD  3000     MOVLW 0x0
16FE  319C     MOVLP 0x1C
16FF  24B4     CALL 0x4B4
1700  3195     MOVLP 0x15
152:               SPI_ETHWIZ_Write(0x2E); //Address = 0x002E
1701  302E     MOVLW 0x2E
1702  319C     MOVLP 0x1C
1703  24B4     CALL 0x4B4
1704  3195     MOVLP 0x15
153:               SPI_ETHWIZ_Write(common_reg_write);
1705  0020     MOVLB 0x0
1706  0839     MOVF common_reg_write, W
1707  319C     MOVLP 0x1C
1708  24B4     CALL 0x4B4
1709  3195     MOVLP 0x15
154:               SPI_ETHWIZ_Write(0b10111000);
170A  30B8     MOVLW 0xB8
170B  319C     MOVLP 0x1C
170C  24B4     CALL 0x4B4
170D  3195     MOVLP 0x15
155:               PORTDbits.RD3 = 1;
170E  0020     MOVLB 0x0
170F  158F     BSF PORTD, 0x3
156:               __delay_ms(1);
1710  300B     MOVLW 0xB
1711  00F1     MOVWF i2cWriteData
1712  3062     MOVLW 0x62
1713  0B89     DECFSZ WREG, F
1714  2F13     GOTO 0x713
1715  0BF1     DECFSZ i2cWriteData, F
1716  2F13     GOTO 0x713
1717  3200     BRA 0x1718
157:               
158:               
159:               /*
160:                * Start of the Socket 0 (S0) Registers set up
161:                */
162:               
163:               //Set S0 Mode Register to enable Multicasting and sets 
164:               //the protocol mode to TCP - CMH
165:               PORTDbits.RD3 = 0;
1718  0020     MOVLB 0x0
1719  118F     BCF PORTD, 0x3
166:               SPI_ETHWIZ_Write(0x00);
171A  3000     MOVLW 0x0
171B  319C     MOVLP 0x1C
171C  24B4     CALL 0x4B4
171D  3195     MOVLP 0x15
167:               SPI_ETHWIZ_Write(0x00); //Address = 0x0000
171E  3000     MOVLW 0x0
171F  319C     MOVLP 0x1C
1720  24B4     CALL 0x4B4
1721  3195     MOVLP 0x15
168:               SPI_ETHWIZ_Write(s0_reg_write);
1722  0020     MOVLB 0x0
1723  0838     MOVF s0_reg_write, W
1724  319C     MOVLP 0x1C
1725  24B4     CALL 0x4B4
1726  3195     MOVLP 0x15
169:               SPI_ETHWIZ_Write(0b10000001);
1727  3081     MOVLW 0x81
1728  319C     MOVLP 0x1C
1729  24B4     CALL 0x4B4
172A  3195     MOVLP 0x15
170:               PORTDbits.RD3 = 1;
172B  0020     MOVLB 0x0
172C  158F     BSF PORTD, 0x3
171:               __delay_ms(1);
172D  300B     MOVLW 0xB
172E  00F1     MOVWF i2cWriteData
172F  3062     MOVLW 0x62
1730  0B89     DECFSZ WREG, F
1731  2F30     GOTO 0x730
1732  0BF1     DECFSZ i2cWriteData, F
1733  2F30     GOTO 0x730
1734  3200     BRA 0x1735
172:                   
173:               //Set the S0 Source Port Register to d'10,000' - CMH
174:               PORTDbits.RD3 = 0;
1735  0020     MOVLB 0x0
1736  118F     BCF PORTD, 0x3
175:               SPI_ETHWIZ_Write(0x00);
1737  3000     MOVLW 0x0
1738  319C     MOVLP 0x1C
1739  24B4     CALL 0x4B4
173A  3195     MOVLP 0x15
176:               SPI_ETHWIZ_Write(0x04); //Address = 0x0004
173B  3004     MOVLW 0x4
173C  319C     MOVLP 0x1C
173D  24B4     CALL 0x4B4
173E  3195     MOVLP 0x15
177:               SPI_ETHWIZ_Write(s0_reg_write);
173F  0020     MOVLB 0x0
1740  0838     MOVF s0_reg_write, W
1741  319C     MOVLP 0x1C
1742  24B4     CALL 0x4B4
1743  3195     MOVLP 0x15
178:               SPI_ETHWIZ_Write(0x27);
1744  3027     MOVLW 0x27
1745  319C     MOVLP 0x1C
1746  24B4     CALL 0x4B4
1747  3195     MOVLP 0x15
179:               SPI_ETHWIZ_Write(0x10); //10,000 = 0x2710
1748  3010     MOVLW 0x10
1749  319C     MOVLP 0x1C
174A  24B4     CALL 0x4B4
174B  3195     MOVLP 0x15
180:               PORTDbits.RD3 = 1;
174C  0020     MOVLB 0x0
174D  158F     BSF PORTD, 0x3
181:               __delay_ms(1);
174E  300B     MOVLW 0xB
174F  00F1     MOVWF i2cWriteData
1750  3062     MOVLW 0x62
1751  0B89     DECFSZ WREG, F
1752  2F51     GOTO 0x751
1753  0BF1     DECFSZ i2cWriteData, F
1754  2F51     GOTO 0x751
1755  3200     BRA 0x1756
182:           
183:               //Set the S0 Destination IP Address Register to 10.0.0.1 - CMH
184:               PORTDbits.RD3 = 0;
1756  0020     MOVLB 0x0
1757  118F     BCF PORTD, 0x3
185:               SPI_ETHWIZ_Write(0x00);
1758  3000     MOVLW 0x0
1759  319C     MOVLP 0x1C
175A  24B4     CALL 0x4B4
175B  3195     MOVLP 0x15
186:               SPI_ETHWIZ_Write(0x0C); //Address = 0x000C
175C  300C     MOVLW 0xC
175D  319C     MOVLP 0x1C
175E  24B4     CALL 0x4B4
175F  3195     MOVLP 0x15
187:               SPI_ETHWIZ_Write(s0_reg_write);
1760  0020     MOVLB 0x0
1761  0838     MOVF s0_reg_write, W
1762  319C     MOVLP 0x1C
1763  24B4     CALL 0x4B4
1764  3195     MOVLP 0x15
188:               SPI_ETHWIZ_Write(0x0A); //10
1765  300A     MOVLW 0xA
1766  319C     MOVLP 0x1C
1767  24B4     CALL 0x4B4
1768  3195     MOVLP 0x15
189:               SPI_ETHWIZ_Write(0x00); //0
1769  3000     MOVLW 0x0
176A  319C     MOVLP 0x1C
176B  24B4     CALL 0x4B4
176C  3195     MOVLP 0x15
190:               SPI_ETHWIZ_Write(0x00); //0
176D  3000     MOVLW 0x0
176E  319C     MOVLP 0x1C
176F  24B4     CALL 0x4B4
1770  3195     MOVLP 0x15
191:               SPI_ETHWIZ_Write(0x01); //1
1771  3001     MOVLW 0x1
1772  319C     MOVLP 0x1C
1773  24B4     CALL 0x4B4
1774  3195     MOVLP 0x15
192:               PORTDbits.RD3 = 1;
1775  0020     MOVLB 0x0
1776  158F     BSF PORTD, 0x3
193:               __delay_ms(1);
1777  300B     MOVLW 0xB
1778  00F1     MOVWF i2cWriteData
1779  3062     MOVLW 0x62
177A  0B89     DECFSZ WREG, F
177B  2F7A     GOTO 0x77A
177C  0BF1     DECFSZ i2cWriteData, F
177D  2F7A     GOTO 0x77A
177E  3200     BRA 0x177F
194:               
195:               //Set the S0 Destination Port Register to d'10,000' - CMH
196:               PORTDbits.RD3 = 0;
177F  0020     MOVLB 0x0
1780  118F     BCF PORTD, 0x3
197:               SPI_ETHWIZ_Write(0x00);
1781  3000     MOVLW 0x0
1782  319C     MOVLP 0x1C
1783  24B4     CALL 0x4B4
1784  3195     MOVLP 0x15
198:               SPI_ETHWIZ_Write(0x10); //Address = 0x0010
1785  3010     MOVLW 0x10
1786  319C     MOVLP 0x1C
1787  24B4     CALL 0x4B4
1788  3195     MOVLP 0x15
199:               SPI_ETHWIZ_Write(s0_reg_write);
1789  0020     MOVLB 0x0
178A  0838     MOVF s0_reg_write, W
178B  319C     MOVLP 0x1C
178C  24B4     CALL 0x4B4
178D  3195     MOVLP 0x15
200:               SPI_ETHWIZ_Write(0x27);
178E  3027     MOVLW 0x27
178F  319C     MOVLP 0x1C
1790  24B4     CALL 0x4B4
1791  3195     MOVLP 0x15
201:               SPI_ETHWIZ_Write(0x10); //10,000 = 0x2710
1792  3010     MOVLW 0x10
1793  319C     MOVLP 0x1C
1794  24B4     CALL 0x4B4
1795  3195     MOVLP 0x15
202:               PORTDbits.RD3 = 1;
1796  0020     MOVLB 0x0
1797  158F     BSF PORTD, 0x3
203:               __delay_ms(1);
1798  300B     MOVLW 0xB
1799  00F1     MOVWF i2cWriteData
179A  3062     MOVLW 0x62
179B  0B89     DECFSZ WREG, F
179C  2F9B     GOTO 0x79B
179D  0BF1     DECFSZ i2cWriteData, F
179E  2F9B     GOTO 0x79B
179F  3200     BRA 0x17A0
204:                  
205:               //Set the S0 Max Segment Size Register to d'1460' - CMH
206:               PORTDbits.RD3 = 0;
17A0  0020     MOVLB 0x0
17A1  118F     BCF PORTD, 0x3
207:               SPI_ETHWIZ_Write(0x00);
17A2  3000     MOVLW 0x0
17A3  319C     MOVLP 0x1C
17A4  24B4     CALL 0x4B4
17A5  3195     MOVLP 0x15
208:               SPI_ETHWIZ_Write(0x12); //Address = 0x0012
17A6  3012     MOVLW 0x12
17A7  319C     MOVLP 0x1C
17A8  24B4     CALL 0x4B4
17A9  3195     MOVLP 0x15
209:               SPI_ETHWIZ_Write(s0_reg_write);
17AA  0020     MOVLB 0x0
17AB  0838     MOVF s0_reg_write, W
17AC  319C     MOVLP 0x1C
17AD  24B4     CALL 0x4B4
17AE  3195     MOVLP 0x15
210:               SPI_ETHWIZ_Write(0x05);
17AF  3005     MOVLW 0x5
17B0  319C     MOVLP 0x1C
17B1  24B4     CALL 0x4B4
17B2  3195     MOVLP 0x15
211:               SPI_ETHWIZ_Write(0xB4); //1,460 = 0x05B4
17B3  30B4     MOVLW 0xB4
17B4  319C     MOVLP 0x1C
17B5  24B4     CALL 0x4B4
17B6  3195     MOVLP 0x15
212:               PORTDbits.RD3 = 1;
17B7  0020     MOVLB 0x0
17B8  158F     BSF PORTD, 0x3
213:               __delay_ms(1);
17B9  300B     MOVLW 0xB
17BA  00F1     MOVWF i2cWriteData
17BB  3062     MOVLW 0x62
17BC  0B89     DECFSZ WREG, F
17BD  2FBC     GOTO 0x7BC
17BE  0BF1     DECFSZ i2cWriteData, F
17BF  2FBC     GOTO 0x7BC
17C0  3200     BRA 0x17C1
214:               
215:               //Set the S0 Fragment Register to d'0' to not allow for IP Fragments - CMH
216:               PORTDbits.RD3 = 0;
17C1  0020     MOVLB 0x0
17C2  118F     BCF PORTD, 0x3
217:               SPI_ETHWIZ_Write(0x00);
17C3  3000     MOVLW 0x0
17C4  319C     MOVLP 0x1C
17C5  24B4     CALL 0x4B4
17C6  3195     MOVLP 0x15
218:               SPI_ETHWIZ_Write(0x2D); //Address = 0x002D
17C7  302D     MOVLW 0x2D
17C8  319C     MOVLP 0x1C
17C9  24B4     CALL 0x4B4
17CA  3195     MOVLP 0x15
219:               SPI_ETHWIZ_Write(s0_reg_write);
17CB  0020     MOVLB 0x0
17CC  0838     MOVF s0_reg_write, W
17CD  319C     MOVLP 0x1C
17CE  24B4     CALL 0x4B4
17CF  3195     MOVLP 0x15
220:               SPI_ETHWIZ_Write(0x00);
17D0  3000     MOVLW 0x0
17D1  319C     MOVLP 0x1C
17D2  24B4     CALL 0x4B4
17D3  3195     MOVLP 0x15
221:               SPI_ETHWIZ_Write(0x00); //0 = 0x0000
17D4  3000     MOVLW 0x0
17D5  319C     MOVLP 0x1C
17D6  24B4     CALL 0x4B4
17D7  3195     MOVLP 0x15
222:               PORTDbits.RD3 = 1;
17D8  0020     MOVLB 0x0
17D9  158F     BSF PORTD, 0x3
223:               __delay_ms(1);
17DA  300B     MOVLW 0xB
17DB  00F1     MOVWF i2cWriteData
17DC  3062     MOVLW 0x62
17DD  0B89     DECFSZ WREG, F
17DE  2FDD     GOTO 0x7DD
17DF  0BF1     DECFSZ i2cWriteData, F
17E0  2FDD     GOTO 0x7DD
17E1  3200     BRA 0x17E2
224:               
225:               //Set the S0 Keep Alive Time Register to d'10' - CMH
226:               PORTDbits.RD3 = 0;
17E2  0020     MOVLB 0x0
17E3  118F     BCF PORTD, 0x3
227:               SPI_ETHWIZ_Write(0x00);
17E4  3000     MOVLW 0x0
17E5  319C     MOVLP 0x1C
17E6  24B4     CALL 0x4B4
17E7  3195     MOVLP 0x15
228:               SPI_ETHWIZ_Write(0x2F); //Address = 0x002F
17E8  302F     MOVLW 0x2F
17E9  319C     MOVLP 0x1C
17EA  24B4     CALL 0x4B4
17EB  3195     MOVLP 0x15
229:               SPI_ETHWIZ_Write(s0_reg_write);
17EC  0020     MOVLB 0x0
17ED  0838     MOVF s0_reg_write, W
17EE  319C     MOVLP 0x1C
17EF  24B4     CALL 0x4B4
17F0  3195     MOVLP 0x15
230:               SPI_ETHWIZ_Write(0x0A); //10 = 0x0A
17F1  300A     MOVLW 0xA
17F2  319C     MOVLP 0x1C
17F3  24B4     CALL 0x4B4
17F4  3195     MOVLP 0x15
231:               PORTDbits.RD3 = 1;
17F5  0020     MOVLB 0x0
17F6  158F     BSF PORTD, 0x3
232:               __delay_ms(1);
17F7  300B     MOVLW 0xB
17F8  00F1     MOVWF i2cWriteData
17F9  3062     MOVLW 0x62
17FA  0B89     DECFSZ WREG, F
17FB  2FFA     GOTO 0x7FA
17FC  0BF1     DECFSZ i2cWriteData, F
17FD  2FFA     GOTO 0x7FA
17FE  3200     BRA 0x17FF
233:           }
17FF  0008     RETURN
234:           
235:           
236:           // ************************************************************
237:           //
238:           //  This function goes through the sequence to create the 
239:           //  Socket 0. Will open and then listen.
240:           //
241:           // ************************************************************
242:           void eth_wiz_createSocket(void){
243:               uint8_t connected = 0;
150D  01F2     CLRF connected
244:               do{
245:                   //Open the Socket 0 - CMH
246:                   PORTDbits.RD3 = 0;
150E  0020     MOVLB 0x0
150F  118F     BCF PORTD, 0x3
247:                   SPI_ETHWIZ_Write(0x00);
1510  3000     MOVLW 0x0
1511  319C     MOVLP 0x1C
1512  24B4     CALL 0x4B4
1513  3195     MOVLP 0x15
248:                   SPI_ETHWIZ_Write(0x01); //Address = 0x0001
1514  3001     MOVLW 0x1
1515  319C     MOVLP 0x1C
1516  24B4     CALL 0x4B4
1517  3195     MOVLP 0x15
249:                   SPI_ETHWIZ_Write(s0_reg_write);
1518  0020     MOVLB 0x0
1519  0838     MOVF s0_reg_write, W
151A  319C     MOVLP 0x1C
151B  24B4     CALL 0x4B4
151C  3195     MOVLP 0x15
250:                   SPI_ETHWIZ_Write(0x01); //OPEN = 0x01
151D  3001     MOVLW 0x1
151E  319C     MOVLP 0x1C
151F  24B4     CALL 0x4B4
1520  3195     MOVLP 0x15
251:                   PORTDbits.RD3 = 1;
1521  0020     MOVLB 0x0
1522  158F     BSF PORTD, 0x3
252:                   __delay_ms(1);
1523  300B     MOVLW 0xB
1524  00F1     MOVWF i2cWriteData
1525  3062     MOVLW 0x62
1526  0B89     DECFSZ WREG, F
1527  2D26     GOTO 0x526
1528  0BF1     DECFSZ i2cWriteData, F
1529  2D26     GOTO 0x526
152A  3200     BRA 0x152B
253:           
254:                   //check if the socket is open - CMH
255:                   do{
256:                       PORTDbits.RD3 = 0;
152B  0020     MOVLB 0x0
152C  118F     BCF PORTD, 0x3
257:                       SPI_ETHWIZ_Write(0x00);
152D  3000     MOVLW 0x0
152E  319C     MOVLP 0x1C
152F  24B4     CALL 0x4B4
1530  3195     MOVLP 0x15
258:                       SPI_ETHWIZ_Write(0x03); //Address = 0x0001
1531  3003     MOVLW 0x3
1532  319C     MOVLP 0x1C
1533  24B4     CALL 0x4B4
1534  3195     MOVLP 0x15
259:                       SPI_ETHWIZ_Write(s0_reg_read);
1535  0020     MOVLB 0x0
1536  0837     MOVF s0_reg_read, W
1537  319C     MOVLP 0x1C
1538  24B4     CALL 0x4B4
1539  3195     MOVLP 0x15
260:                       s0_SR_check = SPI_ETHWIZ_Write(0x00); 
153A  3000     MOVLW 0x0
153B  319C     MOVLP 0x1C
153C  24B4     CALL 0x4B4
153D  3195     MOVLP 0x15
153E  00F1     MOVWF i2cWriteData
153F  0871     MOVF i2cWriteData, W
1540  0020     MOVLB 0x0
1541  00A7     MOVWF s0_SR_check
261:                       PORTDbits.RD3 = 1;
1542  158F     BSF PORTD, 0x3
262:                   }while(s0_SR_check != 0x13); //SR needs to equal SOCK_INIT
1543  3013     MOVLW 0x13
1544  0627     XORWF s0_SR_check, W
1545  1D03     BTFSS STATUS, 0x2
1546  2D2B     GOTO 0x52B
263:           
264:                   //Order the socket to listen for a connection request from
265:                   //the "client" - CMH
266:                   PORTDbits.RD3 = 0;
1547  118F     BCF PORTD, 0x3
267:                   SPI_ETHWIZ_Write(0x00);
1548  3000     MOVLW 0x0
1549  319C     MOVLP 0x1C
154A  24B4     CALL 0x4B4
154B  3195     MOVLP 0x15
268:                   SPI_ETHWIZ_Write(0x01); //Address = 0x0001
154C  3001     MOVLW 0x1
154D  319C     MOVLP 0x1C
154E  24B4     CALL 0x4B4
154F  3195     MOVLP 0x15
269:                   SPI_ETHWIZ_Write(s0_reg_write);
1550  0020     MOVLB 0x0
1551  0838     MOVF s0_reg_write, W
1552  319C     MOVLP 0x1C
1553  24B4     CALL 0x4B4
1554  3195     MOVLP 0x15
270:                   SPI_ETHWIZ_Write(0x02); //LISTEN = 0x02
1555  3002     MOVLW 0x2
1556  319C     MOVLP 0x1C
1557  24B4     CALL 0x4B4
1558  3195     MOVLP 0x15
271:                   PORTDbits.RD3 = 1;
1559  0020     MOVLB 0x0
155A  158F     BSF PORTD, 0x3
272:                   __delay_ms(1);
155B  300B     MOVLW 0xB
155C  00F1     MOVWF i2cWriteData
155D  3062     MOVLW 0x62
155E  0B89     DECFSZ WREG, F
155F  2D5E     GOTO 0x55E
1560  0BF1     DECFSZ i2cWriteData, F
1561  2D5E     GOTO 0x55E
1562  3200     BRA 0x1563
273:           
274:                   //check if the socket is listening for a client - CMH
275:                   do{
276:                       PORTDbits.RD3 = 0;
1563  0020     MOVLB 0x0
1564  118F     BCF PORTD, 0x3
277:                       SPI_ETHWIZ_Write(0x00);
1565  3000     MOVLW 0x0
1566  319C     MOVLP 0x1C
1567  24B4     CALL 0x4B4
1568  3195     MOVLP 0x15
278:                       SPI_ETHWIZ_Write(0x03); //Address = 0x0003
1569  3003     MOVLW 0x3
156A  319C     MOVLP 0x1C
156B  24B4     CALL 0x4B4
156C  3195     MOVLP 0x15
279:                       SPI_ETHWIZ_Write(s0_reg_read);
156D  0020     MOVLB 0x0
156E  0837     MOVF s0_reg_read, W
156F  319C     MOVLP 0x1C
1570  24B4     CALL 0x4B4
1571  3195     MOVLP 0x15
280:                       s0_SR_check = SPI_ETHWIZ_Write(0x00); 
1572  3000     MOVLW 0x0
1573  319C     MOVLP 0x1C
1574  24B4     CALL 0x4B4
1575  3195     MOVLP 0x15
1576  00F1     MOVWF i2cWriteData
1577  0871     MOVF i2cWriteData, W
1578  0020     MOVLB 0x0
1579  00A7     MOVWF s0_SR_check
281:                       PORTDbits.RD3 = 1;
157A  158F     BSF PORTD, 0x3
282:                   }while(s0_SR_check != 0x13); //SR needs to equal SOCKET_LISTEN - CMH
157B  3013     MOVLW 0x13
157C  0627     XORWF s0_SR_check, W
157D  1D03     BTFSS STATUS, 0x2
157E  2D63     GOTO 0x563
283:           
284:                   while(PORTBbits.RB0 != 0) continue; //until INTn is asserted - CMH
157F  180D     BTFSC PORTB, 0x0
1580  2D7F     GOTO 0x57F
285:           
286:                   //Read in the S0_IR and S0_SR register for interrupt checking - CMH
287:                   PORTDbits.RD3 = 0;
1581  118F     BCF PORTD, 0x3
288:                   SPI_ETHWIZ_Write(0x00);
1582  3000     MOVLW 0x0
1583  319C     MOVLP 0x1C
1584  24B4     CALL 0x4B4
1585  3195     MOVLP 0x15
289:                   SPI_ETHWIZ_Write(0x02); //Address = 0x0002
1586  3002     MOVLW 0x2
1587  319C     MOVLP 0x1C
1588  24B4     CALL 0x4B4
1589  3195     MOVLP 0x15
290:                   SPI_ETHWIZ_Write(s0_reg_read);
158A  0020     MOVLB 0x0
158B  0837     MOVF s0_reg_read, W
158C  319C     MOVLP 0x1C
158D  24B4     CALL 0x4B4
158E  3195     MOVLP 0x15
291:                   s0_IR_check = SPI_ETHWIZ_Write(0x00);   //0x0002
158F  3000     MOVLW 0x0
1590  319C     MOVLP 0x1C
1591  24B4     CALL 0x4B4
1592  3195     MOVLP 0x15
1593  00F1     MOVWF i2cWriteData
1594  0871     MOVF i2cWriteData, W
1595  0020     MOVLB 0x0
1596  00A6     MOVWF s0_IR_check
292:                   s0_SR_check = SPI_ETHWIZ_Write(0x00);   //0x0003
1597  3000     MOVLW 0x0
1598  319C     MOVLP 0x1C
1599  24B4     CALL 0x4B4
159A  3195     MOVLP 0x15
159B  00F1     MOVWF i2cWriteData
159C  0871     MOVF i2cWriteData, W
159D  0020     MOVLB 0x0
159E  00A7     MOVWF s0_SR_check
293:                   PORTDbits.RD3 = 1;
159F  158F     BSF PORTD, 0x3
294:               
295:                   //if Timed out and socket closed - CMH
296:                   if((s0_IR_check & 0x08) == 0x08 && s0_SR_check == 0x00){
15A0  1DA6     BTFSS s0_IR_check, 0x3
15A1  2DBB     GOTO 0x5BB
15A2  0827     MOVF s0_SR_check, W
15A3  1D03     BTFSS STATUS, 0x2
15A4  2DBB     GOTO 0x5BB
297:                       //Clear (by writing a 1) the time out flag 
298:                       //to de-assert the INTn Pin - CMH
299:                       PORTDbits.RD3 = 0;
15A5  118F     BCF PORTD, 0x3
300:                       SPI_ETHWIZ_Write(0x00);
15A6  3000     MOVLW 0x0
15A7  319C     MOVLP 0x1C
15A8  24B4     CALL 0x4B4
15A9  3195     MOVLP 0x15
301:                       SPI_ETHWIZ_Write(0x02); //Address = 0x0002
15AA  3002     MOVLW 0x2
15AB  319C     MOVLP 0x1C
15AC  24B4     CALL 0x4B4
15AD  3195     MOVLP 0x15
302:                       SPI_ETHWIZ_Write(s0_reg_write);
15AE  0020     MOVLB 0x0
15AF  0838     MOVF s0_reg_write, W
15B0  319C     MOVLP 0x1C
15B1  24B4     CALL 0x4B4
15B2  3195     MOVLP 0x15
303:                       SPI_ETHWIZ_Write(0x08);
15B3  3008     MOVLW 0x8
15B4  319C     MOVLP 0x1C
15B5  24B4     CALL 0x4B4
15B6  3195     MOVLP 0x15
304:                       PORTDbits.RD3 = 1;
15B7  0020     MOVLB 0x0
15B8  158F     BSF PORTD, 0x3
305:                       
306:                       connected = 0;
15B9  01F2     CLRF connected
307:                   }
15BA  2DD7     GOTO 0x5D7
308:                   //if successfully connected and sock_established - CMH
309:                   else if((s0_IR_check & 0x01) == 0x01 && s0_SR_check == 0x17){
15BB  1C26     BTFSS s0_IR_check, 0x0
15BC  2DD7     GOTO 0x5D7
15BD  3017     MOVLW 0x17
15BE  0627     XORWF s0_SR_check, W
15BF  1D03     BTFSS STATUS, 0x2
15C0  2DD7     GOTO 0x5D7
310:                       //Clear (by writing a 1) the tconnection flag 
311:                       //to de-assert the INTn Pin - CMH
312:                       PORTDbits.RD3 = 0;
15C1  118F     BCF PORTD, 0x3
313:                       SPI_ETHWIZ_Write(0x00);
15C2  3000     MOVLW 0x0
15C3  319C     MOVLP 0x1C
15C4  24B4     CALL 0x4B4
15C5  3195     MOVLP 0x15
314:                       SPI_ETHWIZ_Write(0x02); //Address = 0x0002
15C6  3002     MOVLW 0x2
15C7  319C     MOVLP 0x1C
15C8  24B4     CALL 0x4B4
15C9  3195     MOVLP 0x15
315:                       SPI_ETHWIZ_Write(s0_reg_write);
15CA  0020     MOVLB 0x0
15CB  0838     MOVF s0_reg_write, W
15CC  319C     MOVLP 0x1C
15CD  24B4     CALL 0x4B4
15CE  3195     MOVLP 0x15
316:                       SPI_ETHWIZ_Write(0x01);
15CF  3001     MOVLW 0x1
15D0  319C     MOVLP 0x1C
15D1  24B4     CALL 0x4B4
15D2  3195     MOVLP 0x15
317:                       PORTDbits.RD3 = 1;
15D3  0020     MOVLB 0x0
15D4  158F     BSF PORTD, 0x3
318:                       
319:                       //Set the connected flag to exit loop and function - CMH
320:                       connected = 1;
15D5  01F2     CLRF connected
15D6  0AF2     INCF connected, F
321:                   }
322:                   
323:                   
324:               }while(connected == 0);
15D7  0872     MOVF connected, W
15D8  1D03     BTFSS STATUS, 0x2
15D9  0008     RETURN
15DA  2D0E     GOTO 0x50E
325:                 
326:               
327:           }
328:           
329:           
330:           // ************************************************************
331:           //
332:           //  This function starts the transmission sequence for the 
333:           //  ETH WIZ. It finds the current location of the TX buffer
334:           //  pointer and then starts the write to buffer sequence at
335:           //  the address of the pointer. Data can be written to the
336:           //  buffer after calling this function.
337:           //
338:           // ************************************************************
339:           void eth_wiz_transmit_start(void){
340:               //Read in the starting tx pointer address - CMH
341:               PORTDbits.RD3 = 0;
1CE2  0020     MOVLB 0x0
1CE3  118F     BCF PORTD, 0x3
342:               SPI_ETHWIZ_Write(0x00);
1CE4  3000     MOVLW 0x0
1CE5  319C     MOVLP 0x1C
1CE6  24B4     CALL 0x4B4
1CE7  319C     MOVLP 0x1C
343:               SPI_ETHWIZ_Write(0x24); //Address = 0x0024
1CE8  3024     MOVLW 0x24
1CE9  319C     MOVLP 0x1C
1CEA  24B4     CALL 0x4B4
1CEB  319C     MOVLP 0x1C
344:               SPI_ETHWIZ_Write(s0_reg_read);
1CEC  0020     MOVLB 0x0
1CED  0837     MOVF s0_reg_read, W
1CEE  319C     MOVLP 0x1C
1CEF  24B4     CALL 0x4B4
1CF0  319C     MOVLP 0x1C
345:               s0_tx_pointer_high = SPI_ETHWIZ_Write(0x00);
1CF1  3000     MOVLW 0x0
1CF2  319C     MOVLP 0x1C
1CF3  24B4     CALL 0x4B4
1CF4  319C     MOVLP 0x1C
1CF5  00F1     MOVWF i2cWriteData
1CF6  0871     MOVF i2cWriteData, W
1CF7  0020     MOVLB 0x0
1CF8  00AF     MOVWF s0_tx_pointer_high
346:               s0_tx_pointer_low  = SPI_ETHWIZ_Write(0x00);
1CF9  3000     MOVLW 0x0
1CFA  319C     MOVLP 0x1C
1CFB  24B4     CALL 0x4B4
1CFC  319C     MOVLP 0x1C
1CFD  00F1     MOVWF i2cWriteData
1CFE  0871     MOVF i2cWriteData, W
1CFF  0020     MOVLB 0x0
1D00  00AE     MOVWF s0_tx_pointer_low
347:               PORTDbits.RD3 = 1;
1D01  158F     BSF PORTD, 0x3
348:               __delay_us(1);
1D02  3200     BRA 0x1D03
1D03  3200     BRA 0x1D04
1D04  3200     BRA 0x1D05
1D05  3200     BRA 0x1D06
349:               
350:               //Start the write to buffer sequence - CMH
351:               PORTDbits.RD3 = 0;
1D06  0020     MOVLB 0x0
1D07  118F     BCF PORTD, 0x3
352:               SPI_ETHWIZ_Write(s0_tx_pointer_high);           //Address high
1D08  082F     MOVF s0_tx_pointer_high, W
1D09  319C     MOVLP 0x1C
1D0A  24B4     CALL 0x4B4
1D0B  319C     MOVLP 0x1C
353:               SPI_ETHWIZ_Write(s0_tx_pointer_low);            //Address low
1D0C  0020     MOVLB 0x0
1D0D  082E     MOVF s0_tx_pointer_low, W
1D0E  319C     MOVLP 0x1C
1D0F  24B4     CALL 0x4B4
1D10  319C     MOVLP 0x1C
354:               SPI_ETHWIZ_Write(s0_tx_buf_write);              //TX Write Command
1D11  0020     MOVLB 0x0
1D12  0836     MOVF s0_tx_buf_write, W
1D13  319C     MOVLP 0x1C
1D14  24B4     CALL 0x4B4
355:               
356:               //data can now be written to TX buffer in main program - CMH
357:           }
1D15  0008     RETURN
358:           
359:           
360:           // ************************************************************
361:           //
362:           //  This function ends the transmission sequence into the TX
363:           //  buffer and the initiates the SEND sequence by calling the
364:           //  SEND command. After ending the TX write sequence, the TX
365:           //  pointer is updated to its new value by adding the number
366:           //  of written bytes to the previous value of the pointer.
367:           //  After that, the SEND command is sent.
368:           //
369:           // ************************************************************
370:           void eth_wiz_transmit_end(void){
371:               //De-assert RD3 to stop transmission into TX buffer - CMH
372:               PORTDbits.RD3 = 1;
102D  0020     MOVLB 0x0
102E  158F     BSF PORTD, 0x3
373:               
374:               //combined high and low bytes of tx pointer and add
375:               //the number of bytes added to buffer - CMH
376:               uint16_t value = (s0_tx_pointer_high << 8) | s0_tx_pointer_low;
102F  082E     MOVF s0_tx_pointer_low, W
1030  00F1     MOVWF i2cWriteData
1031  01F2     CLRF connected
1032  082F     MOVF s0_tx_pointer_high, W
1033  00F3     MOVWF 0x73
1034  01F4     CLRF 0x74
1035  0873     MOVF 0x73, W
1036  00F4     MOVWF 0x74
1037  01F3     CLRF 0x73
1038  0871     MOVF i2cWriteData, W
1039  0473     IORWF 0x73, W
103A  00F6     MOVWF value
103B  0872     MOVF connected, W
103C  0474     IORWF 0x74, W
103D  00F7     MOVWF 0x77
377:               value = (value + 164) & (0xFFFF);
103E  0876     MOVF value, W
103F  3EA4     ADDLW 0xA4
1040  00F6     MOVWF value
1041  3000     MOVLW 0x0
1042  3D77     ADDWFC 0x77, W
1043  00F7     MOVWF 0x77
378:               s0_tx_pointer_high = (value & 0xFF00) >> 8;
1044  0877     MOVF 0x77, W
1045  00F1     MOVWF i2cWriteData
1046  0871     MOVF i2cWriteData, W
1047  00AF     MOVWF s0_tx_pointer_high
379:               s0_tx_pointer_low  = value & 0x00FF;
1048  0876     MOVF value, W
1049  00F1     MOVWF i2cWriteData
104A  0871     MOVF i2cWriteData, W
104B  00AE     MOVWF s0_tx_pointer_low
380:               
381:               //Update the pointer address for the amount of data added - CMH
382:               PORTDbits.RD3 = 0;
104C  118F     BCF PORTD, 0x3
383:               SPI_ETHWIZ_Write(0x00);
104D  3000     MOVLW 0x0
104E  319C     MOVLP 0x1C
104F  24B4     CALL 0x4B4
1050  3190     MOVLP 0x10
384:               SPI_ETHWIZ_Write(0x24); //Address = 0x0024
1051  3024     MOVLW 0x24
1052  319C     MOVLP 0x1C
1053  24B4     CALL 0x4B4
1054  3190     MOVLP 0x10
385:               SPI_ETHWIZ_Write(s0_reg_write);
1055  0020     MOVLB 0x0
1056  0838     MOVF s0_reg_write, W
1057  319C     MOVLP 0x1C
1058  24B4     CALL 0x4B4
1059  3190     MOVLP 0x10
386:               SPI_ETHWIZ_Write(s0_tx_pointer_high);
105A  0020     MOVLB 0x0
105B  082F     MOVF s0_tx_pointer_high, W
105C  319C     MOVLP 0x1C
105D  24B4     CALL 0x4B4
105E  3190     MOVLP 0x10
387:               SPI_ETHWIZ_Write(s0_tx_pointer_low);
105F  0020     MOVLB 0x0
1060  082E     MOVF s0_tx_pointer_low, W
1061  319C     MOVLP 0x1C
1062  24B4     CALL 0x4B4
1063  3190     MOVLP 0x10
388:               PORTDbits.RD3 = 1;
1064  0020     MOVLB 0x0
1065  158F     BSF PORTD, 0x3
389:               __delay_us(1);
1066  3200     BRA 0x1067
1067  3200     BRA 0x1068
1068  3200     BRA 0x1069
1069  3200     BRA 0x106A
390:               
391:               //Initiate the send command in the S0_CR Register - CMH
392:               PORTDbits.RD3 = 0;
106A  0020     MOVLB 0x0
106B  118F     BCF PORTD, 0x3
393:               SPI_ETHWIZ_Write(0x00);
106C  3000     MOVLW 0x0
106D  319C     MOVLP 0x1C
106E  24B4     CALL 0x4B4
106F  3190     MOVLP 0x10
394:               SPI_ETHWIZ_Write(0x01); //Address = 0x0024
1070  3001     MOVLW 0x1
1071  319C     MOVLP 0x1C
1072  24B4     CALL 0x4B4
1073  3190     MOVLP 0x10
395:               SPI_ETHWIZ_Write(s0_reg_write);
1074  0020     MOVLB 0x0
1075  0838     MOVF s0_reg_write, W
1076  319C     MOVLP 0x1C
1077  24B4     CALL 0x4B4
1078  3190     MOVLP 0x10
396:               SPI_ETHWIZ_Write(0x20);   //SEND = 0x20
1079  3020     MOVLW 0x20
107A  319C     MOVLP 0x1C
107B  24B4     CALL 0x4B4
397:               PORTDbits.RD3 = 1;
107C  0020     MOVLB 0x0
107D  158F     BSF PORTD, 0x3
398:               
399:           }
107E  0008     RETURN
400:           
401:           
402:           // ************************************************************
403:           //
404:           //  This function performs the receive data sequence. Will only
405:           //  be called after a receive interrupt is sent from the ETH
406:           //  WIZ.
407:           //
408:           // ************************************************************
409:           void eth_wiz_receive(void){
410:               //Read in Received Data Size Register (0x0026 - 0x0027),
411:               //the RX Read Data Pointer Register (0x0028 - 0x0029), and
412:               //the RX Write pointer Register (0x002A - 0x002B) - CMH
413:               PORTDbits.RD3 = 0;
414:               SPI_ETHWIZ_Write(0x00);
415:               SPI_ETHWIZ_Write(0x26); //Starting Address = 0x0026
416:               SPI_ETHWIZ_Write(s0_reg_read);
417:               s0_rx_datalength_high = SPI_ETHWIZ_Write(0x00);         //0x0026
418:               s0_rx_datalength_low  = SPI_ETHWIZ_Write(0x00);         //0x0027
419:               s0_rx_readpointer_high = SPI_ETHWIZ_Write(0x00);        //0x0028
420:               s0_rx_readpointer_low  = SPI_ETHWIZ_Write(0x00);        //0x0029
421:               s0_rx_writepointer_high = SPI_ETHWIZ_Write(0x00);       //0x002A
422:               s0_rx_writepointer_low  = SPI_ETHWIZ_Write(0x00);       //0x002B
423:               PORTDbits.RD3 = 1;
424:               
425:               //determine the amount of bytes to read in from RX buffer - CMH
426:               uint16_t datalength = (s0_rx_datalength_high << 8) | s0_rx_datalength_low;
427:               
428:               //Read in data from the RX buffer - CMH
429:               PORTDbits.RD3 = 0;
430:                //Starting Address = RX Read Data Pointer
431:               SPI_ETHWIZ_Write(s0_rx_readpointer_high);
432:               SPI_ETHWIZ_Write(s0_rx_readpointer_low);
433:               SPI_ETHWIZ_Write(s0_rx_buf_read);
434:               for(int i = 0; i < datalength; i++){
435:                   //Collect these values into an array - CMH
436:                   SPI_ETHWIZ_Write(0x00);
437:               }
438:               PORTDbits.RD3 = 1;
439:               __delay_us(1);
440:               
441:               //Update the Read Pointer to the Write Pointer Address - CMH
442:               PORTDbits.RD3 = 0;
443:               SPI_ETHWIZ_Write(0x00);
444:               SPI_ETHWIZ_Write(0x28); //Starting Address = 0x0028
445:               SPI_ETHWIZ_Write(s0_reg_write);
446:               SPI_ETHWIZ_Write(s0_rx_writepointer_high);
447:               SPI_ETHWIZ_Write(s0_rx_writepointer_low);
448:               PORTDbits.RD3 = 1;
449:               
450:               //Order the RECV command to notify W5500 that the data was read in - CMH
451:               PORTDbits.RD3 = 0;
452:               SPI_ETHWIZ_Write(0x00);
453:               SPI_ETHWIZ_Write(0x01); //Address = 0x0024
454:               SPI_ETHWIZ_Write(s0_reg_write);
455:               SPI_ETHWIZ_Write(0x40);   //RECV = 0x40
456:               PORTDbits.RD3 = 1;
457:           }
458:           
---  C:/Users/cmh52/Desktop/SeniorDesign.X/config.c  ----------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: config.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 1.00
12:             */
13:            
14:            
15:            #include "config.h"
16:            
17:            // ************************************************************
18:            //
19:            //  This function setups oscillator to function at 32MHz.
20:            //
21:            // ************************************************************
22:            void OSCILLATOR_Initialize(void) {
23:                OSCCON1 = 0x60;     // NOSC HFINTOSC; NDIV 1; 
1000  3060     MOVLW 0x60
1001  0031     MOVLB 0x11
1002  008D     MOVWF OSCCON1
24:                OSCFRQ = 0x06;      // Fosc set to 32MHz
1003  3006     MOVLW 0x6
1004  0093     MOVWF OSCFRQ
25:            }
1005  0008     RETURN
26:            
27:            
28:            // ************************************************************
29:            //
30:            //  This function is the first Initialization function for 
31:            //  the port pins. Within all pins are set to be digital, set
32:            //  to be either an input or an output, and the various serial
33:            //  protocols have pins mapped for use. The necessary interrupts
34:            //  are enabled and their respective flags are cleared.
35:            //
36:            // ************************************************************
37:            void PORT_PIN_Initialize1(void) {
38:                
39:                //Set all pins of the microcontroller to digital pins - CMH
40:                ANSELA = 0x00;
1D16  003E     MOVLB 0x1E
1D17  01B8     CLRF ANSELA
41:                ANSELB = 0x00;
1D18  01C3     CLRF ANSELB
42:                ANSELC = 0x00;
1D19  01CE     CLRF ANSELC
43:                ANSELD = 0x00;
1D1A  01D9     CLRF ANSELD
44:                ANSELE = 0x00;
1D1B  01E4     CLRF ANSELE
45:                
46:                //Set up each pin to either be an input(1) or an output(0) based on
47:                //its necessary function. Each binary value corresponds to a port - CMH
48:                TRISA = 0x00;
1D1C  0020     MOVLB 0x0
1D1D  0191     CLRF TRISA
49:                TRISB = 0b01100101;
1D1E  3065     MOVLW 0x65
1D1F  0092     MOVWF TRISB
50:                TRISC = 0b10011000;
1D20  3098     MOVLW 0x98
1D21  0093     MOVWF TRISC
51:                TRISD = 0x00;
1D22  0194     CLRF TRISD
52:                TRISE = 0x00;
1D23  0195     CLRF TRISE
53:                
54:                //Initially set all pins to 0 (low) state - CMH 
55:                PORTA = 0x00;
1D24  018C     CLRF PORTA
56:                PORTB = 0x00;
1D25  018D     CLRF PORTB
57:                PORTC = 0x00;
1D26  018E     CLRF PORTC
58:                PORTD = 0x00;
1D27  018F     CLRF PORTD
59:                PORTE = 0x00;
1D28  0190     CLRF PORTE
60:                
61:                //Turn off the latch for all pins - CMH
62:                LATA = 0x00;
1D29  0196     CLRF LATA
63:                LATB = 0x00;
1D2A  0197     CLRF LATB
64:                LATC = 0x00;
1D2B  0198     CLRF LATC
65:                LATD = 0x00;
1D2C  0199     CLRF LATD
66:                LATE = 0x00;
1D2D  019A     CLRF LATE
67:                
68:                //Turn off interrupts to allow for the unlocking sequence below - CMH
69:                PIE3bits.RCIE = 0;
1D2E  002E     MOVLB 0xE
1D2F  1299     BCF PIE3, 0x5
70:                INTCONbits.PEIE = 0;
1D30  130B     BCF 0x70B, 0x6
71:                INTCONbits.GIE = 0;
1D31  138B     BCF 0x70B, 0x7
72:                PIE0bits.IOCIE = 0;
1D32  1216     BCF PIE0, 0x4
73:                
74:                //Unlock Peripheral Pin Select (PPS) using the unlock sequence - CMH
75:                PPSLOCK = 0x55;
1D33  3055     MOVLW 0x55
1D34  003D     MOVLB 0x1D
1D35  008F     MOVWF PPSLOCK
76:                PPSLOCK = 0xAA;
1D36  30AA     MOVLW 0xAA
1D37  008F     MOVWF PPSLOCK
77:                PPSLOCKbits.PPSLOCKED = 0;
1D38  100F     BCF PPSLOCK, 0x0
78:                
79:                //Sets up the pins for UART between PIC and GNSS 5 - CMH
80:                RC6PPS = 0x10;
1D39  3010     MOVLW 0x10
1D3A  003E     MOVLB 0x1E
1D3B  00A6     MOVWF RC6PPS
81:                RXPPS = 0x17; 
1D3C  3017     MOVLW 0x17
1D3D  003D     MOVLB 0x1D
1D3E  00CB     MOVWF RXPPS
82:                
83:                //Sets up the pins for SPI on SSP1 between PIC and Cameras - CMH 
84:                SSP1DATPPS = 0x0E;  //MISO - RB6
1D3F  300E     MOVLW 0xE
1D40  00C6     MOVWF SSP1DATPPS
85:                RB7PPS = 0x14;      //SCLK
1D41  3014     MOVLW 0x14
1D42  003E     MOVLB 0x1E
1D43  009F     MOVWF RB7PPS
86:                RC1PPS = 0x15;      //MOSI     
1D44  3015     MOVLW 0x15
1D45  00A1     MOVWF RC1PPS
87:                    
88:                //Sets up the pins for I2C on SSP2 between PIC and Cameras - CMH
89:                SSP2DATPPS = 0x14;  
1D46  3014     MOVLW 0x14
1D47  003D     MOVLB 0x1D
1D48  00C9     MOVWF SSP2DATPPS
90:                RC3PPS = 0x16;      
1D49  3016     MOVLW 0x16
1D4A  003E     MOVLB 0x1E
1D4B  00A3     MOVWF RC3PPS
91:                RC4PPS = 0x17;      
1D4C  3017     MOVLW 0x17
1D4D  00A4     MOVWF RC4PPS
92:                
93:                //Lock PPS using the locking sequence - CMH
94:                PPSLOCK = 0x55;
1D4E  3055     MOVLW 0x55
1D4F  003D     MOVLB 0x1D
1D50  008F     MOVWF PPSLOCK
95:                PPSLOCK = 0xAA;
1D51  30AA     MOVLW 0xAA
1D52  008F     MOVWF PPSLOCK
96:                PPSLOCKbits.PPSLOCKED = 1;
1D53  140F     BSF PPSLOCK, 0x0
97:               
98:                //Re-enable the necessary interrupts - CMH
99:                PIE3bits.RCIE = 1;
1D54  002E     MOVLB 0xE
1D55  1699     BSF PIE3, 0x5
100:               INTCONbits.PEIE = 1;
1D56  170B     BSF 0x70B, 0x6
101:               INTCONbits.GIE = 1;
1D57  178B     BSF 0x70B, 0x7
102:               PIE0bits.IOCIE = 1;
1D58  1616     BSF PIE0, 0x4
103:            
104:               //Clear all the interrupt flags - CMH
105:               PIR3 = 0;               
1D59  018F     CLRF PIR3
106:           }
1D5A  0008     RETURN
107:           
108:           // ************************************************************
109:           //
110:           //  This function is the second Initialization function for 
111:           //  the port pins. Within all pins are set to be digital, set
112:           //  to be either an input or an output, and the various serial
113:           //  protocols have pins mapped for use. The necessary interrupts
114:           //  are re-enabled and their respective flags are cleared.
115:           //
116:           // ************************************************************
117:           void PORT_PIN_Initialize2(void) {
118:               
119:               //Turn off the interrupts to allow for the PPS unlocking sequence - CMH
120:               PIE3bits.RCIE = 0;
000C  002E     MOVLB 0xE
000D  1299     BCF PIE3, 0x5
121:               INTCONbits.PEIE = 0;
000E  130B     BCF 0x70B, 0x6
122:               INTCONbits.GIE = 0;
000F  138B     BCF 0x70B, 0x7
123:               PIE0bits.IOCIE = 0;
0010  1216     BCF PIE0, 0x4
124:               
125:               //Unlock PPS using the unlocking sequence - CMH
126:               PPSLOCK = 0x55;
0011  3055     MOVLW 0x55
0012  003D     MOVLB 0x1D
0013  008F     MOVWF PPSLOCK
127:               PPSLOCK = 0xAA;
0014  30AA     MOVLW 0xAA
0015  008F     MOVWF PPSLOCK
128:               PPSLOCKbits.PPSLOCKED = 0;
0016  100F     BCF PPSLOCK, 0x0
129:               
130:               //Set up the pins for SPI on SSP2 between PIC and ETH WIZ - CMH
131:               //Replaces the I2C that was previously on SSP2 - CMH
132:               SSP2DATPPS = 0x0A;  
0017  300A     MOVLW 0xA
0018  00C9     MOVWF SSP2DATPPS
133:               RB1PPS = 0x16;      
0019  3016     MOVLW 0x16
001A  003E     MOVLB 0x1E
001B  0099     MOVWF RB1PPS
134:               RB3PPS = 0x17;      
001C  3017     MOVLW 0x17
001D  009B     MOVWF RB3PPS
135:                
136:               //Lock the PPS using the locking sequence - CMH
137:               PPSLOCK = 0x55;
001E  3055     MOVLW 0x55
001F  003D     MOVLB 0x1D
0020  008F     MOVWF PPSLOCK
138:               PPSLOCK = 0xAA;
0021  30AA     MOVLW 0xAA
0022  008F     MOVWF PPSLOCK
139:               PPSLOCKbits.PPSLOCKED = 1;
0023  140F     BSF PPSLOCK, 0x0
140:              
141:               //Re-enable the necessary interrupts - CMH
142:               PIE3bits.RCIE = 1;
0024  002E     MOVLB 0xE
0025  1699     BSF PIE3, 0x5
143:               INTCONbits.PEIE = 1;
0026  170B     BSF 0x70B, 0x6
144:               INTCONbits.GIE = 1;
0027  178B     BSF 0x70B, 0x7
145:               PIE0bits.IOCIE = 1;
0028  1616     BSF PIE0, 0x4
146:               
147:               //Clear all the respective interrupt flags - CMH
148:               PIR3 = 0;              
0029  018F     CLRF PIR3
149:           }
002A  0008     RETURN
---  C:/Users/cmh52/Desktop/SeniorDesign.X/arducam.c  ---------------------------------------------------
1:             /* 
2:              * Search & Rescue Drone
3:              * Data Acquisition Unit Firmware
4:              *  
5:              * Members: Cole Hinton, Zachary Tumbleson, Richard McGinnis, & Jay Elliot
6:              * 
7:              * File: arducam.c
8:              * 
9:              * Date: 1/14/19
10:             * 
11:             * Revision: 0.01
12:             */
13:            
14:            #include "arducam.h"
15:            #include "serial_spi.h"
16:            
17:            // ************************************************************
18:            //
19:            //  This function initializes the arducam to the desired
20:            //  settings through the I2C bus.
21:            //
22:            // ************************************************************
23:            void arducam_initialize(void){
24:                
25:            }
1C7E  0008     RETURN
26:            
27:            
28:            // ************************************************************
29:            //
30:            //  This function gets the captures an image from the buffer
31:            //  on the Arducam using the SPI bus.
32:            //
33:            // ************************************************************
34:            void arducam_capture(void){
35:                
36:                uint8_t data = SPI_Write(0x00);
37:                
38:                
39:            }
40:            
41:            
42:            // ************************************************************
43:            //
44:            //  This function sends the received image from the Arducam 
45:            //  over the SPI to the ETH WIZ to be sent to the ground 
46:            //  station software.
47:            //
48:            // ************************************************************
49:            void arducam_send(void){
50:                
51:            }
---  C:/Users/cmh52/Desktop/SeniorDesign.X/2  -----------------------------------------------------------
1CAB  0000     NOP
1CAC  0000     NOP
1CAD  0000     NOP
1CAE  0000     NOP
1CAF  0000     NOP
1CB0  0000     NOP
1CB1  0000     NOP
1CB2  0000     NOP
1CB3  0008     RETURN
